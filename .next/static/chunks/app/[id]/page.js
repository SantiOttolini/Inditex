/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/[id]/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsantiagoottolini%2FDocuments%2FDownloads%2FZara%2Fapp%2F%5Bid%5D%2Fpage.tsx&server=false!":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsantiagoottolini%2FDocuments%2FDownloads%2FZara%2Fapp%2F%5Bid%5D%2Fpage.tsx&server=false! ***!
  \******************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/[id]/page.tsx */ \"(app-pages-browser)/./app/[id]/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRnNhbnRpYWdvb3R0b2xpbmklMkZEb2N1bWVudHMlMkZEb3dubG9hZHMlMkZaYXJhJTJGYXBwJTJGJTVCaWQlNUQlMkZwYWdlLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/NjA3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9zYW50aWFnb290dG9saW5pL0RvY3VtZW50cy9Eb3dubG9hZHMvWmFyYS9hcHAvW2lkXS9wYWdlLnRzeFwiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsantiagoottolini%2FDocuments%2FDownloads%2FZara%2Fapp%2F%5Bid%5D%2Fpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HiddenText: function() { return /* binding */ HiddenText; },\n/* harmony export */   LiveRegion: function() { return /* binding */ LiveRegion; },\n/* harmony export */   useAnnouncement: function() { return /* binding */ useAnnouncement; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar _s = $RefreshSig$();\n\nconst hiddenStyles = {\n    display: \"none\"\n};\nfunction HiddenText(_ref) {\n    let { id, value } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        id: id,\n        style: hiddenStyles\n    }, value);\n}\n_c = HiddenText;\nfunction LiveRegion(_ref) {\n    let { id, announcement, ariaLiveType = \"assertive\" } = _ref;\n    // Hide element visually but keep it readable by screen readers\n    const visuallyHidden = {\n        position: \"fixed\",\n        width: 1,\n        height: 1,\n        margin: -1,\n        border: 0,\n        padding: 0,\n        overflow: \"hidden\",\n        clip: \"rect(0 0 0 0)\",\n        clipPath: \"inset(100%)\",\n        whiteSpace: \"nowrap\"\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        id: id,\n        style: visuallyHidden,\n        role: \"status\",\n        \"aria-live\": ariaLiveType,\n        \"aria-atomic\": true\n    }, announcement);\n}\n_c1 = LiveRegion;\nfunction useAnnouncement() {\n    _s();\n    const [announcement, setAnnouncement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const announce = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>{\n        if (value != null) {\n            setAnnouncement(value);\n        }\n    }, []);\n    return {\n        announce,\n        announcement\n    };\n}\n_s(useAnnouncement, \"Tya47b9GDQXdn7rcuPs4ijy9Znc=\");\n //# sourceMappingURL=accessibility.esm.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"HiddenText\");\n$RefreshReg$(_c1, \"LiveRegion\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZG5kLWtpdC9hY2Nlc3NpYmlsaXR5L2Rpc3QvYWNjZXNzaWJpbGl0eS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXFEO0FBRXJELE1BQU1HLGVBQWU7SUFDbkJDLFNBQVM7QUFDWDtBQUNBLFNBQVNDLFdBQVdDLElBQUk7SUFDdEIsSUFBSSxFQUNGQyxFQUFFLEVBQ0ZDLEtBQUssRUFDTixHQUFHRjtJQUNKLHFCQUFPTiwwREFBbUIsQ0FBQyxPQUFPO1FBQ2hDTyxJQUFJQTtRQUNKRyxPQUFPUDtJQUNULEdBQUdLO0FBQ0w7S0FUU0g7QUFXVCxTQUFTTSxXQUFXTCxJQUFJO0lBQ3RCLElBQUksRUFDRkMsRUFBRSxFQUNGSyxZQUFZLEVBQ1pDLGVBQWUsV0FBVyxFQUMzQixHQUFHUDtJQUNKLCtEQUErRDtJQUMvRCxNQUFNUSxpQkFBaUI7UUFDckJDLFVBQVU7UUFDVkMsT0FBTztRQUNQQyxRQUFRO1FBQ1JDLFFBQVEsQ0FBQztRQUNUQyxRQUFRO1FBQ1JDLFNBQVM7UUFDVEMsVUFBVTtRQUNWQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsWUFBWTtJQUNkO0lBQ0EscUJBQU94QiwwREFBbUIsQ0FBQyxPQUFPO1FBQ2hDTyxJQUFJQTtRQUNKRyxPQUFPSTtRQUNQVyxNQUFNO1FBQ04sYUFBYVo7UUFDYixlQUFlO0lBQ2pCLEdBQUdEO0FBQ0w7TUExQlNEO0FBNEJULFNBQVNlOztJQUNQLE1BQU0sQ0FBQ2QsY0FBY2UsZ0JBQWdCLEdBQUcxQiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNMkIsV0FBVzFCLGtEQUFXQSxDQUFDTSxDQUFBQTtRQUMzQixJQUFJQSxTQUFTLE1BQU07WUFDakJtQixnQkFBZ0JuQjtRQUNsQjtJQUNGLEdBQUcsRUFBRTtJQUNMLE9BQU87UUFDTG9CO1FBQ0FoQjtJQUNGO0FBQ0Y7R0FYU2M7QUFhMEMsQ0FDbkQsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZG5kLWtpdC9hY2Nlc3NpYmlsaXR5L2Rpc3QvYWNjZXNzaWJpbGl0eS5lc20uanM/Mzc2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBoaWRkZW5TdHlsZXMgPSB7XG4gIGRpc3BsYXk6ICdub25lJ1xufTtcbmZ1bmN0aW9uIEhpZGRlblRleHQoX3JlZikge1xuICBsZXQge1xuICAgIGlkLFxuICAgIHZhbHVlXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgaWQ6IGlkLFxuICAgIHN0eWxlOiBoaWRkZW5TdHlsZXNcbiAgfSwgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBMaXZlUmVnaW9uKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBpZCxcbiAgICBhbm5vdW5jZW1lbnQsXG4gICAgYXJpYUxpdmVUeXBlID0gXCJhc3NlcnRpdmVcIlxuICB9ID0gX3JlZjtcbiAgLy8gSGlkZSBlbGVtZW50IHZpc3VhbGx5IGJ1dCBrZWVwIGl0IHJlYWRhYmxlIGJ5IHNjcmVlbiByZWFkZXJzXG4gIGNvbnN0IHZpc3VhbGx5SGlkZGVuID0ge1xuICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgIHdpZHRoOiAxLFxuICAgIGhlaWdodDogMSxcbiAgICBtYXJnaW46IC0xLFxuICAgIGJvcmRlcjogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gICAgY2xpcFBhdGg6ICdpbnNldCgxMDAlKScsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGlkOiBpZCxcbiAgICBzdHlsZTogdmlzdWFsbHlIaWRkZW4sXG4gICAgcm9sZTogXCJzdGF0dXNcIixcbiAgICBcImFyaWEtbGl2ZVwiOiBhcmlhTGl2ZVR5cGUsXG4gICAgXCJhcmlhLWF0b21pY1wiOiB0cnVlXG4gIH0sIGFubm91bmNlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHVzZUFubm91bmNlbWVudCgpIHtcbiAgY29uc3QgW2Fubm91bmNlbWVudCwgc2V0QW5ub3VuY2VtZW50XSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgYW5ub3VuY2UgPSB1c2VDYWxsYmFjayh2YWx1ZSA9PiB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNldEFubm91bmNlbWVudCh2YWx1ZSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiB7XG4gICAgYW5ub3VuY2UsXG4gICAgYW5ub3VuY2VtZW50XG4gIH07XG59XG5cbmV4cG9ydCB7IEhpZGRlblRleHQsIExpdmVSZWdpb24sIHVzZUFubm91bmNlbWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzaWJpbGl0eS5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiaGlkZGVuU3R5bGVzIiwiZGlzcGxheSIsIkhpZGRlblRleHQiLCJfcmVmIiwiaWQiLCJ2YWx1ZSIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsIkxpdmVSZWdpb24iLCJhbm5vdW5jZW1lbnQiLCJhcmlhTGl2ZVR5cGUiLCJ2aXN1YWxseUhpZGRlbiIsInBvc2l0aW9uIiwid2lkdGgiLCJoZWlnaHQiLCJtYXJnaW4iLCJib3JkZXIiLCJwYWRkaW5nIiwib3ZlcmZsb3ciLCJjbGlwIiwiY2xpcFBhdGgiLCJ3aGl0ZVNwYWNlIiwicm9sZSIsInVzZUFubm91bmNlbWVudCIsInNldEFubm91bmNlbWVudCIsImFubm91bmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dnd-kit/core/dist/core.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/@dnd-kit/core/dist/core.esm.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoScrollActivator: function() { return /* binding */ AutoScrollActivator; },\n/* harmony export */   DndContext: function() { return /* binding */ DndContext; },\n/* harmony export */   DragOverlay: function() { return /* binding */ DragOverlay; },\n/* harmony export */   KeyboardCode: function() { return /* binding */ KeyboardCode; },\n/* harmony export */   KeyboardSensor: function() { return /* binding */ KeyboardSensor; },\n/* harmony export */   MeasuringFrequency: function() { return /* binding */ MeasuringFrequency; },\n/* harmony export */   MeasuringStrategy: function() { return /* binding */ MeasuringStrategy; },\n/* harmony export */   MouseSensor: function() { return /* binding */ MouseSensor; },\n/* harmony export */   PointerSensor: function() { return /* binding */ PointerSensor; },\n/* harmony export */   TouchSensor: function() { return /* binding */ TouchSensor; },\n/* harmony export */   TraversalOrder: function() { return /* binding */ TraversalOrder; },\n/* harmony export */   applyModifiers: function() { return /* binding */ applyModifiers; },\n/* harmony export */   closestCenter: function() { return /* binding */ closestCenter; },\n/* harmony export */   closestCorners: function() { return /* binding */ closestCorners; },\n/* harmony export */   defaultAnnouncements: function() { return /* binding */ defaultAnnouncements; },\n/* harmony export */   defaultCoordinates: function() { return /* binding */ defaultCoordinates; },\n/* harmony export */   defaultDropAnimation: function() { return /* binding */ defaultDropAnimationConfiguration; },\n/* harmony export */   defaultDropAnimationSideEffects: function() { return /* binding */ defaultDropAnimationSideEffects; },\n/* harmony export */   defaultScreenReaderInstructions: function() { return /* binding */ defaultScreenReaderInstructions; },\n/* harmony export */   getClientRect: function() { return /* binding */ getClientRect; },\n/* harmony export */   getFirstCollision: function() { return /* binding */ getFirstCollision; },\n/* harmony export */   getScrollableAncestors: function() { return /* binding */ getScrollableAncestors; },\n/* harmony export */   pointerWithin: function() { return /* binding */ pointerWithin; },\n/* harmony export */   rectIntersection: function() { return /* binding */ rectIntersection; },\n/* harmony export */   useDndContext: function() { return /* binding */ useDndContext; },\n/* harmony export */   useDndMonitor: function() { return /* binding */ useDndMonitor; },\n/* harmony export */   useDraggable: function() { return /* binding */ useDraggable; },\n/* harmony export */   useDroppable: function() { return /* binding */ useDroppable; },\n/* harmony export */   useSensor: function() { return /* binding */ useSensor; },\n/* harmony export */   useSensors: function() { return /* binding */ useSensors; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dnd-kit/utilities */ \"(app-pages-browser)/./node_modules/@dnd-kit/utilities/dist/utilities.esm.js\");\n/* harmony import */ var _dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dnd-kit/accessibility */ \"(app-pages-browser)/./node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$(), _s16 = $RefreshSig$(), _s17 = $RefreshSig$(), _s18 = $RefreshSig$(), _s19 = $RefreshSig$(), _s20 = $RefreshSig$(), _s21 = $RefreshSig$(), _s22 = $RefreshSig$(), _s23 = $RefreshSig$(), _s24 = $RefreshSig$(), _s25 = $RefreshSig$(), _s26 = $RefreshSig$(), _s27 = $RefreshSig$(), _s28 = $RefreshSig$(), _s29 = $RefreshSig$(), _s30 = $RefreshSig$(), _s31 = $RefreshSig$(), _s32 = $RefreshSig$(), _s33 = $RefreshSig$(), _s34 = $RefreshSig$();\n\n\n\n\nconst DndMonitorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useDndMonitor(listener) {\n    _s();\n    const registerListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DndMonitorContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!registerListener) {\n            throw new Error(\"useDndMonitor must be used within a children of <DndContext>\");\n        }\n        const unsubscribe = registerListener(listener);\n        return unsubscribe;\n    }, [\n        listener,\n        registerListener\n    ]);\n}\n_s(useDndMonitor, \"jx47SIBSltS+kv6AOnPEqbrOjnU=\");\nfunction useDndMonitorProvider() {\n    _s1();\n    const [listeners] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new Set());\n    const registerListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((listener)=>{\n        listeners.add(listener);\n        return ()=>listeners.delete(listener);\n    }, [\n        listeners\n    ]);\n    const dispatch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((_ref)=>{\n        let { type, event } = _ref;\n        listeners.forEach((listener)=>{\n            var _listener$type;\n            return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);\n        });\n    }, [\n        listeners\n    ]);\n    return [\n        dispatch,\n        registerListener\n    ];\n}\n_s1(useDndMonitorProvider, \"0gD/AuzMugCzbfEtWwYQ6OWSLPc=\");\nconst defaultScreenReaderInstructions = {\n    draggable: \"\\n    To pick up a draggable item, press the space bar.\\n    While dragging, use the arrow keys to move the item.\\n    Press space again to drop the item in its new position, or press escape to cancel.\\n  \"\n};\nconst defaultAnnouncements = {\n    onDragStart (_ref) {\n        let { active } = _ref;\n        return \"Picked up draggable item \" + active.id + \".\";\n    },\n    onDragOver (_ref2) {\n        let { active, over } = _ref2;\n        if (over) {\n            return \"Draggable item \" + active.id + \" was moved over droppable area \" + over.id + \".\";\n        }\n        return \"Draggable item \" + active.id + \" is no longer over a droppable area.\";\n    },\n    onDragEnd (_ref3) {\n        let { active, over } = _ref3;\n        if (over) {\n            return \"Draggable item \" + active.id + \" was dropped over droppable area \" + over.id;\n        }\n        return \"Draggable item \" + active.id + \" was dropped.\";\n    },\n    onDragCancel (_ref4) {\n        let { active } = _ref4;\n        return \"Dragging was cancelled. Draggable item \" + active.id + \" was dropped.\";\n    }\n};\nfunction Accessibility(_ref) {\n    _s2();\n    let { announcements = defaultAnnouncements, container, hiddenTextDescribedById, screenReaderInstructions = defaultScreenReaderInstructions } = _ref;\n    const { announce, announcement } = (0,_dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.useAnnouncement)();\n    const liveRegionId = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(\"DndLiveRegion\");\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setMounted(true);\n    }, []);\n    useDndMonitor((0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            onDragStart (_ref2) {\n                let { active } = _ref2;\n                announce(announcements.onDragStart({\n                    active\n                }));\n            },\n            onDragMove (_ref3) {\n                let { active, over } = _ref3;\n                if (announcements.onDragMove) {\n                    announce(announcements.onDragMove({\n                        active,\n                        over\n                    }));\n                }\n            },\n            onDragOver (_ref4) {\n                let { active, over } = _ref4;\n                announce(announcements.onDragOver({\n                    active,\n                    over\n                }));\n            },\n            onDragEnd (_ref5) {\n                let { active, over } = _ref5;\n                announce(announcements.onDragEnd({\n                    active,\n                    over\n                }));\n            },\n            onDragCancel (_ref6) {\n                let { active, over } = _ref6;\n                announce(announcements.onDragCancel({\n                    active,\n                    over\n                }));\n            }\n        }), [\n        announce,\n        announcements\n    ]));\n    if (!mounted) {\n        return null;\n    }\n    const markup = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.HiddenText, {\n        id: hiddenTextDescribedById,\n        value: screenReaderInstructions.draggable\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.LiveRegion, {\n        id: liveRegionId,\n        announcement: announcement\n    }));\n    return container ? /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(markup, container) : markup;\n}\n_s2(Accessibility, \"UrFtfNtvs50tXDZXx8jHd0VDBXg=\", false, function() {\n    return [\n        _dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.useAnnouncement,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId,\n        useDndMonitor\n    ];\n});\n_c = Accessibility;\nvar Action;\n(function(Action) {\n    Action[\"DragStart\"] = \"dragStart\";\n    Action[\"DragMove\"] = \"dragMove\";\n    Action[\"DragEnd\"] = \"dragEnd\";\n    Action[\"DragCancel\"] = \"dragCancel\";\n    Action[\"DragOver\"] = \"dragOver\";\n    Action[\"RegisterDroppable\"] = \"registerDroppable\";\n    Action[\"SetDroppableDisabled\"] = \"setDroppableDisabled\";\n    Action[\"UnregisterDroppable\"] = \"unregisterDroppable\";\n})(Action || (Action = {}));\nfunction noop() {}\nfunction useSensor(sensor, options) {\n    _s3();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            sensor,\n            options: options != null ? options : {}\n        }), [\n        sensor,\n        options\n    ]);\n}\n_s3(useSensor, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nfunction useSensors() {\n    _s4();\n    for(var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++){\n        sensors[_key] = arguments[_key];\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n            ...sensors\n        ].filter((sensor)=>sensor != null), [\n        ...sensors\n    ]);\n}\n_s4(useSensors, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nconst defaultCoordinates = /*#__PURE__*/ Object.freeze({\n    x: 0,\n    y: 0\n});\n/**\r\n * Returns the distance between two points\r\n */ function distanceBetween(p1, p2) {\n    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n}\nfunction getRelativeTransformOrigin(event, rect) {\n    const eventCoordinates = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(event);\n    if (!eventCoordinates) {\n        return \"0 0\";\n    }\n    const transformOrigin = {\n        x: (eventCoordinates.x - rect.left) / rect.width * 100,\n        y: (eventCoordinates.y - rect.top) / rect.height * 100\n    };\n    return transformOrigin.x + \"% \" + transformOrigin.y + \"%\";\n}\n/**\r\n * Sort collisions from smallest to greatest value\r\n */ function sortCollisionsAsc(_ref, _ref2) {\n    let { data: { value: a } } = _ref;\n    let { data: { value: b } } = _ref2;\n    return a - b;\n}\n/**\r\n * Sort collisions from greatest to smallest value\r\n */ function sortCollisionsDesc(_ref3, _ref4) {\n    let { data: { value: a } } = _ref3;\n    let { data: { value: b } } = _ref4;\n    return b - a;\n}\n/**\r\n * Returns the coordinates of the corners of a given rectangle:\r\n * [TopLeft {x, y}, TopRight {x, y}, BottomLeft {x, y}, BottomRight {x, y}]\r\n */ function cornersOfRectangle(_ref5) {\n    let { left, top, height, width } = _ref5;\n    return [\n        {\n            x: left,\n            y: top\n        },\n        {\n            x: left + width,\n            y: top\n        },\n        {\n            x: left,\n            y: top + height\n        },\n        {\n            x: left + width,\n            y: top + height\n        }\n    ];\n}\nfunction getFirstCollision(collisions, property) {\n    if (!collisions || collisions.length === 0) {\n        return null;\n    }\n    const [firstCollision] = collisions;\n    return property ? firstCollision[property] : firstCollision;\n}\n/**\r\n * Returns the coordinates of the center of a given ClientRect\r\n */ function centerOfRectangle(rect, left, top) {\n    if (left === void 0) {\n        left = rect.left;\n    }\n    if (top === void 0) {\n        top = rect.top;\n    }\n    return {\n        x: left + rect.width * 0.5,\n        y: top + rect.height * 0.5\n    };\n}\n/**\r\n * Returns the closest rectangles from an array of rectangles to the center of a given\r\n * rectangle.\r\n */ const closestCenter = (_ref)=>{\n    let { collisionRect, droppableRects, droppableContainers } = _ref;\n    const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect) {\n            const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);\n            collisions.push({\n                id,\n                data: {\n                    droppableContainer,\n                    value: distBetween\n                }\n            });\n        }\n    }\n    return collisions.sort(sortCollisionsAsc);\n};\n/**\r\n * Returns the closest rectangles from an array of rectangles to the corners of\r\n * another rectangle.\r\n */ const closestCorners = (_ref)=>{\n    let { collisionRect, droppableRects, droppableContainers } = _ref;\n    const corners = cornersOfRectangle(collisionRect);\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect) {\n            const rectCorners = cornersOfRectangle(rect);\n            const distances = corners.reduce((accumulator, corner, index)=>{\n                return accumulator + distanceBetween(rectCorners[index], corner);\n            }, 0);\n            const effectiveDistance = Number((distances / 4).toFixed(4));\n            collisions.push({\n                id,\n                data: {\n                    droppableContainer,\n                    value: effectiveDistance\n                }\n            });\n        }\n    }\n    return collisions.sort(sortCollisionsAsc);\n};\n/**\r\n * Returns the intersecting rectangle area between two rectangles\r\n */ function getIntersectionRatio(entry, target) {\n    const top = Math.max(target.top, entry.top);\n    const left = Math.max(target.left, entry.left);\n    const right = Math.min(target.left + target.width, entry.left + entry.width);\n    const bottom = Math.min(target.top + target.height, entry.top + entry.height);\n    const width = right - left;\n    const height = bottom - top;\n    if (left < right && top < bottom) {\n        const targetArea = target.width * target.height;\n        const entryArea = entry.width * entry.height;\n        const intersectionArea = width * height;\n        const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);\n        return Number(intersectionRatio.toFixed(4));\n    } // Rectangles do not overlap, or overlap has an area of zero (edge/corner overlap)\n    return 0;\n}\n/**\r\n * Returns the rectangles that has the greatest intersection area with a given\r\n * rectangle in an array of rectangles.\r\n */ const rectIntersection = (_ref)=>{\n    let { collisionRect, droppableRects, droppableContainers } = _ref;\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect) {\n            const intersectionRatio = getIntersectionRatio(rect, collisionRect);\n            if (intersectionRatio > 0) {\n                collisions.push({\n                    id,\n                    data: {\n                        droppableContainer,\n                        value: intersectionRatio\n                    }\n                });\n            }\n        }\n    }\n    return collisions.sort(sortCollisionsDesc);\n};\n/**\r\n * Check if a given point is contained within a bounding rectangle\r\n */ function isPointWithinRect(point, rect) {\n    const { top, left, bottom, right } = rect;\n    return top <= point.y && point.y <= bottom && left <= point.x && point.x <= right;\n}\n/**\r\n * Returns the rectangles that the pointer is hovering over\r\n */ const pointerWithin = (_ref)=>{\n    let { droppableContainers, droppableRects, pointerCoordinates } = _ref;\n    if (!pointerCoordinates) {\n        return [];\n    }\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect && isPointWithinRect(pointerCoordinates, rect)) {\n            /* There may be more than a single rectangle intersecting\r\n       * with the pointer coordinates. In order to sort the\r\n       * colliding rectangles, we measure the distance between\r\n       * the pointer and the corners of the intersecting rectangle\r\n       */ const corners = cornersOfRectangle(rect);\n            const distances = corners.reduce((accumulator, corner)=>{\n                return accumulator + distanceBetween(pointerCoordinates, corner);\n            }, 0);\n            const effectiveDistance = Number((distances / 4).toFixed(4));\n            collisions.push({\n                id,\n                data: {\n                    droppableContainer,\n                    value: effectiveDistance\n                }\n            });\n        }\n    }\n    return collisions.sort(sortCollisionsAsc);\n};\nfunction adjustScale(transform, rect1, rect2) {\n    return {\n        ...transform,\n        scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,\n        scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1\n    };\n}\nfunction getRectDelta(rect1, rect2) {\n    return rect1 && rect2 ? {\n        x: rect1.left - rect2.left,\n        y: rect1.top - rect2.top\n    } : defaultCoordinates;\n}\nfunction createRectAdjustmentFn(modifier) {\n    return function adjustClientRect(rect) {\n        for(var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            adjustments[_key - 1] = arguments[_key];\n        }\n        return adjustments.reduce((acc, adjustment)=>({\n                ...acc,\n                top: acc.top + modifier * adjustment.y,\n                bottom: acc.bottom + modifier * adjustment.y,\n                left: acc.left + modifier * adjustment.x,\n                right: acc.right + modifier * adjustment.x\n            }), {\n            ...rect\n        });\n    };\n}\nconst getAdjustedRect = /*#__PURE__*/ createRectAdjustmentFn(1);\nfunction parseTransform(transform) {\n    if (transform.startsWith(\"matrix3d(\")) {\n        const transformArray = transform.slice(9, -1).split(/, /);\n        return {\n            x: +transformArray[12],\n            y: +transformArray[13],\n            scaleX: +transformArray[0],\n            scaleY: +transformArray[5]\n        };\n    } else if (transform.startsWith(\"matrix(\")) {\n        const transformArray = transform.slice(7, -1).split(/, /);\n        return {\n            x: +transformArray[4],\n            y: +transformArray[5],\n            scaleX: +transformArray[0],\n            scaleY: +transformArray[3]\n        };\n    }\n    return null;\n}\nfunction inverseTransform(rect, transform, transformOrigin) {\n    const parsedTransform = parseTransform(transform);\n    if (!parsedTransform) {\n        return rect;\n    }\n    const { scaleX, scaleY, x: translateX, y: translateY } = parsedTransform;\n    const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);\n    const y = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(\" \") + 1));\n    const w = scaleX ? rect.width / scaleX : rect.width;\n    const h = scaleY ? rect.height / scaleY : rect.height;\n    return {\n        width: w,\n        height: h,\n        top: y,\n        right: x + w,\n        bottom: y + h,\n        left: x\n    };\n}\nconst defaultOptions = {\n    ignoreTransform: false\n};\n/**\r\n * Returns the bounding client rect of an element relative to the viewport.\r\n */ function getClientRect(element, options) {\n    if (options === void 0) {\n        options = defaultOptions;\n    }\n    let rect = element.getBoundingClientRect();\n    if (options.ignoreTransform) {\n        const { transform, transformOrigin } = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(element).getComputedStyle(element);\n        if (transform) {\n            rect = inverseTransform(rect, transform, transformOrigin);\n        }\n    }\n    const { top, left, width, height, bottom, right } = rect;\n    return {\n        top,\n        left,\n        width,\n        height,\n        bottom,\n        right\n    };\n}\n/**\r\n * Returns the bounding client rect of an element relative to the viewport.\r\n *\r\n * @remarks\r\n * The ClientRect returned by this method does not take into account transforms\r\n * applied to the element it measures.\r\n *\r\n */ function getTransformAgnosticClientRect(element) {\n    return getClientRect(element, {\n        ignoreTransform: true\n    });\n}\nfunction getWindowClientRect(element) {\n    const width = element.innerWidth;\n    const height = element.innerHeight;\n    return {\n        top: 0,\n        left: 0,\n        right: width,\n        bottom: height,\n        width,\n        height\n    };\n}\nfunction isFixed(node, computedStyle) {\n    if (computedStyle === void 0) {\n        computedStyle = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(node).getComputedStyle(node);\n    }\n    return computedStyle.position === \"fixed\";\n}\nfunction isScrollable(element, computedStyle) {\n    if (computedStyle === void 0) {\n        computedStyle = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(element).getComputedStyle(element);\n    }\n    const overflowRegex = /(auto|scroll|overlay)/;\n    const properties = [\n        \"overflow\",\n        \"overflowX\",\n        \"overflowY\"\n    ];\n    return properties.some((property)=>{\n        const value = computedStyle[property];\n        return typeof value === \"string\" ? overflowRegex.test(value) : false;\n    });\n}\nfunction getScrollableAncestors(element, limit) {\n    const scrollParents = [];\n    function findScrollableAncestors(node) {\n        if (limit != null && scrollParents.length >= limit) {\n            return scrollParents;\n        }\n        if (!node) {\n            return scrollParents;\n        }\n        if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isDocument)(node) && node.scrollingElement != null && !scrollParents.includes(node.scrollingElement)) {\n            scrollParents.push(node.scrollingElement);\n            return scrollParents;\n        }\n        if (!(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(node) || (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isSVGElement)(node)) {\n            return scrollParents;\n        }\n        if (scrollParents.includes(node)) {\n            return scrollParents;\n        }\n        const computedStyle = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(element).getComputedStyle(node);\n        if (node !== element) {\n            if (isScrollable(node, computedStyle)) {\n                scrollParents.push(node);\n            }\n        }\n        if (isFixed(node, computedStyle)) {\n            return scrollParents;\n        }\n        return findScrollableAncestors(node.parentNode);\n    }\n    if (!element) {\n        return scrollParents;\n    }\n    return findScrollableAncestors(element);\n}\nfunction getFirstScrollableAncestor(node) {\n    const [firstScrollableAncestor] = getScrollableAncestors(node, 1);\n    return firstScrollableAncestor != null ? firstScrollableAncestor : null;\n}\nfunction getScrollableElement(element) {\n    if (!_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseDOM || !element) {\n        return null;\n    }\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isWindow)(element)) {\n        return element;\n    }\n    if (!(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isNode)(element)) {\n        return null;\n    }\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isDocument)(element) || element === (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(element).scrollingElement) {\n        return window;\n    }\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(element)) {\n        return element;\n    }\n    return null;\n}\nfunction getScrollXCoordinate(element) {\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isWindow)(element)) {\n        return element.scrollX;\n    }\n    return element.scrollLeft;\n}\nfunction getScrollYCoordinate(element) {\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isWindow)(element)) {\n        return element.scrollY;\n    }\n    return element.scrollTop;\n}\nfunction getScrollCoordinates(element) {\n    return {\n        x: getScrollXCoordinate(element),\n        y: getScrollYCoordinate(element)\n    };\n}\nvar Direction;\n(function(Direction) {\n    Direction[Direction[\"Forward\"] = 1] = \"Forward\";\n    Direction[Direction[\"Backward\"] = -1] = \"Backward\";\n})(Direction || (Direction = {}));\nfunction isDocumentScrollingElement(element) {\n    if (!_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseDOM || !element) {\n        return false;\n    }\n    return element === document.scrollingElement;\n}\nfunction getScrollPosition(scrollingContainer) {\n    const minScroll = {\n        x: 0,\n        y: 0\n    };\n    const dimensions = isDocumentScrollingElement(scrollingContainer) ? {\n        height: window.innerHeight,\n        width: window.innerWidth\n    } : {\n        height: scrollingContainer.clientHeight,\n        width: scrollingContainer.clientWidth\n    };\n    const maxScroll = {\n        x: scrollingContainer.scrollWidth - dimensions.width,\n        y: scrollingContainer.scrollHeight - dimensions.height\n    };\n    const isTop = scrollingContainer.scrollTop <= minScroll.y;\n    const isLeft = scrollingContainer.scrollLeft <= minScroll.x;\n    const isBottom = scrollingContainer.scrollTop >= maxScroll.y;\n    const isRight = scrollingContainer.scrollLeft >= maxScroll.x;\n    return {\n        isTop,\n        isLeft,\n        isBottom,\n        isRight,\n        maxScroll,\n        minScroll\n    };\n}\nconst defaultThreshold = {\n    x: 0.2,\n    y: 0.2\n};\nfunction getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref, acceleration, thresholdPercentage) {\n    let { top, left, right, bottom } = _ref;\n    if (acceleration === void 0) {\n        acceleration = 10;\n    }\n    if (thresholdPercentage === void 0) {\n        thresholdPercentage = defaultThreshold;\n    }\n    const { isTop, isBottom, isLeft, isRight } = getScrollPosition(scrollContainer);\n    const direction = {\n        x: 0,\n        y: 0\n    };\n    const speed = {\n        x: 0,\n        y: 0\n    };\n    const threshold = {\n        height: scrollContainerRect.height * thresholdPercentage.y,\n        width: scrollContainerRect.width * thresholdPercentage.x\n    };\n    if (!isTop && top <= scrollContainerRect.top + threshold.height) {\n        // Scroll Up\n        direction.y = Direction.Backward;\n        speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);\n    } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {\n        // Scroll Down\n        direction.y = Direction.Forward;\n        speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);\n    }\n    if (!isRight && right >= scrollContainerRect.right - threshold.width) {\n        // Scroll Right\n        direction.x = Direction.Forward;\n        speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);\n    } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {\n        // Scroll Left\n        direction.x = Direction.Backward;\n        speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);\n    }\n    return {\n        direction,\n        speed\n    };\n}\nfunction getScrollElementRect(element) {\n    if (element === document.scrollingElement) {\n        const { innerWidth, innerHeight } = window;\n        return {\n            top: 0,\n            left: 0,\n            right: innerWidth,\n            bottom: innerHeight,\n            width: innerWidth,\n            height: innerHeight\n        };\n    }\n    const { top, left, right, bottom } = element.getBoundingClientRect();\n    return {\n        top,\n        left,\n        right,\n        bottom,\n        width: element.clientWidth,\n        height: element.clientHeight\n    };\n}\nfunction getScrollOffsets(scrollableAncestors) {\n    return scrollableAncestors.reduce((acc, node)=>{\n        return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(acc, getScrollCoordinates(node));\n    }, defaultCoordinates);\n}\nfunction getScrollXOffset(scrollableAncestors) {\n    return scrollableAncestors.reduce((acc, node)=>{\n        return acc + getScrollXCoordinate(node);\n    }, 0);\n}\nfunction getScrollYOffset(scrollableAncestors) {\n    return scrollableAncestors.reduce((acc, node)=>{\n        return acc + getScrollYCoordinate(node);\n    }, 0);\n}\nfunction scrollIntoViewIfNeeded(element, measure) {\n    if (measure === void 0) {\n        measure = getClientRect;\n    }\n    if (!element) {\n        return;\n    }\n    const { top, left, bottom, right } = measure(element);\n    const firstScrollableAncestor = getFirstScrollableAncestor(element);\n    if (!firstScrollableAncestor) {\n        return;\n    }\n    if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {\n        element.scrollIntoView({\n            block: \"center\",\n            inline: \"center\"\n        });\n    }\n}\nconst properties = [\n    [\n        \"x\",\n        [\n            \"left\",\n            \"right\"\n        ],\n        getScrollXOffset\n    ],\n    [\n        \"y\",\n        [\n            \"top\",\n            \"bottom\"\n        ],\n        getScrollYOffset\n    ]\n];\nclass Rect {\n    constructor(rect, element){\n        this.rect = void 0;\n        this.width = void 0;\n        this.height = void 0;\n        this.top = void 0;\n        this.bottom = void 0;\n        this.right = void 0;\n        this.left = void 0;\n        const scrollableAncestors = getScrollableAncestors(element);\n        const scrollOffsets = getScrollOffsets(scrollableAncestors);\n        this.rect = {\n            ...rect\n        };\n        this.width = rect.width;\n        this.height = rect.height;\n        for (const [axis, keys, getScrollOffset] of properties){\n            for (const key of keys){\n                Object.defineProperty(this, key, {\n                    get: ()=>{\n                        const currentOffsets = getScrollOffset(scrollableAncestors);\n                        const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;\n                        return this.rect[key] + scrollOffsetsDeltla;\n                    },\n                    enumerable: true\n                });\n            }\n        }\n        Object.defineProperty(this, \"rect\", {\n            enumerable: false\n        });\n    }\n}\nclass Listeners {\n    add(eventName, handler, options) {\n        var _this$target2;\n        (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);\n        this.listeners.push([\n            eventName,\n            handler,\n            options\n        ]);\n    }\n    constructor(target){\n        this.target = void 0;\n        this.listeners = [];\n        this.removeAll = ()=>{\n            this.listeners.forEach((listener)=>{\n                var _this$target;\n                return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);\n            });\n        };\n        this.target = target;\n    }\n}\nfunction getEventListenerTarget(target) {\n    // If the `event.target` element is removed from the document events will still be targeted\n    // at it, and hence won't always bubble up to the window or document anymore.\n    // If there is any risk of an element being removed while it is being dragged,\n    // the best practice is to attach the event listeners directly to the target.\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n    const { EventTarget } = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(target);\n    return target instanceof EventTarget ? target : (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(target);\n}\nfunction hasExceededDistance(delta, measurement) {\n    const dx = Math.abs(delta.x);\n    const dy = Math.abs(delta.y);\n    if (typeof measurement === \"number\") {\n        return Math.sqrt(dx ** 2 + dy ** 2) > measurement;\n    }\n    if (\"x\" in measurement && \"y\" in measurement) {\n        return dx > measurement.x && dy > measurement.y;\n    }\n    if (\"x\" in measurement) {\n        return dx > measurement.x;\n    }\n    if (\"y\" in measurement) {\n        return dy > measurement.y;\n    }\n    return false;\n}\nvar EventName;\n(function(EventName) {\n    EventName[\"Click\"] = \"click\";\n    EventName[\"DragStart\"] = \"dragstart\";\n    EventName[\"Keydown\"] = \"keydown\";\n    EventName[\"ContextMenu\"] = \"contextmenu\";\n    EventName[\"Resize\"] = \"resize\";\n    EventName[\"SelectionChange\"] = \"selectionchange\";\n    EventName[\"VisibilityChange\"] = \"visibilitychange\";\n})(EventName || (EventName = {}));\nfunction preventDefault(event) {\n    event.preventDefault();\n}\nfunction stopPropagation(event) {\n    event.stopPropagation();\n}\nvar KeyboardCode;\n(function(KeyboardCode) {\n    KeyboardCode[\"Space\"] = \"Space\";\n    KeyboardCode[\"Down\"] = \"ArrowDown\";\n    KeyboardCode[\"Right\"] = \"ArrowRight\";\n    KeyboardCode[\"Left\"] = \"ArrowLeft\";\n    KeyboardCode[\"Up\"] = \"ArrowUp\";\n    KeyboardCode[\"Esc\"] = \"Escape\";\n    KeyboardCode[\"Enter\"] = \"Enter\";\n})(KeyboardCode || (KeyboardCode = {}));\nconst defaultKeyboardCodes = {\n    start: [\n        KeyboardCode.Space,\n        KeyboardCode.Enter\n    ],\n    cancel: [\n        KeyboardCode.Esc\n    ],\n    end: [\n        KeyboardCode.Space,\n        KeyboardCode.Enter\n    ]\n};\nconst defaultKeyboardCoordinateGetter = (event, _ref)=>{\n    let { currentCoordinates } = _ref;\n    switch(event.code){\n        case KeyboardCode.Right:\n            return {\n                ...currentCoordinates,\n                x: currentCoordinates.x + 25\n            };\n        case KeyboardCode.Left:\n            return {\n                ...currentCoordinates,\n                x: currentCoordinates.x - 25\n            };\n        case KeyboardCode.Down:\n            return {\n                ...currentCoordinates,\n                y: currentCoordinates.y + 25\n            };\n        case KeyboardCode.Up:\n            return {\n                ...currentCoordinates,\n                y: currentCoordinates.y - 25\n            };\n    }\n    return undefined;\n};\nclass KeyboardSensor {\n    attach() {\n        this.handleStart();\n        this.windowListeners.add(EventName.Resize, this.handleCancel);\n        this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);\n        setTimeout(()=>this.listeners.add(EventName.Keydown, this.handleKeyDown));\n    }\n    handleStart() {\n        const { activeNode, onStart } = this.props;\n        const node = activeNode.node.current;\n        if (node) {\n            scrollIntoViewIfNeeded(node);\n        }\n        onStart(defaultCoordinates);\n    }\n    handleKeyDown(event) {\n        if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(event)) {\n            const { active, context, options } = this.props;\n            const { keyboardCodes = defaultKeyboardCodes, coordinateGetter = defaultKeyboardCoordinateGetter, scrollBehavior = \"smooth\" } = options;\n            const { code } = event;\n            if (keyboardCodes.end.includes(code)) {\n                this.handleEnd(event);\n                return;\n            }\n            if (keyboardCodes.cancel.includes(code)) {\n                this.handleCancel(event);\n                return;\n            }\n            const { collisionRect } = context.current;\n            const currentCoordinates = collisionRect ? {\n                x: collisionRect.left,\n                y: collisionRect.top\n            } : defaultCoordinates;\n            if (!this.referenceCoordinates) {\n                this.referenceCoordinates = currentCoordinates;\n            }\n            const newCoordinates = coordinateGetter(event, {\n                active,\n                context: context.current,\n                currentCoordinates\n            });\n            if (newCoordinates) {\n                const coordinatesDelta = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(newCoordinates, currentCoordinates);\n                const scrollDelta = {\n                    x: 0,\n                    y: 0\n                };\n                const { scrollableAncestors } = context.current;\n                for (const scrollContainer of scrollableAncestors){\n                    const direction = event.code;\n                    const { isTop, isRight, isLeft, isBottom, maxScroll, minScroll } = getScrollPosition(scrollContainer);\n                    const scrollElementRect = getScrollElementRect(scrollContainer);\n                    const clampedCoordinates = {\n                        x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),\n                        y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))\n                    };\n                    const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;\n                    const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;\n                    if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {\n                        const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;\n                        const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;\n                        if (canScrollToNewCoordinates && !coordinatesDelta.y) {\n                            // We don't need to update coordinates, the scroll adjustment alone will trigger\n                            // logic to auto-detect the new container we are over\n                            scrollContainer.scrollTo({\n                                left: newScrollCoordinates,\n                                behavior: scrollBehavior\n                            });\n                            return;\n                        }\n                        if (canScrollToNewCoordinates) {\n                            scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;\n                        } else {\n                            scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;\n                        }\n                        if (scrollDelta.x) {\n                            scrollContainer.scrollBy({\n                                left: -scrollDelta.x,\n                                behavior: scrollBehavior\n                            });\n                        }\n                        break;\n                    } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {\n                        const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;\n                        const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;\n                        if (canScrollToNewCoordinates && !coordinatesDelta.x) {\n                            // We don't need to update coordinates, the scroll adjustment alone will trigger\n                            // logic to auto-detect the new container we are over\n                            scrollContainer.scrollTo({\n                                top: newScrollCoordinates,\n                                behavior: scrollBehavior\n                            });\n                            return;\n                        }\n                        if (canScrollToNewCoordinates) {\n                            scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;\n                        } else {\n                            scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;\n                        }\n                        if (scrollDelta.y) {\n                            scrollContainer.scrollBy({\n                                top: -scrollDelta.y,\n                                behavior: scrollBehavior\n                            });\n                        }\n                        break;\n                    }\n                }\n                this.handleMove(event, (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(newCoordinates, this.referenceCoordinates), scrollDelta));\n            }\n        }\n    }\n    handleMove(event, coordinates) {\n        const { onMove } = this.props;\n        event.preventDefault();\n        onMove(coordinates);\n    }\n    handleEnd(event) {\n        const { onEnd } = this.props;\n        event.preventDefault();\n        this.detach();\n        onEnd();\n    }\n    handleCancel(event) {\n        const { onCancel } = this.props;\n        event.preventDefault();\n        this.detach();\n        onCancel();\n    }\n    detach() {\n        this.listeners.removeAll();\n        this.windowListeners.removeAll();\n    }\n    constructor(props){\n        this.props = void 0;\n        this.autoScrollEnabled = false;\n        this.referenceCoordinates = void 0;\n        this.listeners = void 0;\n        this.windowListeners = void 0;\n        this.props = props;\n        const { event: { target } } = props;\n        this.props = props;\n        this.listeners = new Listeners((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(target));\n        this.windowListeners = new Listeners((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(target));\n        this.handleKeyDown = this.handleKeyDown.bind(this);\n        this.handleCancel = this.handleCancel.bind(this);\n        this.attach();\n    }\n}\nKeyboardSensor.activators = [\n    {\n        eventName: \"onKeyDown\",\n        handler: (event, _ref, _ref2)=>{\n            let { keyboardCodes = defaultKeyboardCodes, onActivation } = _ref;\n            let { active } = _ref2;\n            const { code } = event.nativeEvent;\n            if (keyboardCodes.start.includes(code)) {\n                const activator = active.activatorNode.current;\n                if (activator && event.target !== activator) {\n                    return false;\n                }\n                event.preventDefault();\n                onActivation == null ? void 0 : onActivation({\n                    event: event.nativeEvent\n                });\n                return true;\n            }\n            return false;\n        }\n    }\n];\nfunction isDistanceConstraint(constraint) {\n    return Boolean(constraint && \"distance\" in constraint);\n}\nfunction isDelayConstraint(constraint) {\n    return Boolean(constraint && \"delay\" in constraint);\n}\nclass AbstractPointerSensor {\n    attach() {\n        const { events, props: { options: { activationConstraint, bypassActivationConstraint } } } = this;\n        this.listeners.add(events.move.name, this.handleMove, {\n            passive: false\n        });\n        this.listeners.add(events.end.name, this.handleEnd);\n        this.windowListeners.add(EventName.Resize, this.handleCancel);\n        this.windowListeners.add(EventName.DragStart, preventDefault);\n        this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);\n        this.windowListeners.add(EventName.ContextMenu, preventDefault);\n        this.documentListeners.add(EventName.Keydown, this.handleKeydown);\n        if (activationConstraint) {\n            if (bypassActivationConstraint != null && bypassActivationConstraint({\n                event: this.props.event,\n                activeNode: this.props.activeNode,\n                options: this.props.options\n            })) {\n                return this.handleStart();\n            }\n            if (isDelayConstraint(activationConstraint)) {\n                this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);\n                return;\n            }\n            if (isDistanceConstraint(activationConstraint)) {\n                return;\n            }\n        }\n        this.handleStart();\n    }\n    detach() {\n        this.listeners.removeAll();\n        this.windowListeners.removeAll(); // Wait until the next event loop before removing document listeners\n        // This is necessary because we listen for `click` and `selection` events on the document\n        setTimeout(this.documentListeners.removeAll, 50);\n        if (this.timeoutId !== null) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = null;\n        }\n    }\n    handleStart() {\n        const { initialCoordinates } = this;\n        const { onStart } = this.props;\n        if (initialCoordinates) {\n            this.activated = true; // Stop propagation of click events once activation constraints are met\n            this.documentListeners.add(EventName.Click, stopPropagation, {\n                capture: true\n            }); // Remove any text selection from the document\n            this.removeTextSelection(); // Prevent further text selection while dragging\n            this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);\n            onStart(initialCoordinates);\n        }\n    }\n    handleMove(event) {\n        var _getEventCoordinates2;\n        const { activated, initialCoordinates, props } = this;\n        const { onMove, options: { activationConstraint } } = props;\n        if (!initialCoordinates) {\n            return;\n        }\n        const coordinates = (_getEventCoordinates2 = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(event)) != null ? _getEventCoordinates2 : defaultCoordinates;\n        const delta = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(initialCoordinates, coordinates); // Constraint validation\n        if (!activated && activationConstraint) {\n            if (isDistanceConstraint(activationConstraint)) {\n                if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {\n                    return this.handleCancel();\n                }\n                if (hasExceededDistance(delta, activationConstraint.distance)) {\n                    return this.handleStart();\n                }\n            }\n            if (isDelayConstraint(activationConstraint)) {\n                if (hasExceededDistance(delta, activationConstraint.tolerance)) {\n                    return this.handleCancel();\n                }\n            }\n            return;\n        }\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        onMove(coordinates);\n    }\n    handleEnd() {\n        const { onEnd } = this.props;\n        this.detach();\n        onEnd();\n    }\n    handleCancel() {\n        const { onCancel } = this.props;\n        this.detach();\n        onCancel();\n    }\n    handleKeydown(event) {\n        if (event.code === KeyboardCode.Esc) {\n            this.handleCancel();\n        }\n    }\n    removeTextSelection() {\n        var _this$document$getSel;\n        (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();\n    }\n    constructor(props, events, listenerTarget){\n        var _getEventCoordinates;\n        if (listenerTarget === void 0) {\n            listenerTarget = getEventListenerTarget(props.event.target);\n        }\n        this.props = void 0;\n        this.events = void 0;\n        this.autoScrollEnabled = true;\n        this.document = void 0;\n        this.activated = false;\n        this.initialCoordinates = void 0;\n        this.timeoutId = null;\n        this.listeners = void 0;\n        this.documentListeners = void 0;\n        this.windowListeners = void 0;\n        this.props = props;\n        this.events = events;\n        const { event } = props;\n        const { target } = event;\n        this.props = props;\n        this.events = events;\n        this.document = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(target);\n        this.documentListeners = new Listeners(this.document);\n        this.listeners = new Listeners(listenerTarget);\n        this.windowListeners = new Listeners((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(target));\n        this.initialCoordinates = (_getEventCoordinates = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(event)) != null ? _getEventCoordinates : defaultCoordinates;\n        this.handleStart = this.handleStart.bind(this);\n        this.handleMove = this.handleMove.bind(this);\n        this.handleEnd = this.handleEnd.bind(this);\n        this.handleCancel = this.handleCancel.bind(this);\n        this.handleKeydown = this.handleKeydown.bind(this);\n        this.removeTextSelection = this.removeTextSelection.bind(this);\n        this.attach();\n    }\n}\nconst events = {\n    move: {\n        name: \"pointermove\"\n    },\n    end: {\n        name: \"pointerup\"\n    }\n};\nclass PointerSensor extends AbstractPointerSensor {\n    constructor(props){\n        const { event } = props; // Pointer events stop firing if the target is unmounted while dragging\n        // Therefore we attach listeners to the owner document instead\n        const listenerTarget = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(event.target);\n        super(props, events, listenerTarget);\n    }\n}\nPointerSensor.activators = [\n    {\n        eventName: \"onPointerDown\",\n        handler: (_ref, _ref2)=>{\n            let { nativeEvent: event } = _ref;\n            let { onActivation } = _ref2;\n            if (!event.isPrimary || event.button !== 0) {\n                return false;\n            }\n            onActivation == null ? void 0 : onActivation({\n                event\n            });\n            return true;\n        }\n    }\n];\nconst events$1 = {\n    move: {\n        name: \"mousemove\"\n    },\n    end: {\n        name: \"mouseup\"\n    }\n};\nvar MouseButton;\n(function(MouseButton) {\n    MouseButton[MouseButton[\"RightClick\"] = 2] = \"RightClick\";\n})(MouseButton || (MouseButton = {}));\nclass MouseSensor extends AbstractPointerSensor {\n    constructor(props){\n        super(props, events$1, (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(props.event.target));\n    }\n}\nMouseSensor.activators = [\n    {\n        eventName: \"onMouseDown\",\n        handler: (_ref, _ref2)=>{\n            let { nativeEvent: event } = _ref;\n            let { onActivation } = _ref2;\n            if (event.button === MouseButton.RightClick) {\n                return false;\n            }\n            onActivation == null ? void 0 : onActivation({\n                event\n            });\n            return true;\n        }\n    }\n];\nconst events$2 = {\n    move: {\n        name: \"touchmove\"\n    },\n    end: {\n        name: \"touchend\"\n    }\n};\nclass TouchSensor extends AbstractPointerSensor {\n    static setup() {\n        // Adding a non-capture and non-passive `touchmove` listener in order\n        // to force `event.preventDefault()` calls to work in dynamically added\n        // touchmove event handlers. This is required for iOS Safari.\n        window.addEventListener(events$2.move.name, noop, {\n            capture: false,\n            passive: false\n        });\n        return function teardown() {\n            window.removeEventListener(events$2.move.name, noop);\n        }; // We create a new handler because the teardown function of another sensor\n        // could remove our event listener if we use a referentially equal listener.\n        function noop() {}\n    }\n    constructor(props){\n        super(props, events$2);\n    }\n}\nTouchSensor.activators = [\n    {\n        eventName: \"onTouchStart\",\n        handler: (_ref, _ref2)=>{\n            let { nativeEvent: event } = _ref;\n            let { onActivation } = _ref2;\n            const { touches } = event;\n            if (touches.length > 1) {\n                return false;\n            }\n            onActivation == null ? void 0 : onActivation({\n                event\n            });\n            return true;\n        }\n    }\n];\nvar AutoScrollActivator;\n(function(AutoScrollActivator) {\n    AutoScrollActivator[AutoScrollActivator[\"Pointer\"] = 0] = \"Pointer\";\n    AutoScrollActivator[AutoScrollActivator[\"DraggableRect\"] = 1] = \"DraggableRect\";\n})(AutoScrollActivator || (AutoScrollActivator = {}));\nvar TraversalOrder;\n(function(TraversalOrder) {\n    TraversalOrder[TraversalOrder[\"TreeOrder\"] = 0] = \"TreeOrder\";\n    TraversalOrder[TraversalOrder[\"ReversedTreeOrder\"] = 1] = \"ReversedTreeOrder\";\n})(TraversalOrder || (TraversalOrder = {}));\nfunction useAutoScroller(_ref) {\n    _s5();\n    let { acceleration, activator = AutoScrollActivator.Pointer, canScroll, draggingRect, enabled, interval = 5, order = TraversalOrder.TreeOrder, pointerCoordinates, scrollableAncestors, scrollableAncestorRects, delta, threshold } = _ref;\n    const scrollIntent = useScrollIntent({\n        delta,\n        disabled: !enabled\n    });\n    const [setAutoScrollInterval, clearAutoScrollInterval] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useInterval)();\n    const scrollSpeed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const scrollDirection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const rect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        switch(activator){\n            case AutoScrollActivator.Pointer:\n                return pointerCoordinates ? {\n                    top: pointerCoordinates.y,\n                    bottom: pointerCoordinates.y,\n                    left: pointerCoordinates.x,\n                    right: pointerCoordinates.x\n                } : null;\n            case AutoScrollActivator.DraggableRect:\n                return draggingRect;\n        }\n    }, [\n        activator,\n        draggingRect,\n        pointerCoordinates\n    ]);\n    const scrollContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const autoScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const scrollContainer = scrollContainerRef.current;\n        if (!scrollContainer) {\n            return;\n        }\n        const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;\n        const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;\n        scrollContainer.scrollBy(scrollLeft, scrollTop);\n    }, []);\n    const sortedScrollableAncestors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>order === TraversalOrder.TreeOrder ? [\n            ...scrollableAncestors\n        ].reverse() : scrollableAncestors, [\n        order,\n        scrollableAncestors\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!enabled || !scrollableAncestors.length || !rect) {\n            clearAutoScrollInterval();\n            return;\n        }\n        for (const scrollContainer of sortedScrollableAncestors){\n            if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {\n                continue;\n            }\n            const index = scrollableAncestors.indexOf(scrollContainer);\n            const scrollContainerRect = scrollableAncestorRects[index];\n            if (!scrollContainerRect) {\n                continue;\n            }\n            const { direction, speed } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);\n            for (const axis of [\n                \"x\",\n                \"y\"\n            ]){\n                if (!scrollIntent[axis][direction[axis]]) {\n                    speed[axis] = 0;\n                    direction[axis] = 0;\n                }\n            }\n            if (speed.x > 0 || speed.y > 0) {\n                clearAutoScrollInterval();\n                scrollContainerRef.current = scrollContainer;\n                setAutoScrollInterval(autoScroll, interval);\n                scrollSpeed.current = speed;\n                scrollDirection.current = direction;\n                return;\n            }\n        }\n        scrollSpeed.current = {\n            x: 0,\n            y: 0\n        };\n        scrollDirection.current = {\n            x: 0,\n            y: 0\n        };\n        clearAutoScrollInterval();\n    }, [\n        acceleration,\n        autoScroll,\n        canScroll,\n        clearAutoScrollInterval,\n        enabled,\n        interval,\n        JSON.stringify(rect),\n        JSON.stringify(scrollIntent),\n        setAutoScrollInterval,\n        scrollableAncestors,\n        sortedScrollableAncestors,\n        scrollableAncestorRects,\n        JSON.stringify(threshold)\n    ]);\n}\n_s5(useAutoScroller, \"05PP1A+hj+2QT+727BzRvKIUu/g=\", false, function() {\n    return [\n        useScrollIntent,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useInterval\n    ];\n});\nconst defaultScrollIntent = {\n    x: {\n        [Direction.Backward]: false,\n        [Direction.Forward]: false\n    },\n    y: {\n        [Direction.Backward]: false,\n        [Direction.Forward]: false\n    }\n};\nfunction useScrollIntent(_ref2) {\n    _s6();\n    let { delta, disabled } = _ref2;\n    const previousDelta = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(delta);\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousIntent)=>{\n        if (disabled || !previousDelta || !previousIntent) {\n            // Reset scroll intent tracking when auto-scrolling is disabled\n            return defaultScrollIntent;\n        }\n        const direction = {\n            x: Math.sign(delta.x - previousDelta.x),\n            y: Math.sign(delta.y - previousDelta.y)\n        }; // Keep track of the user intent to scroll in each direction for both axis\n        return {\n            x: {\n                [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,\n                [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1\n            },\n            y: {\n                [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,\n                [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1\n            }\n        };\n    }, [\n        disabled,\n        delta,\n        previousDelta\n    ]);\n}\n_s6(useScrollIntent, \"w0nq+bUtbIED4FFUYX+zM6zwT/A=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo\n    ];\n});\nfunction useCachedNode(draggableNodes, id) {\n    _s7();\n    const draggableNode = id !== null ? draggableNodes.get(id) : undefined;\n    const node = draggableNode ? draggableNode.node.current : null;\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((cachedNode)=>{\n        var _ref;\n        if (id === null) {\n            return null;\n        } // In some cases, the draggable node can unmount while dragging\n        // This is the case for virtualized lists. In those situations,\n        // we fall back to the last known value for that node.\n        return (_ref = node != null ? node : cachedNode) != null ? _ref : null;\n    }, [\n        node,\n        id\n    ]);\n}\n_s7(useCachedNode, \"PD3L6ddlQf2Qhh98aOFrwTwnHDw=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo\n    ];\n});\nfunction useCombineActivators(sensors, getSyntheticHandler) {\n    _s8();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>sensors.reduce((accumulator, sensor)=>{\n            const { sensor: Sensor } = sensor;\n            const sensorActivators = Sensor.activators.map((activator)=>({\n                    eventName: activator.eventName,\n                    handler: getSyntheticHandler(activator.handler, sensor)\n                }));\n            return [\n                ...accumulator,\n                ...sensorActivators\n            ];\n        }, []), [\n        sensors,\n        getSyntheticHandler\n    ]);\n}\n_s8(useCombineActivators, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nvar MeasuringStrategy;\n(function(MeasuringStrategy) {\n    MeasuringStrategy[MeasuringStrategy[\"Always\"] = 0] = \"Always\";\n    MeasuringStrategy[MeasuringStrategy[\"BeforeDragging\"] = 1] = \"BeforeDragging\";\n    MeasuringStrategy[MeasuringStrategy[\"WhileDragging\"] = 2] = \"WhileDragging\";\n})(MeasuringStrategy || (MeasuringStrategy = {}));\nvar MeasuringFrequency;\n(function(MeasuringFrequency) {\n    MeasuringFrequency[\"Optimized\"] = \"optimized\";\n})(MeasuringFrequency || (MeasuringFrequency = {}));\nconst defaultValue = /*#__PURE__*/ new Map();\nfunction useDroppableMeasuring(containers, _ref) {\n    _s9();\n    let { dragging, dependencies, config } = _ref;\n    const [queue, setQueue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { frequency, measure, strategy } = config;\n    const containersRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(containers);\n    const disabled = isDisabled();\n    const disabledRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(disabled);\n    const measureDroppableContainers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(ids) {\n        if (ids === void 0) {\n            ids = [];\n        }\n        if (disabledRef.current) {\n            return;\n        }\n        setQueue((value)=>{\n            if (value === null) {\n                return ids;\n            }\n            return value.concat(ids.filter((id)=>!value.includes(id)));\n        });\n    }, [\n        disabledRef\n    ]);\n    const timeoutId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const droppableRects = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousValue)=>{\n        if (disabled && !dragging) {\n            return defaultValue;\n        }\n        if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {\n            const map = new Map();\n            for (let container of containers){\n                if (!container) {\n                    continue;\n                }\n                if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {\n                    // This container does not need to be re-measured\n                    map.set(container.id, container.rect.current);\n                    continue;\n                }\n                const node = container.node.current;\n                const rect = node ? new Rect(measure(node), node) : null;\n                container.rect.current = rect;\n                if (rect) {\n                    map.set(container.id, rect);\n                }\n            }\n            return map;\n        }\n        return previousValue;\n    }, [\n        containers,\n        queue,\n        dragging,\n        disabled,\n        measure\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        containersRef.current = containers;\n    }, [\n        containers\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled) {\n            return;\n        }\n        measureDroppableContainers();\n    }, [\n        dragging,\n        disabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (queue && queue.length > 0) {\n            setQueue(null);\n        }\n    }, [\n        JSON.stringify(queue)\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled || typeof frequency !== \"number\" || timeoutId.current !== null) {\n            return;\n        }\n        timeoutId.current = setTimeout(()=>{\n            measureDroppableContainers();\n            timeoutId.current = null;\n        }, frequency);\n    }, [\n        frequency,\n        disabled,\n        measureDroppableContainers,\n        ...dependencies\n    ]);\n    return {\n        droppableRects,\n        measureDroppableContainers,\n        measuringScheduled: queue != null\n    };\n    function isDisabled() {\n        switch(strategy){\n            case MeasuringStrategy.Always:\n                return false;\n            case MeasuringStrategy.BeforeDragging:\n                return dragging;\n            default:\n                return !dragging;\n        }\n    }\n}\n_s9(useDroppableMeasuring, \"hA9GE5WOFluLxRXiVEK/FvWnSFg=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo\n    ];\n});\nfunction useInitialValue(value, computeFn) {\n    _s10();\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousValue)=>{\n        if (!value) {\n            return null;\n        }\n        if (previousValue) {\n            return previousValue;\n        }\n        return typeof computeFn === \"function\" ? computeFn(value) : value;\n    }, [\n        computeFn,\n        value\n    ]);\n}\n_s10(useInitialValue, \"PD3L6ddlQf2Qhh98aOFrwTwnHDw=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo\n    ];\n});\nfunction useInitialRect(node, measure) {\n    _s11();\n    return useInitialValue(node, measure);\n}\n_s11(useInitialRect, \"qFbOeZhs+QGTE2i0EQpB+4kcCWc=\", false, function() {\n    return [\n        useInitialValue\n    ];\n});\n/**\r\n * Returns a new MutationObserver instance.\r\n * If `MutationObserver` is undefined in the execution environment, returns `undefined`.\r\n */ function useMutationObserver(_ref) {\n    _s12();\n    let { callback, disabled } = _ref;\n    const handleMutations = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent)(callback);\n    const mutationObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (disabled || \"object\" === \"undefined\" || typeof window.MutationObserver === \"undefined\") {\n            return undefined;\n        }\n        const { MutationObserver } = window;\n        return new MutationObserver(handleMutations);\n    }, [\n        handleMutations,\n        disabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>mutationObserver == null ? void 0 : mutationObserver.disconnect();\n    }, [\n        mutationObserver\n    ]);\n    return mutationObserver;\n}\n_s12(useMutationObserver, \"Y/qWgtYVQEJx9TeK9zfNERgyowE=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent\n    ];\n});\n/**\r\n * Returns a new ResizeObserver instance bound to the `onResize` callback.\r\n * If `ResizeObserver` is undefined in the execution environment, returns `undefined`.\r\n */ function useResizeObserver(_ref) {\n    _s13();\n    let { callback, disabled } = _ref;\n    const handleResize = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent)(callback);\n    const resizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (disabled || \"object\" === \"undefined\" || typeof window.ResizeObserver === \"undefined\") {\n            return undefined;\n        }\n        const { ResizeObserver } = window;\n        return new ResizeObserver(handleResize);\n    }, [\n        disabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>resizeObserver == null ? void 0 : resizeObserver.disconnect();\n    }, [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\n_s13(useResizeObserver, \"rNUr96JNe4liR53VN7gZb/olFNE=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent\n    ];\n});\nfunction defaultMeasure(element) {\n    return new Rect(getClientRect(element), element);\n}\nfunction useRect(element, measure, fallbackRect) {\n    _s14();\n    if (measure === void 0) {\n        measure = defaultMeasure;\n    }\n    const [rect, measureRect] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, null);\n    const mutationObserver = useMutationObserver({\n        callback (records) {\n            if (!element) {\n                return;\n            }\n            for (const record of records){\n                const { type, target } = record;\n                if (type === \"childList\" && target instanceof HTMLElement && target.contains(element)) {\n                    measureRect();\n                    break;\n                }\n            }\n        }\n    });\n    const resizeObserver = useResizeObserver({\n        callback: measureRect\n    });\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        measureRect();\n        if (element) {\n            resizeObserver == null ? void 0 : resizeObserver.observe(element);\n            mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {\n                childList: true,\n                subtree: true\n            });\n        } else {\n            resizeObserver == null ? void 0 : resizeObserver.disconnect();\n            mutationObserver == null ? void 0 : mutationObserver.disconnect();\n        }\n    }, [\n        element\n    ]);\n    return rect;\n    function reducer(currentRect) {\n        if (!element) {\n            return null;\n        }\n        if (element.isConnected === false) {\n            var _ref;\n            // Fall back to last rect we measured if the element is\n            // no longer connected to the DOM.\n            return (_ref = currentRect != null ? currentRect : fallbackRect) != null ? _ref : null;\n        }\n        const newRect = measure(element);\n        if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {\n            return currentRect;\n        }\n        return newRect;\n    }\n}\n_s14(useRect, \"9k3o4QDqHJXgkhxmxwVFG7cEnUo=\", false, function() {\n    return [\n        useMutationObserver,\n        useResizeObserver,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect\n    ];\n});\nfunction useRectDelta(rect) {\n    _s15();\n    const initialRect = useInitialValue(rect);\n    return getRectDelta(rect, initialRect);\n}\n_s15(useRectDelta, \"8UqbiBhMohR1aMrK7M02IdrspaU=\", false, function() {\n    return [\n        useInitialValue\n    ];\n});\nconst defaultValue$1 = [];\nfunction useScrollableAncestors(node) {\n    _s16();\n    const previousNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(node);\n    const ancestors = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousValue)=>{\n        if (!node) {\n            return defaultValue$1;\n        }\n        if (previousValue && previousValue !== defaultValue$1 && node && previousNode.current && node.parentNode === previousNode.current.parentNode) {\n            return previousValue;\n        }\n        return getScrollableAncestors(node);\n    }, [\n        node\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        previousNode.current = node;\n    }, [\n        node\n    ]);\n    return ancestors;\n}\n_s16(useScrollableAncestors, \"cs2paWHKgwbQFKuSkBxyMKFT9z4=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo\n    ];\n});\nfunction useScrollOffsets(elements) {\n    _s17();\n    const [scrollCoordinates, setScrollCoordinates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const prevElements = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(elements); // To-do: Throttle the handleScroll callback\n    const handleScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        const scrollingElement = getScrollableElement(event.target);\n        if (!scrollingElement) {\n            return;\n        }\n        setScrollCoordinates((scrollCoordinates)=>{\n            if (!scrollCoordinates) {\n                return null;\n            }\n            scrollCoordinates.set(scrollingElement, getScrollCoordinates(scrollingElement));\n            return new Map(scrollCoordinates);\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const previousElements = prevElements.current;\n        if (elements !== previousElements) {\n            cleanup(previousElements);\n            const entries = elements.map((element)=>{\n                const scrollableElement = getScrollableElement(element);\n                if (scrollableElement) {\n                    scrollableElement.addEventListener(\"scroll\", handleScroll, {\n                        passive: true\n                    });\n                    return [\n                        scrollableElement,\n                        getScrollCoordinates(scrollableElement)\n                    ];\n                }\n                return null;\n            }).filter((entry)=>entry != null);\n            setScrollCoordinates(entries.length ? new Map(entries) : null);\n            prevElements.current = elements;\n        }\n        return ()=>{\n            cleanup(elements);\n            cleanup(previousElements);\n        };\n        function cleanup(elements) {\n            elements.forEach((element)=>{\n                const scrollableElement = getScrollableElement(element);\n                scrollableElement == null ? void 0 : scrollableElement.removeEventListener(\"scroll\", handleScroll);\n            });\n        }\n    }, [\n        handleScroll,\n        elements\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (elements.length) {\n            return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates)=>(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);\n        }\n        return defaultCoordinates;\n    }, [\n        elements,\n        scrollCoordinates\n    ]);\n}\n_s17(useScrollOffsets, \"6GawyVApG8q1uwjSAFEA4Tix1hk=\");\nfunction useScrollOffsetsDelta(scrollOffsets, dependencies) {\n    _s18();\n    if (dependencies === void 0) {\n        dependencies = [];\n    }\n    const initialScrollOffsets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        initialScrollOffsets.current = null;\n    }, dependencies);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const hasScrollOffsets = scrollOffsets !== defaultCoordinates;\n        if (hasScrollOffsets && !initialScrollOffsets.current) {\n            initialScrollOffsets.current = scrollOffsets;\n        }\n        if (!hasScrollOffsets && initialScrollOffsets.current) {\n            initialScrollOffsets.current = null;\n        }\n    }, [\n        scrollOffsets\n    ]);\n    return initialScrollOffsets.current ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;\n}\n_s18(useScrollOffsetsDelta, \"CLGa6Hjrt8mpel6U7abI7JMcvBE=\");\nfunction useSensorSetup(sensors) {\n    _s19();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseDOM) {\n            return;\n        }\n        const teardownFns = sensors.map((_ref)=>{\n            let { sensor } = _ref;\n            return sensor.setup == null ? void 0 : sensor.setup();\n        });\n        return ()=>{\n            for (const teardown of teardownFns){\n                teardown == null ? void 0 : teardown();\n            }\n        };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    sensors.map((_ref2)=>{\n        let { sensor } = _ref2;\n        return sensor;\n    }));\n}\n_s19(useSensorSetup, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nfunction useSyntheticListeners(listeners, id) {\n    _s20();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return listeners.reduce((acc, _ref)=>{\n            let { eventName, handler } = _ref;\n            acc[eventName] = (event)=>{\n                handler(event, id);\n            };\n            return acc;\n        }, {});\n    }, [\n        listeners,\n        id\n    ]);\n}\n_s20(useSyntheticListeners, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nfunction useWindowRect(element) {\n    _s21();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>element ? getWindowClientRect(element) : null, [\n        element\n    ]);\n}\n_s21(useWindowRect, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nconst defaultValue$2 = [];\nfunction useRects(elements, measure) {\n    _s22();\n    if (measure === void 0) {\n        measure = getClientRect;\n    }\n    const [firstElement] = elements;\n    const windowRect = useWindowRect(firstElement ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(firstElement) : null);\n    const [rects, measureRects] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, defaultValue$2);\n    const resizeObserver = useResizeObserver({\n        callback: measureRects\n    });\n    if (elements.length > 0 && rects === defaultValue$2) {\n        measureRects();\n    }\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (elements.length) {\n            elements.forEach((element)=>resizeObserver == null ? void 0 : resizeObserver.observe(element));\n        } else {\n            resizeObserver == null ? void 0 : resizeObserver.disconnect();\n            measureRects();\n        }\n    }, [\n        elements\n    ]);\n    return rects;\n    function reducer() {\n        if (!elements.length) {\n            return defaultValue$2;\n        }\n        return elements.map((element)=>isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));\n    }\n}\n_s22(useRects, \"Fn8KoymndSmHfXAJIh4O/sNSCVA=\", false, function() {\n    return [\n        useWindowRect,\n        useResizeObserver,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect\n    ];\n});\nfunction getMeasurableNode(node) {\n    if (!node) {\n        return null;\n    }\n    if (node.children.length > 1) {\n        return node;\n    }\n    const firstChild = node.children[0];\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(firstChild) ? firstChild : node;\n}\nfunction useDragOverlayMeasuring(_ref) {\n    _s23();\n    let { measure } = _ref;\n    const [rect, setRect] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((entries)=>{\n        for (const { target } of entries){\n            if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(target)) {\n                setRect((rect)=>{\n                    const newRect = measure(target);\n                    return rect ? {\n                        ...rect,\n                        width: newRect.width,\n                        height: newRect.height\n                    } : newRect;\n                });\n                break;\n            }\n        }\n    }, [\n        measure\n    ]);\n    const resizeObserver = useResizeObserver({\n        callback: handleResize\n    });\n    const handleNodeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((element)=>{\n        const node = getMeasurableNode(element);\n        resizeObserver == null ? void 0 : resizeObserver.disconnect();\n        if (node) {\n            resizeObserver == null ? void 0 : resizeObserver.observe(node);\n        }\n        setRect(node ? measure(node) : null);\n    }, [\n        measure,\n        resizeObserver\n    ]);\n    const [nodeRef, setRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)(handleNodeChange);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            nodeRef,\n            rect,\n            setRef\n        }), [\n        rect,\n        nodeRef,\n        setRef\n    ]);\n}\n_s23(useDragOverlayMeasuring, \"VfPDS+0K2yofPDukMZlVKrd8uQw=\", false, function() {\n    return [\n        useResizeObserver,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef\n    ];\n});\nconst defaultSensors = [\n    {\n        sensor: PointerSensor,\n        options: {}\n    },\n    {\n        sensor: KeyboardSensor,\n        options: {}\n    }\n];\nconst defaultData = {\n    current: {}\n};\nconst defaultMeasuringConfiguration = {\n    draggable: {\n        measure: getTransformAgnosticClientRect\n    },\n    droppable: {\n        measure: getTransformAgnosticClientRect,\n        strategy: MeasuringStrategy.WhileDragging,\n        frequency: MeasuringFrequency.Optimized\n    },\n    dragOverlay: {\n        measure: getClientRect\n    }\n};\nclass DroppableContainersMap extends Map {\n    get(id) {\n        var _super$get;\n        return id != null ? (_super$get = super.get(id)) != null ? _super$get : undefined : undefined;\n    }\n    toArray() {\n        return Array.from(this.values());\n    }\n    getEnabled() {\n        return this.toArray().filter((_ref)=>{\n            let { disabled } = _ref;\n            return !disabled;\n        });\n    }\n    getNodeFor(id) {\n        var _this$get$node$curren, _this$get;\n        return (_this$get$node$curren = (_this$get = this.get(id)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : undefined;\n    }\n}\nconst defaultPublicContext = {\n    activatorEvent: null,\n    active: null,\n    activeNode: null,\n    activeNodeRect: null,\n    collisions: null,\n    containerNodeRect: null,\n    draggableNodes: /*#__PURE__*/ new Map(),\n    droppableRects: /*#__PURE__*/ new Map(),\n    droppableContainers: /*#__PURE__*/ new DroppableContainersMap(),\n    over: null,\n    dragOverlay: {\n        nodeRef: {\n            current: null\n        },\n        rect: null,\n        setRef: noop\n    },\n    scrollableAncestors: [],\n    scrollableAncestorRects: [],\n    measuringConfiguration: defaultMeasuringConfiguration,\n    measureDroppableContainers: noop,\n    windowRect: null,\n    measuringScheduled: false\n};\nconst defaultInternalContext = {\n    activatorEvent: null,\n    activators: [],\n    active: null,\n    activeNodeRect: null,\n    ariaDescribedById: {\n        draggable: \"\"\n    },\n    dispatch: noop,\n    draggableNodes: /*#__PURE__*/ new Map(),\n    over: null,\n    measureDroppableContainers: noop\n};\nconst InternalContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultInternalContext);\nconst PublicContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultPublicContext);\nfunction getInitialState() {\n    return {\n        draggable: {\n            active: null,\n            initialCoordinates: {\n                x: 0,\n                y: 0\n            },\n            nodes: new Map(),\n            translate: {\n                x: 0,\n                y: 0\n            }\n        },\n        droppable: {\n            containers: new DroppableContainersMap()\n        }\n    };\n}\nfunction reducer(state, action) {\n    switch(action.type){\n        case Action.DragStart:\n            return {\n                ...state,\n                draggable: {\n                    ...state.draggable,\n                    initialCoordinates: action.initialCoordinates,\n                    active: action.active\n                }\n            };\n        case Action.DragMove:\n            if (!state.draggable.active) {\n                return state;\n            }\n            return {\n                ...state,\n                draggable: {\n                    ...state.draggable,\n                    translate: {\n                        x: action.coordinates.x - state.draggable.initialCoordinates.x,\n                        y: action.coordinates.y - state.draggable.initialCoordinates.y\n                    }\n                }\n            };\n        case Action.DragEnd:\n        case Action.DragCancel:\n            return {\n                ...state,\n                draggable: {\n                    ...state.draggable,\n                    active: null,\n                    initialCoordinates: {\n                        x: 0,\n                        y: 0\n                    },\n                    translate: {\n                        x: 0,\n                        y: 0\n                    }\n                }\n            };\n        case Action.RegisterDroppable:\n            {\n                const { element } = action;\n                const { id } = element;\n                const containers = new DroppableContainersMap(state.droppable.containers);\n                containers.set(id, element);\n                return {\n                    ...state,\n                    droppable: {\n                        ...state.droppable,\n                        containers\n                    }\n                };\n            }\n        case Action.SetDroppableDisabled:\n            {\n                const { id, key, disabled } = action;\n                const element = state.droppable.containers.get(id);\n                if (!element || key !== element.key) {\n                    return state;\n                }\n                const containers = new DroppableContainersMap(state.droppable.containers);\n                containers.set(id, {\n                    ...element,\n                    disabled\n                });\n                return {\n                    ...state,\n                    droppable: {\n                        ...state.droppable,\n                        containers\n                    }\n                };\n            }\n        case Action.UnregisterDroppable:\n            {\n                const { id, key } = action;\n                const element = state.droppable.containers.get(id);\n                if (!element || key !== element.key) {\n                    return state;\n                }\n                const containers = new DroppableContainersMap(state.droppable.containers);\n                containers.delete(id);\n                return {\n                    ...state,\n                    droppable: {\n                        ...state.droppable,\n                        containers\n                    }\n                };\n            }\n        default:\n            {\n                return state;\n            }\n    }\n}\nfunction RestoreFocus(_ref) {\n    _s24();\n    let { disabled } = _ref;\n    const { active, activatorEvent, draggableNodes } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(InternalContext);\n    const previousActivatorEvent = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(activatorEvent);\n    const previousActiveId = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(active == null ? void 0 : active.id); // Restore keyboard focus on the activator node\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled) {\n            return;\n        }\n        if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {\n            if (!(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(previousActivatorEvent)) {\n                return;\n            }\n            if (document.activeElement === previousActivatorEvent.target) {\n                // No need to restore focus\n                return;\n            }\n            const draggableNode = draggableNodes.get(previousActiveId);\n            if (!draggableNode) {\n                return;\n            }\n            const { activatorNode, node } = draggableNode;\n            if (!activatorNode.current && !node.current) {\n                return;\n            }\n            requestAnimationFrame(()=>{\n                for (const element of [\n                    activatorNode.current,\n                    node.current\n                ]){\n                    if (!element) {\n                        continue;\n                    }\n                    const focusableNode = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.findFirstFocusableNode)(element);\n                    if (focusableNode) {\n                        focusableNode.focus();\n                        break;\n                    }\n                }\n            });\n        }\n    }, [\n        activatorEvent,\n        disabled,\n        draggableNodes,\n        previousActiveId,\n        previousActivatorEvent\n    ]);\n    return null;\n}\n_s24(RestoreFocus, \"E1ABFJd+EwkXOVLdzfP1f83RfV4=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious\n    ];\n});\n_c1 = RestoreFocus;\nfunction applyModifiers(modifiers, _ref) {\n    let { transform, ...args } = _ref;\n    return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier)=>{\n        return modifier({\n            transform: accumulator,\n            ...args\n        });\n    }, transform) : transform;\n}\nfunction useMeasuringConfiguration(config) {\n    _s25();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            draggable: {\n                ...defaultMeasuringConfiguration.draggable,\n                ...config == null ? void 0 : config.draggable\n            },\n            droppable: {\n                ...defaultMeasuringConfiguration.droppable,\n                ...config == null ? void 0 : config.droppable\n            },\n            dragOverlay: {\n                ...defaultMeasuringConfiguration.dragOverlay,\n                ...config == null ? void 0 : config.dragOverlay\n            }\n        }), [\n        config == null ? void 0 : config.draggable,\n        config == null ? void 0 : config.droppable,\n        config == null ? void 0 : config.dragOverlay\n    ]);\n}\n_s25(useMeasuringConfiguration, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nfunction useLayoutShiftScrollCompensation(_ref) {\n    _s26();\n    let { activeNode, measure, initialRect, config = true } = _ref;\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const { x, y } = typeof config === \"boolean\" ? {\n        x: config,\n        y: config\n    } : config;\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        const disabled = !x && !y;\n        if (disabled || !activeNode) {\n            initialized.current = false;\n            return;\n        }\n        if (initialized.current || !initialRect) {\n            // Return early if layout shift scroll compensation was already attempted\n            // or if there is no initialRect to compare to.\n            return;\n        } // Get the most up to date node ref for the active draggable\n        const node = activeNode == null ? void 0 : activeNode.node.current;\n        if (!node || node.isConnected === false) {\n            // Return early if there is no attached node ref or if the node is\n            // disconnected from the document.\n            return;\n        }\n        const rect = measure(node);\n        const rectDelta = getRectDelta(rect, initialRect);\n        if (!x) {\n            rectDelta.x = 0;\n        }\n        if (!y) {\n            rectDelta.y = 0;\n        } // Only perform layout shift scroll compensation once\n        initialized.current = true;\n        if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {\n            const firstScrollableAncestor = getFirstScrollableAncestor(node);\n            if (firstScrollableAncestor) {\n                firstScrollableAncestor.scrollBy({\n                    top: rectDelta.y,\n                    left: rectDelta.x\n                });\n            }\n        }\n    }, [\n        activeNode,\n        x,\n        y,\n        initialRect,\n        measure\n    ]);\n}\n_s26(useLayoutShiftScrollCompensation, \"9LJ6T+upbkZ2j+5Fp/oxo9wLdgA=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect\n    ];\n});\nconst ActiveDraggableContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    ...defaultCoordinates,\n    scaleX: 1,\n    scaleY: 1\n});\nvar Status;\n(function(Status) {\n    Status[Status[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    Status[Status[\"Initializing\"] = 1] = \"Initializing\";\n    Status[Status[\"Initialized\"] = 2] = \"Initialized\";\n})(Status || (Status = {}));\nconst DndContext = /*#__PURE__*/ _s27((0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(_c2 = _s27(function DndContext(_ref) {\n    _s27();\n    var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;\n    let { id, accessibility, autoScroll = true, children, sensors = defaultSensors, collisionDetection = rectIntersection, measuring, modifiers, ...props } = _ref;\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, undefined, getInitialState);\n    const [state, dispatch] = store;\n    const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(Status.Uninitialized);\n    const isInitialized = status === Status.Initialized;\n    const { draggable: { active: activeId, nodes: draggableNodes, translate }, droppable: { containers: droppableContainers } } = state;\n    const node = activeId ? draggableNodes.get(activeId) : null;\n    const activeRects = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        initial: null,\n        translated: null\n    });\n    const active = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _node$data;\n        return activeId != null ? {\n            id: activeId,\n            // It's possible for the active node to unmount while dragging\n            data: (_node$data = node == null ? void 0 : node.data) != null ? _node$data : defaultData,\n            rect: activeRects\n        } : null;\n    }, [\n        activeId,\n        node\n    ]);\n    const activeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [activeSensor, setActiveSensor] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [activatorEvent, setActivatorEvent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const latestProps = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(props, Object.values(props));\n    const draggableDescribedById = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(\"DndDescribedBy\", id);\n    const enabledDroppableContainers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>droppableContainers.getEnabled(), [\n        droppableContainers\n    ]);\n    const measuringConfiguration = useMeasuringConfiguration(measuring);\n    const { droppableRects, measureDroppableContainers, measuringScheduled } = useDroppableMeasuring(enabledDroppableContainers, {\n        dragging: isInitialized,\n        dependencies: [\n            translate.x,\n            translate.y\n        ],\n        config: measuringConfiguration.droppable\n    });\n    const activeNode = useCachedNode(draggableNodes, activeId);\n    const activationCoordinates = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>activatorEvent ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(activatorEvent) : null, [\n        activatorEvent\n    ]);\n    const autoScrollOptions = getAutoScrollerOptions();\n    const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);\n    useLayoutShiftScrollCompensation({\n        activeNode: activeId ? draggableNodes.get(activeId) : null,\n        config: autoScrollOptions.layoutShiftCompensation,\n        initialRect: initialActiveNodeRect,\n        measure: measuringConfiguration.draggable.measure\n    });\n    const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);\n    const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);\n    const sensorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        activatorEvent: null,\n        active: null,\n        activeNode,\n        collisionRect: null,\n        collisions: null,\n        droppableRects,\n        draggableNodes,\n        draggingNode: null,\n        draggingNodeRect: null,\n        droppableContainers,\n        over: null,\n        scrollableAncestors: [],\n        scrollAdjustedTranslate: null\n    });\n    const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);\n    const dragOverlay = useDragOverlayMeasuring({\n        measure: measuringConfiguration.dragOverlay.measure\n    }); // Use the rect of the drag overlay if it is mounted\n    const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;\n    const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;\n    const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect); // The delta between the previous and new position of the draggable node\n    // is only relevant when there is no drag overlay\n    const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect); // Get the window rect of the dragging node\n    const windowRect = useWindowRect(draggingNode ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(draggingNode) : null); // Get scrollable ancestors of the dragging node\n    const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);\n    const scrollableAncestorRects = useRects(scrollableAncestors); // Apply modifiers\n    const modifiedTranslate = applyModifiers(modifiers, {\n        transform: {\n            x: translate.x - nodeRectDelta.x,\n            y: translate.y - nodeRectDelta.y,\n            scaleX: 1,\n            scaleY: 1\n        },\n        activatorEvent,\n        active,\n        activeNodeRect,\n        containerNodeRect,\n        draggingNodeRect,\n        over: sensorContext.current.over,\n        overlayNodeRect: dragOverlay.rect,\n        scrollableAncestors,\n        scrollableAncestorRects,\n        windowRect\n    });\n    const pointerCoordinates = activationCoordinates ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(activationCoordinates, translate) : null;\n    const scrollOffsets = useScrollOffsets(scrollableAncestors); // Represents the scroll delta since dragging was initiated\n    const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets); // Represents the scroll delta since the last time the active node rect was measured\n    const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [\n        activeNodeRect\n    ]);\n    const scrollAdjustedTranslate = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(modifiedTranslate, scrollAdjustment);\n    const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;\n    const collisions = active && collisionRect ? collisionDetection({\n        active,\n        collisionRect,\n        droppableRects,\n        droppableContainers: enabledDroppableContainers,\n        pointerCoordinates\n    }) : null;\n    const overId = getFirstCollision(collisions, \"id\");\n    const [over, setOver] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null); // When there is no drag overlay used, we need to account for the\n    // window scroll delta\n    const appliedTranslate = usesDragOverlay ? modifiedTranslate : (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(modifiedTranslate, activeNodeScrollDelta);\n    const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);\n    const instantiateSensor = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event, _ref2)=>{\n        let { sensor: Sensor, options } = _ref2;\n        if (activeRef.current == null) {\n            return;\n        }\n        const activeNode = draggableNodes.get(activeRef.current);\n        if (!activeNode) {\n            return;\n        }\n        const activatorEvent = event.nativeEvent;\n        const sensorInstance = new Sensor({\n            active: activeRef.current,\n            activeNode,\n            event: activatorEvent,\n            options,\n            // Sensors need to be instantiated with refs for arguments that change over time\n            // otherwise they are frozen in time with the stale arguments\n            context: sensorContext,\n            onStart (initialCoordinates) {\n                const id = activeRef.current;\n                if (id == null) {\n                    return;\n                }\n                const draggableNode = draggableNodes.get(id);\n                if (!draggableNode) {\n                    return;\n                }\n                const { onDragStart } = latestProps.current;\n                const event = {\n                    active: {\n                        id,\n                        data: draggableNode.data,\n                        rect: activeRects\n                    }\n                };\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n                    onDragStart == null ? void 0 : onDragStart(event);\n                    setStatus(Status.Initializing);\n                    dispatch({\n                        type: Action.DragStart,\n                        initialCoordinates,\n                        active: id\n                    });\n                    dispatchMonitorEvent({\n                        type: \"onDragStart\",\n                        event\n                    });\n                });\n            },\n            onMove (coordinates) {\n                dispatch({\n                    type: Action.DragMove,\n                    coordinates\n                });\n            },\n            onEnd: createHandler(Action.DragEnd),\n            onCancel: createHandler(Action.DragCancel)\n        });\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n            setActiveSensor(sensorInstance);\n            setActivatorEvent(event.nativeEvent);\n        });\n        function createHandler(type) {\n            return async function handler() {\n                const { active, collisions, over, scrollAdjustedTranslate } = sensorContext.current;\n                let event = null;\n                if (active && scrollAdjustedTranslate) {\n                    const { cancelDrop } = latestProps.current;\n                    event = {\n                        activatorEvent,\n                        active: active,\n                        collisions,\n                        delta: scrollAdjustedTranslate,\n                        over\n                    };\n                    if (type === Action.DragEnd && typeof cancelDrop === \"function\") {\n                        const shouldCancel = await Promise.resolve(cancelDrop(event));\n                        if (shouldCancel) {\n                            type = Action.DragCancel;\n                        }\n                    }\n                }\n                activeRef.current = null;\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n                    dispatch({\n                        type\n                    });\n                    setStatus(Status.Uninitialized);\n                    setOver(null);\n                    setActiveSensor(null);\n                    setActivatorEvent(null);\n                    const eventName = type === Action.DragEnd ? \"onDragEnd\" : \"onDragCancel\";\n                    if (event) {\n                        const handler = latestProps.current[eventName];\n                        handler == null ? void 0 : handler(event);\n                        dispatchMonitorEvent({\n                            type: eventName,\n                            event\n                        });\n                    }\n                });\n            };\n        }\n    }, [\n        draggableNodes\n    ]);\n    const bindActivatorToSensorInstantiator = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((handler, sensor)=>{\n        return (event, active)=>{\n            const nativeEvent = event.nativeEvent;\n            const activeDraggableNode = draggableNodes.get(active);\n            if (activeRef.current !== null || // No active draggable\n            !activeDraggableNode || // Event has already been captured\n            nativeEvent.dndKit || nativeEvent.defaultPrevented) {\n                return;\n            }\n            const activationContext = {\n                active: activeDraggableNode\n            };\n            const shouldActivate = handler(event, sensor.options, activationContext);\n            if (shouldActivate === true) {\n                nativeEvent.dndKit = {\n                    capturedBy: sensor.sensor\n                };\n                activeRef.current = active;\n                instantiateSensor(event, sensor);\n            }\n        };\n    }, [\n        draggableNodes,\n        instantiateSensor\n    ]);\n    const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);\n    useSensorSetup(sensors);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (activeNodeRect && status === Status.Initializing) {\n            setStatus(Status.Initialized);\n        }\n    }, [\n        activeNodeRect,\n        status\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { onDragMove } = latestProps.current;\n        const { active, activatorEvent, collisions, over } = sensorContext.current;\n        if (!active || !activatorEvent) {\n            return;\n        }\n        const event = {\n            active,\n            activatorEvent,\n            collisions,\n            delta: {\n                x: scrollAdjustedTranslate.x,\n                y: scrollAdjustedTranslate.y\n            },\n            over\n        };\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n            onDragMove == null ? void 0 : onDragMove(event);\n            dispatchMonitorEvent({\n                type: \"onDragMove\",\n                event\n            });\n        });\n    }, [\n        scrollAdjustedTranslate.x,\n        scrollAdjustedTranslate.y\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { active, activatorEvent, collisions, droppableContainers, scrollAdjustedTranslate } = sensorContext.current;\n        if (!active || activeRef.current == null || !activatorEvent || !scrollAdjustedTranslate) {\n            return;\n        }\n        const { onDragOver } = latestProps.current;\n        const overContainer = droppableContainers.get(overId);\n        const over = overContainer && overContainer.rect.current ? {\n            id: overContainer.id,\n            rect: overContainer.rect.current,\n            data: overContainer.data,\n            disabled: overContainer.disabled\n        } : null;\n        const event = {\n            active,\n            activatorEvent,\n            collisions,\n            delta: {\n                x: scrollAdjustedTranslate.x,\n                y: scrollAdjustedTranslate.y\n            },\n            over\n        };\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n            setOver(over);\n            onDragOver == null ? void 0 : onDragOver(event);\n            dispatchMonitorEvent({\n                type: \"onDragOver\",\n                event\n            });\n        });\n    }, [\n        overId\n    ]);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        sensorContext.current = {\n            activatorEvent,\n            active,\n            activeNode,\n            collisionRect,\n            collisions,\n            droppableRects,\n            draggableNodes,\n            draggingNode,\n            draggingNodeRect,\n            droppableContainers,\n            over,\n            scrollableAncestors,\n            scrollAdjustedTranslate\n        };\n        activeRects.current = {\n            initial: draggingNodeRect,\n            translated: collisionRect\n        };\n    }, [\n        active,\n        activeNode,\n        collisions,\n        collisionRect,\n        draggableNodes,\n        draggingNode,\n        draggingNodeRect,\n        droppableRects,\n        droppableContainers,\n        over,\n        scrollableAncestors,\n        scrollAdjustedTranslate\n    ]);\n    useAutoScroller({\n        ...autoScrollOptions,\n        delta: translate,\n        draggingRect: collisionRect,\n        pointerCoordinates,\n        scrollableAncestors,\n        scrollableAncestorRects\n    });\n    const publicContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const context = {\n            active,\n            activeNode,\n            activeNodeRect,\n            activatorEvent,\n            collisions,\n            containerNodeRect,\n            dragOverlay,\n            draggableNodes,\n            droppableContainers,\n            droppableRects,\n            over,\n            measureDroppableContainers,\n            scrollableAncestors,\n            scrollableAncestorRects,\n            measuringConfiguration,\n            measuringScheduled,\n            windowRect\n        };\n        return context;\n    }, [\n        active,\n        activeNode,\n        activeNodeRect,\n        activatorEvent,\n        collisions,\n        containerNodeRect,\n        dragOverlay,\n        draggableNodes,\n        droppableContainers,\n        droppableRects,\n        over,\n        measureDroppableContainers,\n        scrollableAncestors,\n        scrollableAncestorRects,\n        measuringConfiguration,\n        measuringScheduled,\n        windowRect\n    ]);\n    const internalContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const context = {\n            activatorEvent,\n            activators,\n            active,\n            activeNodeRect,\n            ariaDescribedById: {\n                draggable: draggableDescribedById\n            },\n            dispatch,\n            draggableNodes,\n            over,\n            measureDroppableContainers\n        };\n        return context;\n    }, [\n        activatorEvent,\n        activators,\n        active,\n        activeNodeRect,\n        dispatch,\n        draggableDescribedById,\n        draggableNodes,\n        over,\n        measureDroppableContainers\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DndMonitorContext.Provider, {\n        value: registerMonitorListener\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(InternalContext.Provider, {\n        value: internalContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PublicContext.Provider, {\n        value: publicContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ActiveDraggableContext.Provider, {\n        value: transform\n    }, children)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RestoreFocus, {\n        disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Accessibility, {\n        ...accessibility,\n        hiddenTextDescribedById: draggableDescribedById\n    }));\n    function getAutoScrollerOptions() {\n        const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;\n        const autoScrollGloballyDisabled = typeof autoScroll === \"object\" ? autoScroll.enabled === false : autoScroll === false;\n        const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;\n        if (typeof autoScroll === \"object\") {\n            return {\n                ...autoScroll,\n                enabled\n            };\n        }\n        return {\n            enabled\n        };\n    }\n}, \"jVLYn+ke3aHO5KJOBA1nZY04uAI=\", false, function() {\n    return [\n        useDndMonitorProvider,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId,\n        useMeasuringConfiguration,\n        useDroppableMeasuring,\n        useCachedNode,\n        useInitialRect,\n        useLayoutShiftScrollCompensation,\n        useRect,\n        useRect,\n        useDragOverlayMeasuring,\n        useRectDelta,\n        useWindowRect,\n        useScrollableAncestors,\n        useRects,\n        useScrollOffsets,\n        useScrollOffsetsDelta,\n        useScrollOffsetsDelta,\n        useCombineActivators,\n        useSensorSetup,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect,\n        useAutoScroller\n    ];\n})), \"jVLYn+ke3aHO5KJOBA1nZY04uAI=\", false, function() {\n    return [\n        useDndMonitorProvider,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId,\n        useMeasuringConfiguration,\n        useDroppableMeasuring,\n        useCachedNode,\n        useInitialRect,\n        useLayoutShiftScrollCompensation,\n        useRect,\n        useRect,\n        useDragOverlayMeasuring,\n        useRectDelta,\n        useWindowRect,\n        useScrollableAncestors,\n        useRects,\n        useScrollOffsets,\n        useScrollOffsetsDelta,\n        useScrollOffsetsDelta,\n        useCombineActivators,\n        useSensorSetup,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect,\n        useAutoScroller\n    ];\n});\n_c3 = DndContext;\nconst NullContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst defaultRole = \"button\";\nconst ID_PREFIX = \"Droppable\";\nfunction useDraggable(_ref) {\n    _s28();\n    let { id, data, disabled = false, attributes } = _ref;\n    const key = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX);\n    const { activators, activatorEvent, active, activeNodeRect, ariaDescribedById, draggableNodes, over } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(InternalContext);\n    const { role = defaultRole, roleDescription = \"draggable\", tabIndex = 0 } = attributes != null ? attributes : {};\n    const isDragging = (active == null ? void 0 : active.id) === id;\n    const transform = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(isDragging ? ActiveDraggableContext : NullContext);\n    const [node, setNodeRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)();\n    const [activatorNode, setActivatorNodeRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)();\n    const listeners = useSyntheticListeners(activators, id);\n    const dataRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(data);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        draggableNodes.set(id, {\n            id,\n            key,\n            node,\n            activatorNode,\n            data: dataRef\n        });\n        return ()=>{\n            const node = draggableNodes.get(id);\n            if (node && node.key === key) {\n                draggableNodes.delete(id);\n            }\n        };\n    }, [\n        draggableNodes,\n        id\n    ]);\n    const memoizedAttributes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            role,\n            tabIndex,\n            \"aria-disabled\": disabled,\n            \"aria-pressed\": isDragging && role === defaultRole ? true : undefined,\n            \"aria-roledescription\": roleDescription,\n            \"aria-describedby\": ariaDescribedById.draggable\n        }), [\n        disabled,\n        role,\n        tabIndex,\n        isDragging,\n        roleDescription,\n        ariaDescribedById.draggable\n    ]);\n    return {\n        active,\n        activatorEvent,\n        activeNodeRect,\n        attributes: memoizedAttributes,\n        isDragging,\n        listeners: disabled ? undefined : listeners,\n        node,\n        over,\n        setNodeRef,\n        setActivatorNodeRef,\n        transform\n    };\n}\n_s28(useDraggable, \"4ncs7kEez+lXoXaDIIvPxN+mCdE=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef,\n        useSyntheticListeners,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect\n    ];\n});\nfunction useDndContext() {\n    _s29();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PublicContext);\n}\n_s29(useDndContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ID_PREFIX$1 = \"Droppable\";\nconst defaultResizeObserverConfig = {\n    timeout: 25\n};\nfunction useDroppable(_ref) {\n    _s30();\n    let { data, disabled = false, id, resizeObserverConfig } = _ref;\n    const key = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX$1);\n    const { active, dispatch, over, measureDroppableContainers } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(InternalContext);\n    const previous = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        disabled\n    });\n    const resizeObserverConnected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const rect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const callbackId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { disabled: resizeObserverDisabled, updateMeasurementsFor, timeout: resizeObserverTimeout } = {\n        ...defaultResizeObserverConfig,\n        ...resizeObserverConfig\n    };\n    const ids = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(updateMeasurementsFor != null ? updateMeasurementsFor : id);\n    const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!resizeObserverConnected.current) {\n            // ResizeObserver invokes the `handleResize` callback as soon as `observe` is called,\n            // assuming the element is rendered and displayed.\n            resizeObserverConnected.current = true;\n            return;\n        }\n        if (callbackId.current != null) {\n            clearTimeout(callbackId.current);\n        }\n        callbackId.current = setTimeout(()=>{\n            measureDroppableContainers(Array.isArray(ids.current) ? ids.current : [\n                ids.current\n            ]);\n            callbackId.current = null;\n        }, resizeObserverTimeout);\n    }, [\n        resizeObserverTimeout\n    ]);\n    const resizeObserver = useResizeObserver({\n        callback: handleResize,\n        disabled: resizeObserverDisabled || !active\n    });\n    const handleNodeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newElement, previousElement)=>{\n        if (!resizeObserver) {\n            return;\n        }\n        if (previousElement) {\n            resizeObserver.unobserve(previousElement);\n            resizeObserverConnected.current = false;\n        }\n        if (newElement) {\n            resizeObserver.observe(newElement);\n        }\n    }, [\n        resizeObserver\n    ]);\n    const [nodeRef, setNodeRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)(handleNodeChange);\n    const dataRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(data);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!resizeObserver || !nodeRef.current) {\n            return;\n        }\n        resizeObserver.disconnect();\n        resizeObserverConnected.current = false;\n        resizeObserver.observe(nodeRef.current);\n    }, [\n        nodeRef,\n        resizeObserver\n    ]);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        dispatch({\n            type: Action.RegisterDroppable,\n            element: {\n                id,\n                key,\n                disabled,\n                node: nodeRef,\n                rect,\n                data: dataRef\n            }\n        });\n        return ()=>dispatch({\n                type: Action.UnregisterDroppable,\n                key,\n                id\n            });\n    }, [\n        id\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled !== previous.current.disabled) {\n            dispatch({\n                type: Action.SetDroppableDisabled,\n                id,\n                key,\n                disabled\n            });\n            previous.current.disabled = disabled;\n        }\n    }, [\n        id,\n        key,\n        disabled,\n        dispatch\n    ]);\n    return {\n        active,\n        rect,\n        isOver: (over == null ? void 0 : over.id) === id,\n        node: nodeRef,\n        over,\n        setNodeRef\n    };\n}\n_s30(useDroppable, \"dY0CpesBrYmPKq29fkig63jpsPU=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue,\n        useResizeObserver,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect\n    ];\n});\nfunction AnimationManager(_ref) {\n    _s31();\n    let { animation, children } = _ref;\n    const [clonedChildren, setClonedChildren] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const previousChildren = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(children);\n    if (!children && !clonedChildren && previousChildren) {\n        setClonedChildren(previousChildren);\n    }\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (!element) {\n            return;\n        }\n        const key = clonedChildren == null ? void 0 : clonedChildren.key;\n        const id = clonedChildren == null ? void 0 : clonedChildren.props.id;\n        if (key == null || id == null) {\n            setClonedChildren(null);\n            return;\n        }\n        Promise.resolve(animation(id, element)).then(()=>{\n            setClonedChildren(null);\n        });\n    }, [\n        animation,\n        clonedChildren,\n        element\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children, clonedChildren ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(clonedChildren, {\n        ref: setElement\n    }) : null);\n}\n_s31(AnimationManager, \"ivSoG9kzdgwwAftt5TGHOVp0+KU=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious,\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect\n    ];\n});\n_c4 = AnimationManager;\nconst defaultTransform = {\n    x: 0,\n    y: 0,\n    scaleX: 1,\n    scaleY: 1\n};\nfunction NullifiedContextProvider(_ref) {\n    let { children } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(InternalContext.Provider, {\n        value: defaultInternalContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ActiveDraggableContext.Provider, {\n        value: defaultTransform\n    }, children));\n}\n_c5 = NullifiedContextProvider;\nconst baseStyles = {\n    position: \"fixed\",\n    touchAction: \"none\"\n};\nconst defaultTransition = (activatorEvent)=>{\n    const isKeyboardActivator = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(activatorEvent);\n    return isKeyboardActivator ? \"transform 250ms ease\" : undefined;\n};\nconst PositionedOverlay = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((_ref, ref)=>{\n    let { as, activatorEvent, adjustScale, children, className, rect, style, transform, transition = defaultTransition } = _ref;\n    if (!rect) {\n        return null;\n    }\n    const scaleAdjustedTransform = adjustScale ? transform : {\n        ...transform,\n        scaleX: 1,\n        scaleY: 1\n    };\n    const styles = {\n        ...baseStyles,\n        width: rect.width,\n        height: rect.height,\n        top: rect.top,\n        left: rect.left,\n        transform: _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transform.toString(scaleAdjustedTransform),\n        transformOrigin: adjustScale && activatorEvent ? getRelativeTransformOrigin(activatorEvent, rect) : undefined,\n        transition: typeof transition === \"function\" ? transition(activatorEvent) : transition,\n        ...style\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(as, {\n        className,\n        style: styles,\n        ref\n    }, children);\n});\n_c6 = PositionedOverlay;\nconst defaultDropAnimationSideEffects = (options)=>(_ref)=>{\n        let { active, dragOverlay } = _ref;\n        const originalStyles = {};\n        const { styles, className } = options;\n        if (styles != null && styles.active) {\n            for (const [key, value] of Object.entries(styles.active)){\n                if (value === undefined) {\n                    continue;\n                }\n                originalStyles[key] = active.node.style.getPropertyValue(key);\n                active.node.style.setProperty(key, value);\n            }\n        }\n        if (styles != null && styles.dragOverlay) {\n            for (const [key, value] of Object.entries(styles.dragOverlay)){\n                if (value === undefined) {\n                    continue;\n                }\n                dragOverlay.node.style.setProperty(key, value);\n            }\n        }\n        if (className != null && className.active) {\n            active.node.classList.add(className.active);\n        }\n        if (className != null && className.dragOverlay) {\n            dragOverlay.node.classList.add(className.dragOverlay);\n        }\n        return function cleanup() {\n            for (const [key, value] of Object.entries(originalStyles)){\n                active.node.style.setProperty(key, value);\n            }\n            if (className != null && className.active) {\n                active.node.classList.remove(className.active);\n            }\n        };\n    };\nconst defaultKeyframeResolver = (_ref2)=>{\n    let { transform: { initial, final } } = _ref2;\n    return [\n        {\n            transform: _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transform.toString(initial)\n        },\n        {\n            transform: _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transform.toString(final)\n        }\n    ];\n};\nconst defaultDropAnimationConfiguration = {\n    duration: 250,\n    easing: \"ease\",\n    keyframes: defaultKeyframeResolver,\n    sideEffects: /*#__PURE__*/ defaultDropAnimationSideEffects({\n        styles: {\n            active: {\n                opacity: \"0\"\n            }\n        }\n    })\n};\nfunction useDropAnimation(_ref3) {\n    _s32();\n    let { config, draggableNodes, droppableContainers, measuringConfiguration } = _ref3;\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent)((id, node)=>{\n        if (config === null) {\n            return;\n        }\n        const activeDraggable = draggableNodes.get(id);\n        if (!activeDraggable) {\n            return;\n        }\n        const activeNode = activeDraggable.node.current;\n        if (!activeNode) {\n            return;\n        }\n        const measurableNode = getMeasurableNode(node);\n        if (!measurableNode) {\n            return;\n        }\n        const { transform } = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(node).getComputedStyle(node);\n        const parsedTransform = parseTransform(transform);\n        if (!parsedTransform) {\n            return;\n        }\n        const animation = typeof config === \"function\" ? config : createDefaultDropAnimation(config);\n        scrollIntoViewIfNeeded(activeNode, measuringConfiguration.draggable.measure);\n        return animation({\n            active: {\n                id,\n                data: activeDraggable.data,\n                node: activeNode,\n                rect: measuringConfiguration.draggable.measure(activeNode)\n            },\n            draggableNodes,\n            dragOverlay: {\n                node,\n                rect: measuringConfiguration.dragOverlay.measure(measurableNode)\n            },\n            droppableContainers,\n            measuringConfiguration,\n            transform: parsedTransform\n        });\n    });\n}\n_s32(useDropAnimation, \"hBfwkuy2/VZ6CHMFDq5gbe/8Puc=\", false, function() {\n    return [\n        _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent\n    ];\n});\nfunction createDefaultDropAnimation(options) {\n    const { duration, easing, sideEffects, keyframes } = {\n        ...defaultDropAnimationConfiguration,\n        ...options\n    };\n    return (_ref4)=>{\n        let { active, dragOverlay, transform, ...rest } = _ref4;\n        if (!duration) {\n            // Do not animate if animation duration is zero.\n            return;\n        }\n        const delta = {\n            x: dragOverlay.rect.left - active.rect.left,\n            y: dragOverlay.rect.top - active.rect.top\n        };\n        const scale = {\n            scaleX: transform.scaleX !== 1 ? active.rect.width * transform.scaleX / dragOverlay.rect.width : 1,\n            scaleY: transform.scaleY !== 1 ? active.rect.height * transform.scaleY / dragOverlay.rect.height : 1\n        };\n        const finalTransform = {\n            x: transform.x - delta.x,\n            y: transform.y - delta.y,\n            ...scale\n        };\n        const animationKeyframes = keyframes({\n            ...rest,\n            active,\n            dragOverlay,\n            transform: {\n                initial: transform,\n                final: finalTransform\n            }\n        });\n        const [firstKeyframe] = animationKeyframes;\n        const lastKeyframe = animationKeyframes[animationKeyframes.length - 1];\n        if (JSON.stringify(firstKeyframe) === JSON.stringify(lastKeyframe)) {\n            // The start and end keyframes are the same, infer that there is no animation needed.\n            return;\n        }\n        const cleanup = sideEffects == null ? void 0 : sideEffects({\n            active,\n            dragOverlay,\n            ...rest\n        });\n        const animation = dragOverlay.node.animate(animationKeyframes, {\n            duration,\n            easing,\n            fill: \"forwards\"\n        });\n        return new Promise((resolve)=>{\n            animation.onfinish = ()=>{\n                cleanup == null ? void 0 : cleanup();\n                resolve();\n            };\n        });\n    };\n}\nlet key = 0;\nfunction useKey(id) {\n    _s33();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (id == null) {\n            return;\n        }\n        key++;\n        return key;\n    }, [\n        id\n    ]);\n}\n_s33(useKey, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nconst DragOverlay = /*#__PURE__*/ _s34(react__WEBPACK_IMPORTED_MODULE_0___default().memo(_c7 = _s34((_ref)=>{\n    _s34();\n    let { adjustScale = false, children, dropAnimation: dropAnimationConfig, style, transition, modifiers, wrapperElement = \"div\", className, zIndex = 999 } = _ref;\n    const { activatorEvent, active, activeNodeRect, containerNodeRect, draggableNodes, droppableContainers, dragOverlay, over, measuringConfiguration, scrollableAncestors, scrollableAncestorRects, windowRect } = useDndContext();\n    const transform = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ActiveDraggableContext);\n    const key = useKey(active == null ? void 0 : active.id);\n    const modifiedTransform = applyModifiers(modifiers, {\n        activatorEvent,\n        active,\n        activeNodeRect,\n        containerNodeRect,\n        draggingNodeRect: dragOverlay.rect,\n        over,\n        overlayNodeRect: dragOverlay.rect,\n        scrollableAncestors,\n        scrollableAncestorRects,\n        transform,\n        windowRect\n    });\n    const initialRect = useInitialValue(activeNodeRect);\n    const dropAnimation = useDropAnimation({\n        config: dropAnimationConfig,\n        draggableNodes,\n        droppableContainers,\n        measuringConfiguration\n    }); // We need to wait for the active node to be measured before connecting the drag overlay ref\n    // otherwise collisions can be computed against a mispositioned drag overlay\n    const ref = initialRect ? dragOverlay.setRef : undefined;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(NullifiedContextProvider, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimationManager, {\n        animation: dropAnimation\n    }, active && key ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PositionedOverlay, {\n        key: key,\n        id: active.id,\n        ref: ref,\n        as: wrapperElement,\n        activatorEvent: activatorEvent,\n        adjustScale: adjustScale,\n        className: className,\n        transition: transition,\n        rect: initialRect,\n        style: {\n            zIndex,\n            ...style\n        },\n        transform: modifiedTransform\n    }, children) : null));\n}, \"7GDeY30cDAqhtNKBrkb3H777nDc=\", false, function() {\n    return [\n        useDndContext,\n        useKey,\n        useInitialValue,\n        useDropAnimation\n    ];\n})), \"7GDeY30cDAqhtNKBrkb3H777nDc=\", false, function() {\n    return [\n        useDndContext,\n        useKey,\n        useInitialValue,\n        useDropAnimation\n    ];\n});\n_c8 = DragOverlay;\n //# sourceMappingURL=core.esm.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8;\n$RefreshReg$(_c, \"Accessibility\");\n$RefreshReg$(_c1, \"RestoreFocus\");\n$RefreshReg$(_c2, \"DndContext$memo\");\n$RefreshReg$(_c3, \"DndContext\");\n$RefreshReg$(_c4, \"AnimationManager\");\n$RefreshReg$(_c5, \"NullifiedContextProvider\");\n$RefreshReg$(_c6, \"PositionedOverlay\");\n$RefreshReg$(_c7, \"DragOverlay$React.memo\");\n$RefreshReg$(_c8, \"DragOverlay\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZG5kLWtpdC9jb3JlL2Rpc3QvY29yZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdKO0FBQ3RGO0FBQzRRO0FBQzdQO0FBRWpGLE1BQU11QyxvQkFBb0IsV0FBVyxHQUFFdEMsb0RBQWFBLENBQUM7QUFFckQsU0FBU3VDLGNBQWNDLFFBQVE7O0lBQzdCLE1BQU1DLG1CQUFtQnhDLGlEQUFVQSxDQUFDcUM7SUFDcENwQyxnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ3VDLGtCQUFrQjtZQUNyQixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFFQSxNQUFNQyxjQUFjRixpQkFBaUJEO1FBQ3JDLE9BQU9HO0lBQ1QsR0FBRztRQUFDSDtRQUFVQztLQUFpQjtBQUNqQztHQVZTRjtBQVlULFNBQVNLOztJQUNQLE1BQU0sQ0FBQ0MsVUFBVSxHQUFHMUMsK0NBQVFBLENBQUMsSUFBTSxJQUFJMkM7SUFDdkMsTUFBTUwsbUJBQW1CckMsa0RBQVdBLENBQUNvQyxDQUFBQTtRQUNuQ0ssVUFBVXRCLEdBQUcsQ0FBQ2lCO1FBQ2QsT0FBTyxJQUFNSyxVQUFVRSxNQUFNLENBQUNQO0lBQ2hDLEdBQUc7UUFBQ0s7S0FBVTtJQUNkLE1BQU1HLFdBQVc1QyxrREFBV0EsQ0FBQzZDLENBQUFBO1FBQzNCLElBQUksRUFDRkMsSUFBSSxFQUNKQyxLQUFLLEVBQ04sR0FBR0Y7UUFDSkosVUFBVU8sT0FBTyxDQUFDWixDQUFBQTtZQUNoQixJQUFJYTtZQUVKLE9BQU8sQ0FBQ0EsaUJBQWlCYixRQUFRLENBQUNVLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSUcsZUFBZUMsSUFBSSxDQUFDZCxVQUFVVztRQUM1RjtJQUNGLEdBQUc7UUFBQ047S0FBVTtJQUNkLE9BQU87UUFBQ0c7UUFBVVA7S0FBaUI7QUFDckM7SUFsQlNHO0FBb0JULE1BQU1XLGtDQUFrQztJQUN0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RTtRQWNRNVE7UUFDRStQOzs7O0FBNkJnaUIsQ0FDeGpCLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvY29yZS9kaXN0L2NvcmUuZXNtLmpzPzk4MTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vLCB1c2VSZWYsIHVzZVJlZHVjZXIsIG1lbW8sIGNsb25lRWxlbWVudCwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCwgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgdXNlVW5pcXVlSWQsIGdldEV2ZW50Q29vcmRpbmF0ZXMsIGdldFdpbmRvdywgaXNEb2N1bWVudCwgaXNIVE1MRWxlbWVudCwgaXNTVkdFbGVtZW50LCBjYW5Vc2VET00sIGlzV2luZG93LCBpc05vZGUsIGdldE93bmVyRG9jdW1lbnQsIGFkZCwgaXNLZXlib2FyZEV2ZW50LCBzdWJ0cmFjdCwgdXNlTGF6eU1lbW8sIHVzZUludGVydmFsLCB1c2VQcmV2aW91cywgdXNlTGF0ZXN0VmFsdWUsIHVzZUV2ZW50LCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCB1c2VOb2RlUmVmLCBmaW5kRmlyc3RGb2N1c2FibGVOb2RlLCBDU1MgfSBmcm9tICdAZG5kLWtpdC91dGlsaXRpZXMnO1xuaW1wb3J0IHsgdXNlQW5ub3VuY2VtZW50LCBIaWRkZW5UZXh0LCBMaXZlUmVnaW9uIH0gZnJvbSAnQGRuZC1raXQvYWNjZXNzaWJpbGl0eSc7XG5cbmNvbnN0IERuZE1vbml0b3JDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmZ1bmN0aW9uIHVzZURuZE1vbml0b3IobGlzdGVuZXIpIHtcbiAgY29uc3QgcmVnaXN0ZXJMaXN0ZW5lciA9IHVzZUNvbnRleHQoRG5kTW9uaXRvckNvbnRleHQpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcmVnaXN0ZXJMaXN0ZW5lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VEbmRNb25pdG9yIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBjaGlsZHJlbiBvZiA8RG5kQ29udGV4dD4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHJlZ2lzdGVyTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSwgW2xpc3RlbmVyLCByZWdpc3Rlckxpc3RlbmVyXSk7XG59XG5cbmZ1bmN0aW9uIHVzZURuZE1vbml0b3JQcm92aWRlcigpIHtcbiAgY29uc3QgW2xpc3RlbmVyc10gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgU2V0KCkpO1xuICBjb25zdCByZWdpc3Rlckxpc3RlbmVyID0gdXNlQ2FsbGJhY2sobGlzdGVuZXIgPT4ge1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfSwgW2xpc3RlbmVyc10pO1xuICBjb25zdCBkaXNwYXRjaCA9IHVzZUNhbGxiYWNrKF9yZWYgPT4ge1xuICAgIGxldCB7XG4gICAgICB0eXBlLFxuICAgICAgZXZlbnRcbiAgICB9ID0gX3JlZjtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICB2YXIgX2xpc3RlbmVyJHR5cGU7XG5cbiAgICAgIHJldHVybiAoX2xpc3RlbmVyJHR5cGUgPSBsaXN0ZW5lclt0eXBlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9saXN0ZW5lciR0eXBlLmNhbGwobGlzdGVuZXIsIGV2ZW50KTtcbiAgICB9KTtcbiAgfSwgW2xpc3RlbmVyc10pO1xuICByZXR1cm4gW2Rpc3BhdGNoLCByZWdpc3Rlckxpc3RlbmVyXTtcbn1cblxuY29uc3QgZGVmYXVsdFNjcmVlblJlYWRlckluc3RydWN0aW9ucyA9IHtcbiAgZHJhZ2dhYmxlOiBcIlxcbiAgICBUbyBwaWNrIHVwIGEgZHJhZ2dhYmxlIGl0ZW0sIHByZXNzIHRoZSBzcGFjZSBiYXIuXFxuICAgIFdoaWxlIGRyYWdnaW5nLCB1c2UgdGhlIGFycm93IGtleXMgdG8gbW92ZSB0aGUgaXRlbS5cXG4gICAgUHJlc3Mgc3BhY2UgYWdhaW4gdG8gZHJvcCB0aGUgaXRlbSBpbiBpdHMgbmV3IHBvc2l0aW9uLCBvciBwcmVzcyBlc2NhcGUgdG8gY2FuY2VsLlxcbiAgXCJcbn07XG5jb25zdCBkZWZhdWx0QW5ub3VuY2VtZW50cyA9IHtcbiAgb25EcmFnU3RhcnQoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBhY3RpdmVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gXCJQaWNrZWQgdXAgZHJhZ2dhYmxlIGl0ZW0gXCIgKyBhY3RpdmUuaWQgKyBcIi5cIjtcbiAgfSxcblxuICBvbkRyYWdPdmVyKF9yZWYyKSB7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIG92ZXJcbiAgICB9ID0gX3JlZjI7XG5cbiAgICBpZiAob3Zlcikge1xuICAgICAgcmV0dXJuIFwiRHJhZ2dhYmxlIGl0ZW0gXCIgKyBhY3RpdmUuaWQgKyBcIiB3YXMgbW92ZWQgb3ZlciBkcm9wcGFibGUgYXJlYSBcIiArIG92ZXIuaWQgKyBcIi5cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJEcmFnZ2FibGUgaXRlbSBcIiArIGFjdGl2ZS5pZCArIFwiIGlzIG5vIGxvbmdlciBvdmVyIGEgZHJvcHBhYmxlIGFyZWEuXCI7XG4gIH0sXG5cbiAgb25EcmFnRW5kKF9yZWYzKSB7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIG92ZXJcbiAgICB9ID0gX3JlZjM7XG5cbiAgICBpZiAob3Zlcikge1xuICAgICAgcmV0dXJuIFwiRHJhZ2dhYmxlIGl0ZW0gXCIgKyBhY3RpdmUuaWQgKyBcIiB3YXMgZHJvcHBlZCBvdmVyIGRyb3BwYWJsZSBhcmVhIFwiICsgb3Zlci5pZDtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJEcmFnZ2FibGUgaXRlbSBcIiArIGFjdGl2ZS5pZCArIFwiIHdhcyBkcm9wcGVkLlwiO1xuICB9LFxuXG4gIG9uRHJhZ0NhbmNlbChfcmVmNCkge1xuICAgIGxldCB7XG4gICAgICBhY3RpdmVcbiAgICB9ID0gX3JlZjQ7XG4gICAgcmV0dXJuIFwiRHJhZ2dpbmcgd2FzIGNhbmNlbGxlZC4gRHJhZ2dhYmxlIGl0ZW0gXCIgKyBhY3RpdmUuaWQgKyBcIiB3YXMgZHJvcHBlZC5cIjtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBBY2Nlc3NpYmlsaXR5KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBhbm5vdW5jZW1lbnRzID0gZGVmYXVsdEFubm91bmNlbWVudHMsXG4gICAgY29udGFpbmVyLFxuICAgIGhpZGRlblRleHREZXNjcmliZWRCeUlkLFxuICAgIHNjcmVlblJlYWRlckluc3RydWN0aW9ucyA9IGRlZmF1bHRTY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHtcbiAgICBhbm5vdW5jZSxcbiAgICBhbm5vdW5jZW1lbnRcbiAgfSA9IHVzZUFubm91bmNlbWVudCgpO1xuICBjb25zdCBsaXZlUmVnaW9uSWQgPSB1c2VVbmlxdWVJZChcIkRuZExpdmVSZWdpb25cIik7XG4gIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRNb3VudGVkKHRydWUpO1xuICB9LCBbXSk7XG4gIHVzZURuZE1vbml0b3IodXNlTWVtbygoKSA9PiAoe1xuICAgIG9uRHJhZ1N0YXJ0KF9yZWYyKSB7XG4gICAgICBsZXQge1xuICAgICAgICBhY3RpdmVcbiAgICAgIH0gPSBfcmVmMjtcbiAgICAgIGFubm91bmNlKGFubm91bmNlbWVudHMub25EcmFnU3RhcnQoe1xuICAgICAgICBhY3RpdmVcbiAgICAgIH0pKTtcbiAgICB9LFxuXG4gICAgb25EcmFnTW92ZShfcmVmMykge1xuICAgICAgbGV0IHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9ID0gX3JlZjM7XG5cbiAgICAgIGlmIChhbm5vdW5jZW1lbnRzLm9uRHJhZ01vdmUpIHtcbiAgICAgICAgYW5ub3VuY2UoYW5ub3VuY2VtZW50cy5vbkRyYWdNb3ZlKHtcbiAgICAgICAgICBhY3RpdmUsXG4gICAgICAgICAgb3ZlclxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9uRHJhZ092ZXIoX3JlZjQpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgb3ZlclxuICAgICAgfSA9IF9yZWY0O1xuICAgICAgYW5ub3VuY2UoYW5ub3VuY2VtZW50cy5vbkRyYWdPdmVyKHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9KSk7XG4gICAgfSxcblxuICAgIG9uRHJhZ0VuZChfcmVmNSkge1xuICAgICAgbGV0IHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9ID0gX3JlZjU7XG4gICAgICBhbm5vdW5jZShhbm5vdW5jZW1lbnRzLm9uRHJhZ0VuZCh7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgb3ZlclxuICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBvbkRyYWdDYW5jZWwoX3JlZjYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgb3ZlclxuICAgICAgfSA9IF9yZWY2O1xuICAgICAgYW5ub3VuY2UoYW5ub3VuY2VtZW50cy5vbkRyYWdDYW5jZWwoe1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIG92ZXJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgfSksIFthbm5vdW5jZSwgYW5ub3VuY2VtZW50c10pKTtcblxuICBpZiAoIW1vdW50ZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG1hcmt1cCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGlkZGVuVGV4dCwge1xuICAgIGlkOiBoaWRkZW5UZXh0RGVzY3JpYmVkQnlJZCxcbiAgICB2YWx1ZTogc2NyZWVuUmVhZGVySW5zdHJ1Y3Rpb25zLmRyYWdnYWJsZVxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChMaXZlUmVnaW9uLCB7XG4gICAgaWQ6IGxpdmVSZWdpb25JZCxcbiAgICBhbm5vdW5jZW1lbnQ6IGFubm91bmNlbWVudFxuICB9KSk7XG4gIHJldHVybiBjb250YWluZXIgPyBjcmVhdGVQb3J0YWwobWFya3VwLCBjb250YWluZXIpIDogbWFya3VwO1xufVxuXG52YXIgQWN0aW9uO1xuXG4oZnVuY3Rpb24gKEFjdGlvbikge1xuICBBY3Rpb25bXCJEcmFnU3RhcnRcIl0gPSBcImRyYWdTdGFydFwiO1xuICBBY3Rpb25bXCJEcmFnTW92ZVwiXSA9IFwiZHJhZ01vdmVcIjtcbiAgQWN0aW9uW1wiRHJhZ0VuZFwiXSA9IFwiZHJhZ0VuZFwiO1xuICBBY3Rpb25bXCJEcmFnQ2FuY2VsXCJdID0gXCJkcmFnQ2FuY2VsXCI7XG4gIEFjdGlvbltcIkRyYWdPdmVyXCJdID0gXCJkcmFnT3ZlclwiO1xuICBBY3Rpb25bXCJSZWdpc3RlckRyb3BwYWJsZVwiXSA9IFwicmVnaXN0ZXJEcm9wcGFibGVcIjtcbiAgQWN0aW9uW1wiU2V0RHJvcHBhYmxlRGlzYWJsZWRcIl0gPSBcInNldERyb3BwYWJsZURpc2FibGVkXCI7XG4gIEFjdGlvbltcIlVucmVnaXN0ZXJEcm9wcGFibGVcIl0gPSBcInVucmVnaXN0ZXJEcm9wcGFibGVcIjtcbn0pKEFjdGlvbiB8fCAoQWN0aW9uID0ge30pKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIHVzZVNlbnNvcihzZW5zb3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcbiAgICBzZW5zb3IsXG4gICAgb3B0aW9uczogb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9XG4gIH0pLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtzZW5zb3IsIG9wdGlvbnNdKTtcbn1cblxuZnVuY3Rpb24gdXNlU2Vuc29ycygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNlbnNvcnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc2Vuc29yc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiB1c2VNZW1vKCgpID0+IFsuLi5zZW5zb3JzXS5maWx0ZXIoc2Vuc29yID0+IHNlbnNvciAhPSBudWxsKSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbLi4uc2Vuc29yc10pO1xufVxuXG5jb25zdCBkZWZhdWx0Q29vcmRpbmF0ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIHg6IDAsXG4gIHk6IDBcbn0pO1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXHJcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuKHAxLCBwMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAxLnggLSBwMi54LCAyKSArIE1hdGgucG93KHAxLnkgLSBwMi55LCAyKSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbGF0aXZlVHJhbnNmb3JtT3JpZ2luKGV2ZW50LCByZWN0KSB7XG4gIGNvbnN0IGV2ZW50Q29vcmRpbmF0ZXMgPSBnZXRFdmVudENvb3JkaW5hdGVzKGV2ZW50KTtcblxuICBpZiAoIWV2ZW50Q29vcmRpbmF0ZXMpIHtcbiAgICByZXR1cm4gJzAgMCc7XG4gIH1cblxuICBjb25zdCB0cmFuc2Zvcm1PcmlnaW4gPSB7XG4gICAgeDogKGV2ZW50Q29vcmRpbmF0ZXMueCAtIHJlY3QubGVmdCkgLyByZWN0LndpZHRoICogMTAwLFxuICAgIHk6IChldmVudENvb3JkaW5hdGVzLnkgLSByZWN0LnRvcCkgLyByZWN0LmhlaWdodCAqIDEwMFxuICB9O1xuICByZXR1cm4gdHJhbnNmb3JtT3JpZ2luLnggKyBcIiUgXCIgKyB0cmFuc2Zvcm1PcmlnaW4ueSArIFwiJVwiO1xufVxuXG4vKipcclxuICogU29ydCBjb2xsaXNpb25zIGZyb20gc21hbGxlc3QgdG8gZ3JlYXRlc3QgdmFsdWVcclxuICovXG5mdW5jdGlvbiBzb3J0Q29sbGlzaW9uc0FzYyhfcmVmLCBfcmVmMikge1xuICBsZXQge1xuICAgIGRhdGE6IHtcbiAgICAgIHZhbHVlOiBhXG4gICAgfVxuICB9ID0gX3JlZjtcbiAgbGV0IHtcbiAgICBkYXRhOiB7XG4gICAgICB2YWx1ZTogYlxuICAgIH1cbiAgfSA9IF9yZWYyO1xuICByZXR1cm4gYSAtIGI7XG59XG4vKipcclxuICogU29ydCBjb2xsaXNpb25zIGZyb20gZ3JlYXRlc3QgdG8gc21hbGxlc3QgdmFsdWVcclxuICovXG5cbmZ1bmN0aW9uIHNvcnRDb2xsaXNpb25zRGVzYyhfcmVmMywgX3JlZjQpIHtcbiAgbGV0IHtcbiAgICBkYXRhOiB7XG4gICAgICB2YWx1ZTogYVxuICAgIH1cbiAgfSA9IF9yZWYzO1xuICBsZXQge1xuICAgIGRhdGE6IHtcbiAgICAgIHZhbHVlOiBiXG4gICAgfVxuICB9ID0gX3JlZjQ7XG4gIHJldHVybiBiIC0gYTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY29ybmVycyBvZiBhIGdpdmVuIHJlY3RhbmdsZTpcclxuICogW1RvcExlZnQge3gsIHl9LCBUb3BSaWdodCB7eCwgeX0sIEJvdHRvbUxlZnQge3gsIHl9LCBCb3R0b21SaWdodCB7eCwgeX1dXHJcbiAqL1xuXG5mdW5jdGlvbiBjb3JuZXJzT2ZSZWN0YW5nbGUoX3JlZjUpIHtcbiAgbGV0IHtcbiAgICBsZWZ0LFxuICAgIHRvcCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGhcbiAgfSA9IF9yZWY1O1xuICByZXR1cm4gW3tcbiAgICB4OiBsZWZ0LFxuICAgIHk6IHRvcFxuICB9LCB7XG4gICAgeDogbGVmdCArIHdpZHRoLFxuICAgIHk6IHRvcFxuICB9LCB7XG4gICAgeDogbGVmdCxcbiAgICB5OiB0b3AgKyBoZWlnaHRcbiAgfSwge1xuICAgIHg6IGxlZnQgKyB3aWR0aCxcbiAgICB5OiB0b3AgKyBoZWlnaHRcbiAgfV07XG59XG5mdW5jdGlvbiBnZXRGaXJzdENvbGxpc2lvbihjb2xsaXNpb25zLCBwcm9wZXJ0eSkge1xuICBpZiAoIWNvbGxpc2lvbnMgfHwgY29sbGlzaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IFtmaXJzdENvbGxpc2lvbl0gPSBjb2xsaXNpb25zO1xuICByZXR1cm4gcHJvcGVydHkgPyBmaXJzdENvbGxpc2lvbltwcm9wZXJ0eV0gOiBmaXJzdENvbGxpc2lvbjtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBjZW50ZXIgb2YgYSBnaXZlbiBDbGllbnRSZWN0XHJcbiAqL1xuXG5mdW5jdGlvbiBjZW50ZXJPZlJlY3RhbmdsZShyZWN0LCBsZWZ0LCB0b3ApIHtcbiAgaWYgKGxlZnQgPT09IHZvaWQgMCkge1xuICAgIGxlZnQgPSByZWN0LmxlZnQ7XG4gIH1cblxuICBpZiAodG9wID09PSB2b2lkIDApIHtcbiAgICB0b3AgPSByZWN0LnRvcDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogbGVmdCArIHJlY3Qud2lkdGggKiAwLjUsXG4gICAgeTogdG9wICsgcmVjdC5oZWlnaHQgKiAwLjVcbiAgfTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjbG9zZXN0IHJlY3RhbmdsZXMgZnJvbSBhbiBhcnJheSBvZiByZWN0YW5nbGVzIHRvIHRoZSBjZW50ZXIgb2YgYSBnaXZlblxyXG4gKiByZWN0YW5nbGUuXHJcbiAqL1xuXG5cbmNvbnN0IGNsb3Nlc3RDZW50ZXIgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjb2xsaXNpb25SZWN0LFxuICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGNlbnRlclJlY3QgPSBjZW50ZXJPZlJlY3RhbmdsZShjb2xsaXNpb25SZWN0LCBjb2xsaXNpb25SZWN0LmxlZnQsIGNvbGxpc2lvblJlY3QudG9wKTtcbiAgY29uc3QgY29sbGlzaW9ucyA9IFtdO1xuXG4gIGZvciAoY29uc3QgZHJvcHBhYmxlQ29udGFpbmVyIG9mIGRyb3BwYWJsZUNvbnRhaW5lcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZFxuICAgIH0gPSBkcm9wcGFibGVDb250YWluZXI7XG4gICAgY29uc3QgcmVjdCA9IGRyb3BwYWJsZVJlY3RzLmdldChpZCk7XG5cbiAgICBpZiAocmVjdCkge1xuICAgICAgY29uc3QgZGlzdEJldHdlZW4gPSBkaXN0YW5jZUJldHdlZW4oY2VudGVyT2ZSZWN0YW5nbGUocmVjdCksIGNlbnRlclJlY3QpO1xuICAgICAgY29sbGlzaW9ucy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkcm9wcGFibGVDb250YWluZXIsXG4gICAgICAgICAgdmFsdWU6IGRpc3RCZXR3ZWVuXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb2xsaXNpb25zLnNvcnQoc29ydENvbGxpc2lvbnNBc2MpO1xufTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNsb3Nlc3QgcmVjdGFuZ2xlcyBmcm9tIGFuIGFycmF5IG9mIHJlY3RhbmdsZXMgdG8gdGhlIGNvcm5lcnMgb2ZcclxuICogYW5vdGhlciByZWN0YW5nbGUuXHJcbiAqL1xuXG5jb25zdCBjbG9zZXN0Q29ybmVycyA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGNvbGxpc2lvblJlY3QsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVyc1xuICB9ID0gX3JlZjtcbiAgY29uc3QgY29ybmVycyA9IGNvcm5lcnNPZlJlY3RhbmdsZShjb2xsaXNpb25SZWN0KTtcbiAgY29uc3QgY29sbGlzaW9ucyA9IFtdO1xuXG4gIGZvciAoY29uc3QgZHJvcHBhYmxlQ29udGFpbmVyIG9mIGRyb3BwYWJsZUNvbnRhaW5lcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZFxuICAgIH0gPSBkcm9wcGFibGVDb250YWluZXI7XG4gICAgY29uc3QgcmVjdCA9IGRyb3BwYWJsZVJlY3RzLmdldChpZCk7XG5cbiAgICBpZiAocmVjdCkge1xuICAgICAgY29uc3QgcmVjdENvcm5lcnMgPSBjb3JuZXJzT2ZSZWN0YW5nbGUocmVjdCk7XG4gICAgICBjb25zdCBkaXN0YW5jZXMgPSBjb3JuZXJzLnJlZHVjZSgoYWNjdW11bGF0b3IsIGNvcm5lciwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yICsgZGlzdGFuY2VCZXR3ZWVuKHJlY3RDb3JuZXJzW2luZGV4XSwgY29ybmVyKTtcbiAgICAgIH0sIDApO1xuICAgICAgY29uc3QgZWZmZWN0aXZlRGlzdGFuY2UgPSBOdW1iZXIoKGRpc3RhbmNlcyAvIDQpLnRvRml4ZWQoNCkpO1xuICAgICAgY29sbGlzaW9ucy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkcm9wcGFibGVDb250YWluZXIsXG4gICAgICAgICAgdmFsdWU6IGVmZmVjdGl2ZURpc3RhbmNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb2xsaXNpb25zLnNvcnQoc29ydENvbGxpc2lvbnNBc2MpO1xufTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludGVyc2VjdGluZyByZWN0YW5nbGUgYXJlYSBiZXR3ZWVuIHR3byByZWN0YW5nbGVzXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25SYXRpbyhlbnRyeSwgdGFyZ2V0KSB7XG4gIGNvbnN0IHRvcCA9IE1hdGgubWF4KHRhcmdldC50b3AsIGVudHJ5LnRvcCk7XG4gIGNvbnN0IGxlZnQgPSBNYXRoLm1heCh0YXJnZXQubGVmdCwgZW50cnkubGVmdCk7XG4gIGNvbnN0IHJpZ2h0ID0gTWF0aC5taW4odGFyZ2V0LmxlZnQgKyB0YXJnZXQud2lkdGgsIGVudHJ5LmxlZnQgKyBlbnRyeS53aWR0aCk7XG4gIGNvbnN0IGJvdHRvbSA9IE1hdGgubWluKHRhcmdldC50b3AgKyB0YXJnZXQuaGVpZ2h0LCBlbnRyeS50b3AgKyBlbnRyeS5oZWlnaHQpO1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuXG4gIGlmIChsZWZ0IDwgcmlnaHQgJiYgdG9wIDwgYm90dG9tKSB7XG4gICAgY29uc3QgdGFyZ2V0QXJlYSA9IHRhcmdldC53aWR0aCAqIHRhcmdldC5oZWlnaHQ7XG4gICAgY29uc3QgZW50cnlBcmVhID0gZW50cnkud2lkdGggKiBlbnRyeS5oZWlnaHQ7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uQXJlYSA9IHdpZHRoICogaGVpZ2h0O1xuICAgIGNvbnN0IGludGVyc2VjdGlvblJhdGlvID0gaW50ZXJzZWN0aW9uQXJlYSAvICh0YXJnZXRBcmVhICsgZW50cnlBcmVhIC0gaW50ZXJzZWN0aW9uQXJlYSk7XG4gICAgcmV0dXJuIE51bWJlcihpbnRlcnNlY3Rpb25SYXRpby50b0ZpeGVkKDQpKTtcbiAgfSAvLyBSZWN0YW5nbGVzIGRvIG5vdCBvdmVybGFwLCBvciBvdmVybGFwIGhhcyBhbiBhcmVhIG9mIHplcm8gKGVkZ2UvY29ybmVyIG92ZXJsYXApXG5cblxuICByZXR1cm4gMDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSByZWN0YW5nbGVzIHRoYXQgaGFzIHRoZSBncmVhdGVzdCBpbnRlcnNlY3Rpb24gYXJlYSB3aXRoIGEgZ2l2ZW5cclxuICogcmVjdGFuZ2xlIGluIGFuIGFycmF5IG9mIHJlY3RhbmdsZXMuXHJcbiAqL1xuXG5jb25zdCByZWN0SW50ZXJzZWN0aW9uID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY29sbGlzaW9uUmVjdCxcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBkcm9wcGFibGVDb250YWluZXJzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBjb2xsaXNpb25zID0gW107XG5cbiAgZm9yIChjb25zdCBkcm9wcGFibGVDb250YWluZXIgb2YgZHJvcHBhYmxlQ29udGFpbmVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkXG4gICAgfSA9IGRyb3BwYWJsZUNvbnRhaW5lcjtcbiAgICBjb25zdCByZWN0ID0gZHJvcHBhYmxlUmVjdHMuZ2V0KGlkKTtcblxuICAgIGlmIChyZWN0KSB7XG4gICAgICBjb25zdCBpbnRlcnNlY3Rpb25SYXRpbyA9IGdldEludGVyc2VjdGlvblJhdGlvKHJlY3QsIGNvbGxpc2lvblJlY3QpO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW9uUmF0aW8gPiAwKSB7XG4gICAgICAgIGNvbGxpc2lvbnMucHVzaCh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZHJvcHBhYmxlQ29udGFpbmVyLFxuICAgICAgICAgICAgdmFsdWU6IGludGVyc2VjdGlvblJhdGlvXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29sbGlzaW9ucy5zb3J0KHNvcnRDb2xsaXNpb25zRGVzYyk7XG59O1xuXG4vKipcclxuICogQ2hlY2sgaWYgYSBnaXZlbiBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGEgYm91bmRpbmcgcmVjdGFuZ2xlXHJcbiAqL1xuXG5mdW5jdGlvbiBpc1BvaW50V2l0aGluUmVjdChwb2ludCwgcmVjdCkge1xuICBjb25zdCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgYm90dG9tLFxuICAgIHJpZ2h0XG4gIH0gPSByZWN0O1xuICByZXR1cm4gdG9wIDw9IHBvaW50LnkgJiYgcG9pbnQueSA8PSBib3R0b20gJiYgbGVmdCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gcmlnaHQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgcmVjdGFuZ2xlcyB0aGF0IHRoZSBwb2ludGVyIGlzIGhvdmVyaW5nIG92ZXJcclxuICovXG5cblxuY29uc3QgcG9pbnRlcldpdGhpbiA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgcG9pbnRlckNvb3JkaW5hdGVzXG4gIH0gPSBfcmVmO1xuXG4gIGlmICghcG9pbnRlckNvb3JkaW5hdGVzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgY29sbGlzaW9ucyA9IFtdO1xuXG4gIGZvciAoY29uc3QgZHJvcHBhYmxlQ29udGFpbmVyIG9mIGRyb3BwYWJsZUNvbnRhaW5lcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZFxuICAgIH0gPSBkcm9wcGFibGVDb250YWluZXI7XG4gICAgY29uc3QgcmVjdCA9IGRyb3BwYWJsZVJlY3RzLmdldChpZCk7XG5cbiAgICBpZiAocmVjdCAmJiBpc1BvaW50V2l0aGluUmVjdChwb2ludGVyQ29vcmRpbmF0ZXMsIHJlY3QpKSB7XG4gICAgICAvKiBUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIGEgc2luZ2xlIHJlY3RhbmdsZSBpbnRlcnNlY3RpbmdcclxuICAgICAgICogd2l0aCB0aGUgcG9pbnRlciBjb29yZGluYXRlcy4gSW4gb3JkZXIgdG8gc29ydCB0aGVcclxuICAgICAgICogY29sbGlkaW5nIHJlY3RhbmdsZXMsIHdlIG1lYXN1cmUgdGhlIGRpc3RhbmNlIGJldHdlZW5cclxuICAgICAgICogdGhlIHBvaW50ZXIgYW5kIHRoZSBjb3JuZXJzIG9mIHRoZSBpbnRlcnNlY3RpbmcgcmVjdGFuZ2xlXHJcbiAgICAgICAqL1xuICAgICAgY29uc3QgY29ybmVycyA9IGNvcm5lcnNPZlJlY3RhbmdsZShyZWN0KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IGNvcm5lcnMucmVkdWNlKChhY2N1bXVsYXRvciwgY29ybmVyKSA9PiB7XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvciArIGRpc3RhbmNlQmV0d2Vlbihwb2ludGVyQ29vcmRpbmF0ZXMsIGNvcm5lcik7XG4gICAgICB9LCAwKTtcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZURpc3RhbmNlID0gTnVtYmVyKChkaXN0YW5jZXMgLyA0KS50b0ZpeGVkKDQpKTtcbiAgICAgIGNvbGxpc2lvbnMucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZHJvcHBhYmxlQ29udGFpbmVyLFxuICAgICAgICAgIHZhbHVlOiBlZmZlY3RpdmVEaXN0YW5jZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29sbGlzaW9ucy5zb3J0KHNvcnRDb2xsaXNpb25zQXNjKTtcbn07XG5cbmZ1bmN0aW9uIGFkanVzdFNjYWxlKHRyYW5zZm9ybSwgcmVjdDEsIHJlY3QyKSB7XG4gIHJldHVybiB7IC4uLnRyYW5zZm9ybSxcbiAgICBzY2FsZVg6IHJlY3QxICYmIHJlY3QyID8gcmVjdDEud2lkdGggLyByZWN0Mi53aWR0aCA6IDEsXG4gICAgc2NhbGVZOiByZWN0MSAmJiByZWN0MiA/IHJlY3QxLmhlaWdodCAvIHJlY3QyLmhlaWdodCA6IDFcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdERlbHRhKHJlY3QxLCByZWN0Mikge1xuICByZXR1cm4gcmVjdDEgJiYgcmVjdDIgPyB7XG4gICAgeDogcmVjdDEubGVmdCAtIHJlY3QyLmxlZnQsXG4gICAgeTogcmVjdDEudG9wIC0gcmVjdDIudG9wXG4gIH0gOiBkZWZhdWx0Q29vcmRpbmF0ZXM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlY3RBZGp1c3RtZW50Rm4obW9kaWZpZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFkanVzdENsaWVudFJlY3QocmVjdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhZGp1c3RtZW50cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhZGp1c3RtZW50c1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkanVzdG1lbnRzLnJlZHVjZSgoYWNjLCBhZGp1c3RtZW50KSA9PiAoeyAuLi5hY2MsXG4gICAgICB0b3A6IGFjYy50b3AgKyBtb2RpZmllciAqIGFkanVzdG1lbnQueSxcbiAgICAgIGJvdHRvbTogYWNjLmJvdHRvbSArIG1vZGlmaWVyICogYWRqdXN0bWVudC55LFxuICAgICAgbGVmdDogYWNjLmxlZnQgKyBtb2RpZmllciAqIGFkanVzdG1lbnQueCxcbiAgICAgIHJpZ2h0OiBhY2MucmlnaHQgKyBtb2RpZmllciAqIGFkanVzdG1lbnQueFxuICAgIH0pLCB7IC4uLnJlY3RcbiAgICB9KTtcbiAgfTtcbn1cbmNvbnN0IGdldEFkanVzdGVkUmVjdCA9IC8qI19fUFVSRV9fKi9jcmVhdGVSZWN0QWRqdXN0bWVudEZuKDEpO1xuXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybS5zdGFydHNXaXRoKCdtYXRyaXgzZCgnKSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybUFycmF5ID0gdHJhbnNmb3JtLnNsaWNlKDksIC0xKS5zcGxpdCgvLCAvKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogK3RyYW5zZm9ybUFycmF5WzEyXSxcbiAgICAgIHk6ICt0cmFuc2Zvcm1BcnJheVsxM10sXG4gICAgICBzY2FsZVg6ICt0cmFuc2Zvcm1BcnJheVswXSxcbiAgICAgIHNjYWxlWTogK3RyYW5zZm9ybUFycmF5WzVdXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0cmFuc2Zvcm0uc3RhcnRzV2l0aCgnbWF0cml4KCcpKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtQXJyYXkgPSB0cmFuc2Zvcm0uc2xpY2UoNywgLTEpLnNwbGl0KC8sIC8pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiArdHJhbnNmb3JtQXJyYXlbNF0sXG4gICAgICB5OiArdHJhbnNmb3JtQXJyYXlbNV0sXG4gICAgICBzY2FsZVg6ICt0cmFuc2Zvcm1BcnJheVswXSxcbiAgICAgIHNjYWxlWTogK3RyYW5zZm9ybUFycmF5WzNdXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpbnZlcnNlVHJhbnNmb3JtKHJlY3QsIHRyYW5zZm9ybSwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gIGNvbnN0IHBhcnNlZFRyYW5zZm9ybSA9IHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG5cbiAgaWYgKCFwYXJzZWRUcmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBzY2FsZVgsXG4gICAgc2NhbGVZLFxuICAgIHg6IHRyYW5zbGF0ZVgsXG4gICAgeTogdHJhbnNsYXRlWVxuICB9ID0gcGFyc2VkVHJhbnNmb3JtO1xuICBjb25zdCB4ID0gcmVjdC5sZWZ0IC0gdHJhbnNsYXRlWCAtICgxIC0gc2NhbGVYKSAqIHBhcnNlRmxvYXQodHJhbnNmb3JtT3JpZ2luKTtcbiAgY29uc3QgeSA9IHJlY3QudG9wIC0gdHJhbnNsYXRlWSAtICgxIC0gc2NhbGVZKSAqIHBhcnNlRmxvYXQodHJhbnNmb3JtT3JpZ2luLnNsaWNlKHRyYW5zZm9ybU9yaWdpbi5pbmRleE9mKCcgJykgKyAxKSk7XG4gIGNvbnN0IHcgPSBzY2FsZVggPyByZWN0LndpZHRoIC8gc2NhbGVYIDogcmVjdC53aWR0aDtcbiAgY29uc3QgaCA9IHNjYWxlWSA/IHJlY3QuaGVpZ2h0IC8gc2NhbGVZIDogcmVjdC5oZWlnaHQ7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHcsXG4gICAgaGVpZ2h0OiBoLFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHcsXG4gICAgYm90dG9tOiB5ICsgaCxcbiAgICBsZWZ0OiB4XG4gIH07XG59XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBpZ25vcmVUcmFuc2Zvcm06IGZhbHNlXG59O1xuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChlbGVtZW50LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gIH1cblxuICBsZXQgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgaWYgKG9wdGlvbnMuaWdub3JlVHJhbnNmb3JtKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdHJhbnNmb3JtT3JpZ2luXG4gICAgfSA9IGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgcmVjdCA9IGludmVyc2VUcmFuc2Zvcm0ocmVjdCwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgYm90dG9tLFxuICAgIHJpZ2h0XG4gIH0gPSByZWN0O1xuICByZXR1cm4ge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBib3R0b20sXG4gICAgcmlnaHRcbiAgfTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhlIENsaWVudFJlY3QgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QgZG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtc1xyXG4gKiBhcHBsaWVkIHRvIHRoZSBlbGVtZW50IGl0IG1lYXN1cmVzLlxyXG4gKlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtQWdub3N0aWNDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENsaWVudFJlY3QoZWxlbWVudCwge1xuICAgIGlnbm9yZVRyYW5zZm9ybTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93Q2xpZW50UmVjdChlbGVtZW50KSB7XG4gIGNvbnN0IHdpZHRoID0gZWxlbWVudC5pbm5lcldpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBlbGVtZW50LmlubmVySGVpZ2h0O1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiB3aWR0aCxcbiAgICBib3R0b206IGhlaWdodCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNGaXhlZChub2RlLCBjb21wdXRlZFN0eWxlKSB7XG4gIGlmIChjb21wdXRlZFN0eWxlID09PSB2b2lkIDApIHtcbiAgICBjb21wdXRlZFN0eWxlID0gZ2V0V2luZG93KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIH1cblxuICByZXR1cm4gY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJztcbn1cblxuZnVuY3Rpb24gaXNTY3JvbGxhYmxlKGVsZW1lbnQsIGNvbXB1dGVkU3R5bGUpIHtcbiAgaWYgKGNvbXB1dGVkU3R5bGUgPT09IHZvaWQgMCkge1xuICAgIGNvbXB1dGVkU3R5bGUgPSBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgfVxuXG4gIGNvbnN0IG92ZXJmbG93UmVnZXggPSAvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLztcbiAgY29uc3QgcHJvcGVydGllcyA9IFsnb3ZlcmZsb3cnLCAnb3ZlcmZsb3dYJywgJ292ZXJmbG93WSddO1xuICByZXR1cm4gcHJvcGVydGllcy5zb21lKHByb3BlcnR5ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbcHJvcGVydHldO1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gb3ZlcmZsb3dSZWdleC50ZXN0KHZhbHVlKSA6IGZhbHNlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsYWJsZUFuY2VzdG9ycyhlbGVtZW50LCBsaW1pdCkge1xuICBjb25zdCBzY3JvbGxQYXJlbnRzID0gW107XG5cbiAgZnVuY3Rpb24gZmluZFNjcm9sbGFibGVBbmNlc3RvcnMobm9kZSkge1xuICAgIGlmIChsaW1pdCAhPSBudWxsICYmIHNjcm9sbFBhcmVudHMubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cblxuICAgIGlmIChpc0RvY3VtZW50KG5vZGUpICYmIG5vZGUuc2Nyb2xsaW5nRWxlbWVudCAhPSBudWxsICYmICFzY3JvbGxQYXJlbnRzLmluY2x1ZGVzKG5vZGUuc2Nyb2xsaW5nRWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMucHVzaChub2RlLnNjcm9sbGluZ0VsZW1lbnQpO1xuICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudHM7XG4gICAgfVxuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KG5vZGUpIHx8IGlzU1ZHRWxlbWVudChub2RlKSkge1xuICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudHM7XG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbFBhcmVudHMuaW5jbHVkZXMobm9kZSkpIHtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgIGlmIChub2RlICE9PSBlbGVtZW50KSB7XG4gICAgICBpZiAoaXNTY3JvbGxhYmxlKG5vZGUsIGNvbXB1dGVkU3R5bGUpKSB7XG4gICAgICAgIHNjcm9sbFBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNGaXhlZChub2RlLCBjb21wdXRlZFN0eWxlKSkge1xuICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmRTY3JvbGxhYmxlQW5jZXN0b3JzKG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgfVxuXG4gIHJldHVybiBmaW5kU2Nyb2xsYWJsZUFuY2VzdG9ycyhlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yKG5vZGUpIHtcbiAgY29uc3QgW2ZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yXSA9IGdldFNjcm9sbGFibGVBbmNlc3RvcnMobm9kZSwgMSk7XG4gIHJldHVybiBmaXJzdFNjcm9sbGFibGVBbmNlc3RvciAhPSBudWxsID8gZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIGlmICghY2FuVXNlRE9NIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaXNXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGlmICghaXNOb2RlKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaXNEb2N1bWVudChlbGVtZW50KSB8fCBlbGVtZW50ID09PSBnZXRPd25lckRvY3VtZW50KGVsZW1lbnQpLnNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxYQ29vcmRpbmF0ZShlbGVtZW50KSB7XG4gIGlmIChpc1dpbmRvdyhlbGVtZW50KSkge1xuICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFg7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5zY3JvbGxMZWZ0O1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsWUNvb3JkaW5hdGUoZWxlbWVudCkge1xuICBpZiAoaXNXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5zY3JvbGxZO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuc2Nyb2xsVG9wO1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsQ29vcmRpbmF0ZXMoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHg6IGdldFNjcm9sbFhDb29yZGluYXRlKGVsZW1lbnQpLFxuICAgIHk6IGdldFNjcm9sbFlDb29yZGluYXRlKGVsZW1lbnQpXG4gIH07XG59XG5cbnZhciBEaXJlY3Rpb247XG5cbihmdW5jdGlvbiAoRGlyZWN0aW9uKSB7XG4gIERpcmVjdGlvbltEaXJlY3Rpb25bXCJGb3J3YXJkXCJdID0gMV0gPSBcIkZvcndhcmRcIjtcbiAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkJhY2t3YXJkXCJdID0gLTFdID0gXCJCYWNrd2FyZFwiO1xufSkoRGlyZWN0aW9uIHx8IChEaXJlY3Rpb24gPSB7fSkpO1xuXG5mdW5jdGlvbiBpc0RvY3VtZW50U2Nyb2xsaW5nRWxlbWVudChlbGVtZW50KSB7XG4gIGlmICghY2FuVXNlRE9NIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQgPT09IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFBvc2l0aW9uKHNjcm9sbGluZ0NvbnRhaW5lcikge1xuICBjb25zdCBtaW5TY3JvbGwgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBpc0RvY3VtZW50U2Nyb2xsaW5nRWxlbWVudChzY3JvbGxpbmdDb250YWluZXIpID8ge1xuICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aFxuICB9IDoge1xuICAgIGhlaWdodDogc2Nyb2xsaW5nQ29udGFpbmVyLmNsaWVudEhlaWdodCxcbiAgICB3aWR0aDogc2Nyb2xsaW5nQ29udGFpbmVyLmNsaWVudFdpZHRoXG4gIH07XG4gIGNvbnN0IG1heFNjcm9sbCA9IHtcbiAgICB4OiBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsV2lkdGggLSBkaW1lbnNpb25zLndpZHRoLFxuICAgIHk6IHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxIZWlnaHQgLSBkaW1lbnNpb25zLmhlaWdodFxuICB9O1xuICBjb25zdCBpc1RvcCA9IHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgPD0gbWluU2Nyb2xsLnk7XG4gIGNvbnN0IGlzTGVmdCA9IHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxMZWZ0IDw9IG1pblNjcm9sbC54O1xuICBjb25zdCBpc0JvdHRvbSA9IHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgPj0gbWF4U2Nyb2xsLnk7XG4gIGNvbnN0IGlzUmlnaHQgPSBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsTGVmdCA+PSBtYXhTY3JvbGwueDtcbiAgcmV0dXJuIHtcbiAgICBpc1RvcCxcbiAgICBpc0xlZnQsXG4gICAgaXNCb3R0b20sXG4gICAgaXNSaWdodCxcbiAgICBtYXhTY3JvbGwsXG4gICAgbWluU2Nyb2xsXG4gIH07XG59XG5cbmNvbnN0IGRlZmF1bHRUaHJlc2hvbGQgPSB7XG4gIHg6IDAuMixcbiAgeTogMC4yXG59O1xuZnVuY3Rpb24gZ2V0U2Nyb2xsRGlyZWN0aW9uQW5kU3BlZWQoc2Nyb2xsQ29udGFpbmVyLCBzY3JvbGxDb250YWluZXJSZWN0LCBfcmVmLCBhY2NlbGVyYXRpb24sIHRocmVzaG9sZFBlcmNlbnRhZ2UpIHtcbiAgbGV0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICBib3R0b21cbiAgfSA9IF9yZWY7XG5cbiAgaWYgKGFjY2VsZXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgYWNjZWxlcmF0aW9uID0gMTA7XG4gIH1cblxuICBpZiAodGhyZXNob2xkUGVyY2VudGFnZSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyZXNob2xkUGVyY2VudGFnZSA9IGRlZmF1bHRUaHJlc2hvbGQ7XG4gIH1cblxuICBjb25zdCB7XG4gICAgaXNUb3AsXG4gICAgaXNCb3R0b20sXG4gICAgaXNMZWZ0LFxuICAgIGlzUmlnaHRcbiAgfSA9IGdldFNjcm9sbFBvc2l0aW9uKHNjcm9sbENvbnRhaW5lcik7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgY29uc3Qgc3BlZWQgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIGNvbnN0IHRocmVzaG9sZCA9IHtcbiAgICBoZWlnaHQ6IHNjcm9sbENvbnRhaW5lclJlY3QuaGVpZ2h0ICogdGhyZXNob2xkUGVyY2VudGFnZS55LFxuICAgIHdpZHRoOiBzY3JvbGxDb250YWluZXJSZWN0LndpZHRoICogdGhyZXNob2xkUGVyY2VudGFnZS54XG4gIH07XG5cbiAgaWYgKCFpc1RvcCAmJiB0b3AgPD0gc2Nyb2xsQ29udGFpbmVyUmVjdC50b3AgKyB0aHJlc2hvbGQuaGVpZ2h0KSB7XG4gICAgLy8gU2Nyb2xsIFVwXG4gICAgZGlyZWN0aW9uLnkgPSBEaXJlY3Rpb24uQmFja3dhcmQ7XG4gICAgc3BlZWQueSA9IGFjY2VsZXJhdGlvbiAqIE1hdGguYWJzKChzY3JvbGxDb250YWluZXJSZWN0LnRvcCArIHRocmVzaG9sZC5oZWlnaHQgLSB0b3ApIC8gdGhyZXNob2xkLmhlaWdodCk7XG4gIH0gZWxzZSBpZiAoIWlzQm90dG9tICYmIGJvdHRvbSA+PSBzY3JvbGxDb250YWluZXJSZWN0LmJvdHRvbSAtIHRocmVzaG9sZC5oZWlnaHQpIHtcbiAgICAvLyBTY3JvbGwgRG93blxuICAgIGRpcmVjdGlvbi55ID0gRGlyZWN0aW9uLkZvcndhcmQ7XG4gICAgc3BlZWQueSA9IGFjY2VsZXJhdGlvbiAqIE1hdGguYWJzKChzY3JvbGxDb250YWluZXJSZWN0LmJvdHRvbSAtIHRocmVzaG9sZC5oZWlnaHQgLSBib3R0b20pIC8gdGhyZXNob2xkLmhlaWdodCk7XG4gIH1cblxuICBpZiAoIWlzUmlnaHQgJiYgcmlnaHQgPj0gc2Nyb2xsQ29udGFpbmVyUmVjdC5yaWdodCAtIHRocmVzaG9sZC53aWR0aCkge1xuICAgIC8vIFNjcm9sbCBSaWdodFxuICAgIGRpcmVjdGlvbi54ID0gRGlyZWN0aW9uLkZvcndhcmQ7XG4gICAgc3BlZWQueCA9IGFjY2VsZXJhdGlvbiAqIE1hdGguYWJzKChzY3JvbGxDb250YWluZXJSZWN0LnJpZ2h0IC0gdGhyZXNob2xkLndpZHRoIC0gcmlnaHQpIC8gdGhyZXNob2xkLndpZHRoKTtcbiAgfSBlbHNlIGlmICghaXNMZWZ0ICYmIGxlZnQgPD0gc2Nyb2xsQ29udGFpbmVyUmVjdC5sZWZ0ICsgdGhyZXNob2xkLndpZHRoKSB7XG4gICAgLy8gU2Nyb2xsIExlZnRcbiAgICBkaXJlY3Rpb24ueCA9IERpcmVjdGlvbi5CYWNrd2FyZDtcbiAgICBzcGVlZC54ID0gYWNjZWxlcmF0aW9uICogTWF0aC5hYnMoKHNjcm9sbENvbnRhaW5lclJlY3QubGVmdCArIHRocmVzaG9sZC53aWR0aCAtIGxlZnQpIC8gdGhyZXNob2xkLndpZHRoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGlyZWN0aW9uLFxuICAgIHNwZWVkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbEVsZW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbm5lcldpZHRoLFxuICAgICAgaW5uZXJIZWlnaHRcbiAgICB9ID0gd2luZG93O1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IGlubmVyV2lkdGgsXG4gICAgICBib3R0b206IGlubmVySGVpZ2h0LFxuICAgICAgd2lkdGg6IGlubmVyV2lkdGgsXG4gICAgICBoZWlnaHQ6IGlubmVySGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICBib3R0b21cbiAgfSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tLFxuICAgIHdpZHRoOiBlbGVtZW50LmNsaWVudFdpZHRoLFxuICAgIGhlaWdodDogZWxlbWVudC5jbGllbnRIZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsT2Zmc2V0cyhzY3JvbGxhYmxlQW5jZXN0b3JzKSB7XG4gIHJldHVybiBzY3JvbGxhYmxlQW5jZXN0b3JzLnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG4gICAgcmV0dXJuIGFkZChhY2MsIGdldFNjcm9sbENvb3JkaW5hdGVzKG5vZGUpKTtcbiAgfSwgZGVmYXVsdENvb3JkaW5hdGVzKTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFhPZmZzZXQoc2Nyb2xsYWJsZUFuY2VzdG9ycykge1xuICByZXR1cm4gc2Nyb2xsYWJsZUFuY2VzdG9ycy5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICAgIHJldHVybiBhY2MgKyBnZXRTY3JvbGxYQ29vcmRpbmF0ZShub2RlKTtcbiAgfSwgMCk7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxZT2Zmc2V0KHNjcm9sbGFibGVBbmNlc3RvcnMpIHtcbiAgcmV0dXJuIHNjcm9sbGFibGVBbmNlc3RvcnMucmVkdWNlKChhY2MsIG5vZGUpID0+IHtcbiAgICByZXR1cm4gYWNjICsgZ2V0U2Nyb2xsWUNvb3JkaW5hdGUobm9kZSk7XG4gIH0sIDApO1xufVxuXG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlld0lmTmVlZGVkKGVsZW1lbnQsIG1lYXN1cmUpIHtcbiAgaWYgKG1lYXN1cmUgPT09IHZvaWQgMCkge1xuICAgIG1lYXN1cmUgPSBnZXRDbGllbnRSZWN0O1xuICB9XG5cbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIGJvdHRvbSxcbiAgICByaWdodFxuICB9ID0gbWVhc3VyZShlbGVtZW50KTtcbiAgY29uc3QgZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXRGaXJzdFNjcm9sbGFibGVBbmNlc3RvcihlbGVtZW50KTtcblxuICBpZiAoIWZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGJvdHRvbSA8PSAwIHx8IHJpZ2h0IDw9IDAgfHwgdG9wID49IHdpbmRvdy5pbm5lckhlaWdodCB8fCBsZWZ0ID49IHdpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgZWxlbWVudC5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogJ2NlbnRlcicsXG4gICAgICBpbmxpbmU6ICdjZW50ZXInXG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgcHJvcGVydGllcyA9IFtbJ3gnLCBbJ2xlZnQnLCAncmlnaHQnXSwgZ2V0U2Nyb2xsWE9mZnNldF0sIFsneScsIFsndG9wJywgJ2JvdHRvbSddLCBnZXRTY3JvbGxZT2Zmc2V0XV07XG5jbGFzcyBSZWN0IHtcbiAgY29uc3RydWN0b3IocmVjdCwgZWxlbWVudCkge1xuICAgIHRoaXMucmVjdCA9IHZvaWQgMDtcbiAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMudG9wID0gdm9pZCAwO1xuICAgIHRoaXMuYm90dG9tID0gdm9pZCAwO1xuICAgIHRoaXMucmlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5sZWZ0ID0gdm9pZCAwO1xuICAgIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvcnMgPSBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzKGVsZW1lbnQpO1xuICAgIGNvbnN0IHNjcm9sbE9mZnNldHMgPSBnZXRTY3JvbGxPZmZzZXRzKHNjcm9sbGFibGVBbmNlc3RvcnMpO1xuICAgIHRoaXMucmVjdCA9IHsgLi4ucmVjdFxuICAgIH07XG4gICAgdGhpcy53aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSByZWN0LmhlaWdodDtcblxuICAgIGZvciAoY29uc3QgW2F4aXMsIGtleXMsIGdldFNjcm9sbE9mZnNldF0gb2YgcHJvcGVydGllcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50T2Zmc2V0cyA9IGdldFNjcm9sbE9mZnNldChzY3JvbGxhYmxlQW5jZXN0b3JzKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbE9mZnNldHNEZWx0bGEgPSBzY3JvbGxPZmZzZXRzW2F4aXNdIC0gY3VycmVudE9mZnNldHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWN0W2tleV0gKyBzY3JvbGxPZmZzZXRzRGVsdGxhO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlY3QnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbn1cblxuY2xhc3MgTGlzdGVuZXJzIHtcbiAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcblxuICAgIHRoaXMucmVtb3ZlQWxsID0gKCkgPT4ge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgIHZhciBfdGhpcyR0YXJnZXQ7XG5cbiAgICAgICAgcmV0dXJuIChfdGhpcyR0YXJnZXQgPSB0aGlzLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKC4uLmxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgfVxuXG4gIGFkZChldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMkdGFyZ2V0MjtcblxuICAgIChfdGhpcyR0YXJnZXQyID0gdGhpcy50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0YXJnZXQyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB0aGlzLmxpc3RlbmVycy5wdXNoKFtldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnNdKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TGlzdGVuZXJUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIElmIHRoZSBgZXZlbnQudGFyZ2V0YCBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQgZXZlbnRzIHdpbGwgc3RpbGwgYmUgdGFyZ2V0ZWRcbiAgLy8gYXQgaXQsIGFuZCBoZW5jZSB3b24ndCBhbHdheXMgYnViYmxlIHVwIHRvIHRoZSB3aW5kb3cgb3IgZG9jdW1lbnQgYW55bW9yZS5cbiAgLy8gSWYgdGhlcmUgaXMgYW55IHJpc2sgb2YgYW4gZWxlbWVudCBiZWluZyByZW1vdmVkIHdoaWxlIGl0IGlzIGJlaW5nIGRyYWdnZWQsXG4gIC8vIHRoZSBiZXN0IHByYWN0aWNlIGlzIHRvIGF0dGFjaCB0aGUgZXZlbnQgbGlzdGVuZXJzIGRpcmVjdGx5IHRvIHRoZSB0YXJnZXQuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldFxuICBjb25zdCB7XG4gICAgRXZlbnRUYXJnZXRcbiAgfSA9IGdldFdpbmRvdyh0YXJnZXQpO1xuICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgRXZlbnRUYXJnZXQgPyB0YXJnZXQgOiBnZXRPd25lckRvY3VtZW50KHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGhhc0V4Y2VlZGVkRGlzdGFuY2UoZGVsdGEsIG1lYXN1cmVtZW50KSB7XG4gIGNvbnN0IGR4ID0gTWF0aC5hYnMoZGVsdGEueCk7XG4gIGNvbnN0IGR5ID0gTWF0aC5hYnMoZGVsdGEueSk7XG5cbiAgaWYgKHR5cGVvZiBtZWFzdXJlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICoqIDIgKyBkeSAqKiAyKSA+IG1lYXN1cmVtZW50O1xuICB9XG5cbiAgaWYgKCd4JyBpbiBtZWFzdXJlbWVudCAmJiAneScgaW4gbWVhc3VyZW1lbnQpIHtcbiAgICByZXR1cm4gZHggPiBtZWFzdXJlbWVudC54ICYmIGR5ID4gbWVhc3VyZW1lbnQueTtcbiAgfVxuXG4gIGlmICgneCcgaW4gbWVhc3VyZW1lbnQpIHtcbiAgICByZXR1cm4gZHggPiBtZWFzdXJlbWVudC54O1xuICB9XG5cbiAgaWYgKCd5JyBpbiBtZWFzdXJlbWVudCkge1xuICAgIHJldHVybiBkeSA+IG1lYXN1cmVtZW50Lnk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBFdmVudE5hbWU7XG5cbihmdW5jdGlvbiAoRXZlbnROYW1lKSB7XG4gIEV2ZW50TmFtZVtcIkNsaWNrXCJdID0gXCJjbGlja1wiO1xuICBFdmVudE5hbWVbXCJEcmFnU3RhcnRcIl0gPSBcImRyYWdzdGFydFwiO1xuICBFdmVudE5hbWVbXCJLZXlkb3duXCJdID0gXCJrZXlkb3duXCI7XG4gIEV2ZW50TmFtZVtcIkNvbnRleHRNZW51XCJdID0gXCJjb250ZXh0bWVudVwiO1xuICBFdmVudE5hbWVbXCJSZXNpemVcIl0gPSBcInJlc2l6ZVwiO1xuICBFdmVudE5hbWVbXCJTZWxlY3Rpb25DaGFuZ2VcIl0gPSBcInNlbGVjdGlvbmNoYW5nZVwiO1xuICBFdmVudE5hbWVbXCJWaXNpYmlsaXR5Q2hhbmdlXCJdID0gXCJ2aXNpYmlsaXR5Y2hhbmdlXCI7XG59KShFdmVudE5hbWUgfHwgKEV2ZW50TmFtZSA9IHt9KSk7XG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbnZhciBLZXlib2FyZENvZGU7XG5cbihmdW5jdGlvbiAoS2V5Ym9hcmRDb2RlKSB7XG4gIEtleWJvYXJkQ29kZVtcIlNwYWNlXCJdID0gXCJTcGFjZVwiO1xuICBLZXlib2FyZENvZGVbXCJEb3duXCJdID0gXCJBcnJvd0Rvd25cIjtcbiAgS2V5Ym9hcmRDb2RlW1wiUmlnaHRcIl0gPSBcIkFycm93UmlnaHRcIjtcbiAgS2V5Ym9hcmRDb2RlW1wiTGVmdFwiXSA9IFwiQXJyb3dMZWZ0XCI7XG4gIEtleWJvYXJkQ29kZVtcIlVwXCJdID0gXCJBcnJvd1VwXCI7XG4gIEtleWJvYXJkQ29kZVtcIkVzY1wiXSA9IFwiRXNjYXBlXCI7XG4gIEtleWJvYXJkQ29kZVtcIkVudGVyXCJdID0gXCJFbnRlclwiO1xufSkoS2V5Ym9hcmRDb2RlIHx8IChLZXlib2FyZENvZGUgPSB7fSkpO1xuXG5jb25zdCBkZWZhdWx0S2V5Ym9hcmRDb2RlcyA9IHtcbiAgc3RhcnQ6IFtLZXlib2FyZENvZGUuU3BhY2UsIEtleWJvYXJkQ29kZS5FbnRlcl0sXG4gIGNhbmNlbDogW0tleWJvYXJkQ29kZS5Fc2NdLFxuICBlbmQ6IFtLZXlib2FyZENvZGUuU3BhY2UsIEtleWJvYXJkQ29kZS5FbnRlcl1cbn07XG5jb25zdCBkZWZhdWx0S2V5Ym9hcmRDb29yZGluYXRlR2V0dGVyID0gKGV2ZW50LCBfcmVmKSA9PiB7XG4gIGxldCB7XG4gICAgY3VycmVudENvb3JkaW5hdGVzXG4gIH0gPSBfcmVmO1xuXG4gIHN3aXRjaCAoZXZlbnQuY29kZSkge1xuICAgIGNhc2UgS2V5Ym9hcmRDb2RlLlJpZ2h0OlxuICAgICAgcmV0dXJuIHsgLi4uY3VycmVudENvb3JkaW5hdGVzLFxuICAgICAgICB4OiBjdXJyZW50Q29vcmRpbmF0ZXMueCArIDI1XG4gICAgICB9O1xuXG4gICAgY2FzZSBLZXlib2FyZENvZGUuTGVmdDpcbiAgICAgIHJldHVybiB7IC4uLmN1cnJlbnRDb29yZGluYXRlcyxcbiAgICAgICAgeDogY3VycmVudENvb3JkaW5hdGVzLnggLSAyNVxuICAgICAgfTtcblxuICAgIGNhc2UgS2V5Ym9hcmRDb2RlLkRvd246XG4gICAgICByZXR1cm4geyAuLi5jdXJyZW50Q29vcmRpbmF0ZXMsXG4gICAgICAgIHk6IGN1cnJlbnRDb29yZGluYXRlcy55ICsgMjVcbiAgICAgIH07XG5cbiAgICBjYXNlIEtleWJvYXJkQ29kZS5VcDpcbiAgICAgIHJldHVybiB7IC4uLmN1cnJlbnRDb29yZGluYXRlcyxcbiAgICAgICAgeTogY3VycmVudENvb3JkaW5hdGVzLnkgLSAyNVxuICAgICAgfTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5jbGFzcyBLZXlib2FyZFNlbnNvciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dG9TY3JvbGxFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5yZWZlcmVuY2VDb29yZGluYXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgZXZlbnQ6IHtcbiAgICAgICAgdGFyZ2V0XG4gICAgICB9XG4gICAgfSA9IHByb3BzO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoZ2V0T3duZXJEb2N1bWVudCh0YXJnZXQpKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoZ2V0V2luZG93KHRhcmdldCkpO1xuICAgIHRoaXMuaGFuZGxlS2V5RG93biA9IHRoaXMuaGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlQ2FuY2VsID0gdGhpcy5oYW5kbGVDYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLmF0dGFjaCgpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuaGFuZGxlU3RhcnQoKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5hZGQoRXZlbnROYW1lLlJlc2l6ZSwgdGhpcy5oYW5kbGVDYW5jZWwpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuVmlzaWJpbGl0eUNoYW5nZSwgdGhpcy5oYW5kbGVDYW5jZWwpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5saXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5LZXlkb3duLCB0aGlzLmhhbmRsZUtleURvd24pKTtcbiAgfVxuXG4gIGhhbmRsZVN0YXJ0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZU5vZGUsXG4gICAgICBvblN0YXJ0XG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgbm9kZSA9IGFjdGl2ZU5vZGUubm9kZS5jdXJyZW50O1xuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHNjcm9sbEludG9WaWV3SWZOZWVkZWQobm9kZSk7XG4gICAgfVxuXG4gICAgb25TdGFydChkZWZhdWx0Q29vcmRpbmF0ZXMpO1xuICB9XG5cbiAgaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGlmIChpc0tleWJvYXJkRXZlbnQoZXZlbnQpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleWJvYXJkQ29kZXMgPSBkZWZhdWx0S2V5Ym9hcmRDb2RlcyxcbiAgICAgICAgY29vcmRpbmF0ZUdldHRlciA9IGRlZmF1bHRLZXlib2FyZENvb3JkaW5hdGVHZXR0ZXIsXG4gICAgICAgIHNjcm9sbEJlaGF2aW9yID0gJ3Ntb290aCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb2RlXG4gICAgICB9ID0gZXZlbnQ7XG5cbiAgICAgIGlmIChrZXlib2FyZENvZGVzLmVuZC5pbmNsdWRlcyhjb2RlKSkge1xuICAgICAgICB0aGlzLmhhbmRsZUVuZChldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleWJvYXJkQ29kZXMuY2FuY2VsLmluY2x1ZGVzKGNvZGUpKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2FuY2VsKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbGxpc2lvblJlY3RcbiAgICAgIH0gPSBjb250ZXh0LmN1cnJlbnQ7XG4gICAgICBjb25zdCBjdXJyZW50Q29vcmRpbmF0ZXMgPSBjb2xsaXNpb25SZWN0ID8ge1xuICAgICAgICB4OiBjb2xsaXNpb25SZWN0LmxlZnQsXG4gICAgICAgIHk6IGNvbGxpc2lvblJlY3QudG9wXG4gICAgICB9IDogZGVmYXVsdENvb3JkaW5hdGVzO1xuXG4gICAgICBpZiAoIXRoaXMucmVmZXJlbmNlQ29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VDb29yZGluYXRlcyA9IGN1cnJlbnRDb29yZGluYXRlcztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3Q29vcmRpbmF0ZXMgPSBjb29yZGluYXRlR2V0dGVyKGV2ZW50LCB7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgY29udGV4dDogY29udGV4dC5jdXJyZW50LFxuICAgICAgICBjdXJyZW50Q29vcmRpbmF0ZXNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobmV3Q29vcmRpbmF0ZXMpIHtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZXNEZWx0YSA9IHN1YnRyYWN0KG5ld0Nvb3JkaW5hdGVzLCBjdXJyZW50Q29vcmRpbmF0ZXMpO1xuICAgICAgICBjb25zdCBzY3JvbGxEZWx0YSA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNjcm9sbGFibGVBbmNlc3RvcnNcbiAgICAgICAgfSA9IGNvbnRleHQuY3VycmVudDtcblxuICAgICAgICBmb3IgKGNvbnN0IHNjcm9sbENvbnRhaW5lciBvZiBzY3JvbGxhYmxlQW5jZXN0b3JzKSB7XG4gICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gZXZlbnQuY29kZTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpc1RvcCxcbiAgICAgICAgICAgIGlzUmlnaHQsXG4gICAgICAgICAgICBpc0xlZnQsXG4gICAgICAgICAgICBpc0JvdHRvbSxcbiAgICAgICAgICAgIG1heFNjcm9sbCxcbiAgICAgICAgICAgIG1pblNjcm9sbFxuICAgICAgICAgIH0gPSBnZXRTY3JvbGxQb3NpdGlvbihzY3JvbGxDb250YWluZXIpO1xuICAgICAgICAgIGNvbnN0IHNjcm9sbEVsZW1lbnRSZWN0ID0gZ2V0U2Nyb2xsRWxlbWVudFJlY3Qoc2Nyb2xsQ29udGFpbmVyKTtcbiAgICAgICAgICBjb25zdCBjbGFtcGVkQ29vcmRpbmF0ZXMgPSB7XG4gICAgICAgICAgICB4OiBNYXRoLm1pbihkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5SaWdodCA/IHNjcm9sbEVsZW1lbnRSZWN0LnJpZ2h0IC0gc2Nyb2xsRWxlbWVudFJlY3Qud2lkdGggLyAyIDogc2Nyb2xsRWxlbWVudFJlY3QucmlnaHQsIE1hdGgubWF4KGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlJpZ2h0ID8gc2Nyb2xsRWxlbWVudFJlY3QubGVmdCA6IHNjcm9sbEVsZW1lbnRSZWN0LmxlZnQgKyBzY3JvbGxFbGVtZW50UmVjdC53aWR0aCAvIDIsIG5ld0Nvb3JkaW5hdGVzLngpKSxcbiAgICAgICAgICAgIHk6IE1hdGgubWluKGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkRvd24gPyBzY3JvbGxFbGVtZW50UmVjdC5ib3R0b20gLSBzY3JvbGxFbGVtZW50UmVjdC5oZWlnaHQgLyAyIDogc2Nyb2xsRWxlbWVudFJlY3QuYm90dG9tLCBNYXRoLm1heChkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5Eb3duID8gc2Nyb2xsRWxlbWVudFJlY3QudG9wIDogc2Nyb2xsRWxlbWVudFJlY3QudG9wICsgc2Nyb2xsRWxlbWVudFJlY3QuaGVpZ2h0IC8gMiwgbmV3Q29vcmRpbmF0ZXMueSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBjYW5TY3JvbGxYID0gZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuUmlnaHQgJiYgIWlzUmlnaHQgfHwgZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuTGVmdCAmJiAhaXNMZWZ0O1xuICAgICAgICAgIGNvbnN0IGNhblNjcm9sbFkgPSBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5Eb3duICYmICFpc0JvdHRvbSB8fCBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5VcCAmJiAhaXNUb3A7XG5cbiAgICAgICAgICBpZiAoY2FuU2Nyb2xsWCAmJiBjbGFtcGVkQ29vcmRpbmF0ZXMueCAhPT0gbmV3Q29vcmRpbmF0ZXMueCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U2Nyb2xsQ29vcmRpbmF0ZXMgPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCArIGNvb3JkaW5hdGVzRGVsdGEueDtcbiAgICAgICAgICAgIGNvbnN0IGNhblNjcm9sbFRvTmV3Q29vcmRpbmF0ZXMgPSBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5SaWdodCAmJiBuZXdTY3JvbGxDb29yZGluYXRlcyA8PSBtYXhTY3JvbGwueCB8fCBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5MZWZ0ICYmIG5ld1Njcm9sbENvb3JkaW5hdGVzID49IG1pblNjcm9sbC54O1xuXG4gICAgICAgICAgICBpZiAoY2FuU2Nyb2xsVG9OZXdDb29yZGluYXRlcyAmJiAhY29vcmRpbmF0ZXNEZWx0YS55KSB7XG4gICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIGNvb3JkaW5hdGVzLCB0aGUgc2Nyb2xsIGFkanVzdG1lbnQgYWxvbmUgd2lsbCB0cmlnZ2VyXG4gICAgICAgICAgICAgIC8vIGxvZ2ljIHRvIGF1dG8tZGV0ZWN0IHRoZSBuZXcgY29udGFpbmVyIHdlIGFyZSBvdmVyXG4gICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgbGVmdDogbmV3U2Nyb2xsQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6IHNjcm9sbEJlaGF2aW9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYW5TY3JvbGxUb05ld0Nvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICAgIHNjcm9sbERlbHRhLnggPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCAtIG5ld1Njcm9sbENvb3JkaW5hdGVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2Nyb2xsRGVsdGEueCA9IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlJpZ2h0ID8gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgLSBtYXhTY3JvbGwueCA6IHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0IC0gbWluU2Nyb2xsLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JvbGxEZWx0YS54KSB7XG4gICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxCeSh7XG4gICAgICAgICAgICAgICAgbGVmdDogLXNjcm9sbERlbHRhLngsXG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6IHNjcm9sbEJlaGF2aW9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNhblNjcm9sbFkgJiYgY2xhbXBlZENvb3JkaW5hdGVzLnkgIT09IG5ld0Nvb3JkaW5hdGVzLnkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njcm9sbENvb3JkaW5hdGVzID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCArIGNvb3JkaW5hdGVzRGVsdGEueTtcbiAgICAgICAgICAgIGNvbnN0IGNhblNjcm9sbFRvTmV3Q29vcmRpbmF0ZXMgPSBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5Eb3duICYmIG5ld1Njcm9sbENvb3JkaW5hdGVzIDw9IG1heFNjcm9sbC55IHx8IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlVwICYmIG5ld1Njcm9sbENvb3JkaW5hdGVzID49IG1pblNjcm9sbC55O1xuXG4gICAgICAgICAgICBpZiAoY2FuU2Nyb2xsVG9OZXdDb29yZGluYXRlcyAmJiAhY29vcmRpbmF0ZXNEZWx0YS54KSB7XG4gICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIGNvb3JkaW5hdGVzLCB0aGUgc2Nyb2xsIGFkanVzdG1lbnQgYWxvbmUgd2lsbCB0cmlnZ2VyXG4gICAgICAgICAgICAgIC8vIGxvZ2ljIHRvIGF1dG8tZGV0ZWN0IHRoZSBuZXcgY29udGFpbmVyIHdlIGFyZSBvdmVyXG4gICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgdG9wOiBuZXdTY3JvbGxDb29yZGluYXRlcyxcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogc2Nyb2xsQmVoYXZpb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhblNjcm9sbFRvTmV3Q29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgICAgc2Nyb2xsRGVsdGEueSA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgLSBuZXdTY3JvbGxDb29yZGluYXRlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNjcm9sbERlbHRhLnkgPSBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5Eb3duID8gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCAtIG1heFNjcm9sbC55IDogc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCAtIG1pblNjcm9sbC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2Nyb2xsRGVsdGEueSkge1xuICAgICAgICAgICAgICBzY3JvbGxDb250YWluZXIuc2Nyb2xsQnkoe1xuICAgICAgICAgICAgICAgIHRvcDogLXNjcm9sbERlbHRhLnksXG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6IHNjcm9sbEJlaGF2aW9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhhbmRsZU1vdmUoZXZlbnQsIGFkZChzdWJ0cmFjdChuZXdDb29yZGluYXRlcywgdGhpcy5yZWZlcmVuY2VDb29yZGluYXRlcyksIHNjcm9sbERlbHRhKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlTW92ZShldmVudCwgY29vcmRpbmF0ZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBvbk1vdmVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIG9uTW92ZShjb29yZGluYXRlcyk7XG4gIH1cblxuICBoYW5kbGVFbmQoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBvbkVuZFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgICBvbkVuZCgpO1xuICB9XG5cbiAgaGFuZGxlQ2FuY2VsKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgb25DYW5jZWxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgb25DYW5jZWwoKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5yZW1vdmVBbGwoKTtcbiAgfVxuXG59XG5LZXlib2FyZFNlbnNvci5hY3RpdmF0b3JzID0gW3tcbiAgZXZlbnROYW1lOiAnb25LZXlEb3duJyxcbiAgaGFuZGxlcjogKGV2ZW50LCBfcmVmLCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXlib2FyZENvZGVzID0gZGVmYXVsdEtleWJvYXJkQ29kZXMsXG4gICAgICBvbkFjdGl2YXRpb25cbiAgICB9ID0gX3JlZjtcbiAgICBsZXQge1xuICAgICAgYWN0aXZlXG4gICAgfSA9IF9yZWYyO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvZGVcbiAgICB9ID0gZXZlbnQubmF0aXZlRXZlbnQ7XG5cbiAgICBpZiAoa2V5Ym9hcmRDb2Rlcy5zdGFydC5pbmNsdWRlcyhjb2RlKSkge1xuICAgICAgY29uc3QgYWN0aXZhdG9yID0gYWN0aXZlLmFjdGl2YXRvck5vZGUuY3VycmVudDtcblxuICAgICAgaWYgKGFjdGl2YXRvciAmJiBldmVudC50YXJnZXQgIT09IGFjdGl2YXRvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBvbkFjdGl2YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IG9uQWN0aXZhdGlvbih7XG4gICAgICAgIGV2ZW50OiBldmVudC5uYXRpdmVFdmVudFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1dO1xuXG5mdW5jdGlvbiBpc0Rpc3RhbmNlQ29uc3RyYWludChjb25zdHJhaW50KSB7XG4gIHJldHVybiBCb29sZWFuKGNvbnN0cmFpbnQgJiYgJ2Rpc3RhbmNlJyBpbiBjb25zdHJhaW50KTtcbn1cblxuZnVuY3Rpb24gaXNEZWxheUNvbnN0cmFpbnQoY29uc3RyYWludCkge1xuICByZXR1cm4gQm9vbGVhbihjb25zdHJhaW50ICYmICdkZWxheScgaW4gY29uc3RyYWludCk7XG59XG5cbmNsYXNzIEFic3RyYWN0UG9pbnRlclNlbnNvciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzLCBldmVudHMsIGxpc3RlbmVyVGFyZ2V0KSB7XG4gICAgdmFyIF9nZXRFdmVudENvb3JkaW5hdGVzO1xuXG4gICAgaWYgKGxpc3RlbmVyVGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICAgIGxpc3RlbmVyVGFyZ2V0ID0gZ2V0RXZlbnRMaXN0ZW5lclRhcmdldChwcm9wcy5ldmVudC50YXJnZXQpO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMgPSB2b2lkIDA7XG4gICAgdGhpcy5ldmVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRvU2Nyb2xsRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5kb2N1bWVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmFjdGl2YXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdGlhbENvb3JkaW5hdGVzID0gdm9pZCAwO1xuICAgIHRoaXMudGltZW91dElkID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLmRvY3VtZW50TGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICBjb25zdCB7XG4gICAgICBldmVudFxuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXRcbiAgICB9ID0gZXZlbnQ7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMuZG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50KHRhcmdldCk7XG4gICAgdGhpcy5kb2N1bWVudExpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnModGhpcy5kb2N1bWVudCk7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKGxpc3RlbmVyVGFyZ2V0KTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoZ2V0V2luZG93KHRhcmdldCkpO1xuICAgIHRoaXMuaW5pdGlhbENvb3JkaW5hdGVzID0gKF9nZXRFdmVudENvb3JkaW5hdGVzID0gZ2V0RXZlbnRDb29yZGluYXRlcyhldmVudCkpICE9IG51bGwgPyBfZ2V0RXZlbnRDb29yZGluYXRlcyA6IGRlZmF1bHRDb29yZGluYXRlcztcbiAgICB0aGlzLmhhbmRsZVN0YXJ0ID0gdGhpcy5oYW5kbGVTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlTW92ZSA9IHRoaXMuaGFuZGxlTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlRW5kID0gdGhpcy5oYW5kbGVFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUNhbmNlbCA9IHRoaXMuaGFuZGxlQ2FuY2VsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVLZXlkb3duID0gdGhpcy5oYW5kbGVLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZW1vdmVUZXh0U2VsZWN0aW9uID0gdGhpcy5yZW1vdmVUZXh0U2VsZWN0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hdHRhY2goKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBldmVudHMsXG4gICAgICBwcm9wczoge1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgYWN0aXZhdGlvbkNvbnN0cmFpbnQsXG4gICAgICAgICAgYnlwYXNzQWN0aXZhdGlvbkNvbnN0cmFpbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChldmVudHMubW92ZS5uYW1lLCB0aGlzLmhhbmRsZU1vdmUsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKGV2ZW50cy5lbmQubmFtZSwgdGhpcy5oYW5kbGVFbmQpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuUmVzaXplLCB0aGlzLmhhbmRsZUNhbmNlbCk7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5EcmFnU3RhcnQsIHByZXZlbnREZWZhdWx0KTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5hZGQoRXZlbnROYW1lLlZpc2liaWxpdHlDaGFuZ2UsIHRoaXMuaGFuZGxlQ2FuY2VsKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5hZGQoRXZlbnROYW1lLkNvbnRleHRNZW51LCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgdGhpcy5kb2N1bWVudExpc3RlbmVycy5hZGQoRXZlbnROYW1lLktleWRvd24sIHRoaXMuaGFuZGxlS2V5ZG93bik7XG5cbiAgICBpZiAoYWN0aXZhdGlvbkNvbnN0cmFpbnQpIHtcbiAgICAgIGlmIChieXBhc3NBY3RpdmF0aW9uQ29uc3RyYWludCAhPSBudWxsICYmIGJ5cGFzc0FjdGl2YXRpb25Db25zdHJhaW50KHtcbiAgICAgICAgZXZlbnQ6IHRoaXMucHJvcHMuZXZlbnQsXG4gICAgICAgIGFjdGl2ZU5vZGU6IHRoaXMucHJvcHMuYWN0aXZlTm9kZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5wcm9wcy5vcHRpb25zXG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdGFydCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEZWxheUNvbnN0cmFpbnQoYWN0aXZhdGlvbkNvbnN0cmFpbnQpKSB7XG4gICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLmhhbmRsZVN0YXJ0LCBhY3RpdmF0aW9uQ29uc3RyYWludC5kZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzdGFuY2VDb25zdHJhaW50KGFjdGl2YXRpb25Db25zdHJhaW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVTdGFydCgpO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLnJlbW92ZUFsbCgpOyAvLyBXYWl0IHVudGlsIHRoZSBuZXh0IGV2ZW50IGxvb3AgYmVmb3JlIHJlbW92aW5nIGRvY3VtZW50IGxpc3RlbmVyc1xuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbGlzdGVuIGZvciBgY2xpY2tgIGFuZCBgc2VsZWN0aW9uYCBldmVudHMgb24gdGhlIGRvY3VtZW50XG5cbiAgICBzZXRUaW1lb3V0KHRoaXMuZG9jdW1lbnRMaXN0ZW5lcnMucmVtb3ZlQWxsLCA1MCk7XG5cbiAgICBpZiAodGhpcy50aW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICB0aGlzLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU3RhcnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5pdGlhbENvb3JkaW5hdGVzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgb25TdGFydFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKGluaXRpYWxDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5hY3RpdmF0ZWQgPSB0cnVlOyAvLyBTdG9wIHByb3BhZ2F0aW9uIG9mIGNsaWNrIGV2ZW50cyBvbmNlIGFjdGl2YXRpb24gY29uc3RyYWludHMgYXJlIG1ldFxuXG4gICAgICB0aGlzLmRvY3VtZW50TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuQ2xpY2ssIHN0b3BQcm9wYWdhdGlvbiwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICB9KTsgLy8gUmVtb3ZlIGFueSB0ZXh0IHNlbGVjdGlvbiBmcm9tIHRoZSBkb2N1bWVudFxuXG4gICAgICB0aGlzLnJlbW92ZVRleHRTZWxlY3Rpb24oKTsgLy8gUHJldmVudCBmdXJ0aGVyIHRleHQgc2VsZWN0aW9uIHdoaWxlIGRyYWdnaW5nXG5cbiAgICAgIHRoaXMuZG9jdW1lbnRMaXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5TZWxlY3Rpb25DaGFuZ2UsIHRoaXMucmVtb3ZlVGV4dFNlbGVjdGlvbik7XG4gICAgICBvblN0YXJ0KGluaXRpYWxDb29yZGluYXRlcyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlTW92ZShldmVudCkge1xuICAgIHZhciBfZ2V0RXZlbnRDb29yZGluYXRlczI7XG5cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmF0ZWQsXG4gICAgICBpbml0aWFsQ29vcmRpbmF0ZXMsXG4gICAgICBwcm9wc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIG9uTW92ZSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYWN0aXZhdGlvbkNvbnN0cmFpbnRcbiAgICAgIH1cbiAgICB9ID0gcHJvcHM7XG5cbiAgICBpZiAoIWluaXRpYWxDb29yZGluYXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gKF9nZXRFdmVudENvb3JkaW5hdGVzMiA9IGdldEV2ZW50Q29vcmRpbmF0ZXMoZXZlbnQpKSAhPSBudWxsID8gX2dldEV2ZW50Q29vcmRpbmF0ZXMyIDogZGVmYXVsdENvb3JkaW5hdGVzO1xuICAgIGNvbnN0IGRlbHRhID0gc3VidHJhY3QoaW5pdGlhbENvb3JkaW5hdGVzLCBjb29yZGluYXRlcyk7IC8vIENvbnN0cmFpbnQgdmFsaWRhdGlvblxuXG4gICAgaWYgKCFhY3RpdmF0ZWQgJiYgYWN0aXZhdGlvbkNvbnN0cmFpbnQpIHtcbiAgICAgIGlmIChpc0Rpc3RhbmNlQ29uc3RyYWludChhY3RpdmF0aW9uQ29uc3RyYWludCkpIHtcbiAgICAgICAgaWYgKGFjdGl2YXRpb25Db25zdHJhaW50LnRvbGVyYW5jZSAhPSBudWxsICYmIGhhc0V4Y2VlZGVkRGlzdGFuY2UoZGVsdGEsIGFjdGl2YXRpb25Db25zdHJhaW50LnRvbGVyYW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDYW5jZWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNFeGNlZWRlZERpc3RhbmNlKGRlbHRhLCBhY3RpdmF0aW9uQ29uc3RyYWludC5kaXN0YW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdGFydCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlbGF5Q29uc3RyYWludChhY3RpdmF0aW9uQ29uc3RyYWludCkpIHtcbiAgICAgICAgaWYgKGhhc0V4Y2VlZGVkRGlzdGFuY2UoZGVsdGEsIGFjdGl2YXRpb25Db25zdHJhaW50LnRvbGVyYW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgb25Nb3ZlKGNvb3JkaW5hdGVzKTtcbiAgfVxuXG4gIGhhbmRsZUVuZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBvbkVuZFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgb25FbmQoKTtcbiAgfVxuXG4gIGhhbmRsZUNhbmNlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBvbkNhbmNlbFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgb25DYW5jZWwoKTtcbiAgfVxuXG4gIGhhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY29kZSA9PT0gS2V5Ym9hcmRDb2RlLkVzYykge1xuICAgICAgdGhpcy5oYW5kbGVDYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVUZXh0U2VsZWN0aW9uKCkge1xuICAgIHZhciBfdGhpcyRkb2N1bWVudCRnZXRTZWw7XG5cbiAgICAoX3RoaXMkZG9jdW1lbnQkZ2V0U2VsID0gdGhpcy5kb2N1bWVudC5nZXRTZWxlY3Rpb24oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGRvY3VtZW50JGdldFNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgfVxuXG59XG5cbmNvbnN0IGV2ZW50cyA9IHtcbiAgbW92ZToge1xuICAgIG5hbWU6ICdwb2ludGVybW92ZSdcbiAgfSxcbiAgZW5kOiB7XG4gICAgbmFtZTogJ3BvaW50ZXJ1cCdcbiAgfVxufTtcbmNsYXNzIFBvaW50ZXJTZW5zb3IgZXh0ZW5kcyBBYnN0cmFjdFBvaW50ZXJTZW5zb3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50XG4gICAgfSA9IHByb3BzOyAvLyBQb2ludGVyIGV2ZW50cyBzdG9wIGZpcmluZyBpZiB0aGUgdGFyZ2V0IGlzIHVubW91bnRlZCB3aGlsZSBkcmFnZ2luZ1xuICAgIC8vIFRoZXJlZm9yZSB3ZSBhdHRhY2ggbGlzdGVuZXJzIHRvIHRoZSBvd25lciBkb2N1bWVudCBpbnN0ZWFkXG5cbiAgICBjb25zdCBsaXN0ZW5lclRhcmdldCA9IGdldE93bmVyRG9jdW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICBzdXBlcihwcm9wcywgZXZlbnRzLCBsaXN0ZW5lclRhcmdldCk7XG4gIH1cblxufVxuUG9pbnRlclNlbnNvci5hY3RpdmF0b3JzID0gW3tcbiAgZXZlbnROYW1lOiAnb25Qb2ludGVyRG93bicsXG4gIGhhbmRsZXI6IChfcmVmLCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICB9ID0gX3JlZjtcbiAgICBsZXQge1xuICAgICAgb25BY3RpdmF0aW9uXG4gICAgfSA9IF9yZWYyO1xuXG4gICAgaWYgKCFldmVudC5pc1ByaW1hcnkgfHwgZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb25BY3RpdmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvbkFjdGl2YXRpb24oe1xuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufV07XG5cbmNvbnN0IGV2ZW50cyQxID0ge1xuICBtb3ZlOiB7XG4gICAgbmFtZTogJ21vdXNlbW92ZSdcbiAgfSxcbiAgZW5kOiB7XG4gICAgbmFtZTogJ21vdXNldXAnXG4gIH1cbn07XG52YXIgTW91c2VCdXR0b247XG5cbihmdW5jdGlvbiAoTW91c2VCdXR0b24pIHtcbiAgTW91c2VCdXR0b25bTW91c2VCdXR0b25bXCJSaWdodENsaWNrXCJdID0gMl0gPSBcIlJpZ2h0Q2xpY2tcIjtcbn0pKE1vdXNlQnV0dG9uIHx8IChNb3VzZUJ1dHRvbiA9IHt9KSk7XG5cbmNsYXNzIE1vdXNlU2Vuc29yIGV4dGVuZHMgQWJzdHJhY3RQb2ludGVyU2Vuc29yIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcywgZXZlbnRzJDEsIGdldE93bmVyRG9jdW1lbnQocHJvcHMuZXZlbnQudGFyZ2V0KSk7XG4gIH1cblxufVxuTW91c2VTZW5zb3IuYWN0aXZhdG9ycyA9IFt7XG4gIGV2ZW50TmFtZTogJ29uTW91c2VEb3duJyxcbiAgaGFuZGxlcjogKF9yZWYsIF9yZWYyKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIG5hdGl2ZUV2ZW50OiBldmVudFxuICAgIH0gPSBfcmVmO1xuICAgIGxldCB7XG4gICAgICBvbkFjdGl2YXRpb25cbiAgICB9ID0gX3JlZjI7XG5cbiAgICBpZiAoZXZlbnQuYnV0dG9uID09PSBNb3VzZUJ1dHRvbi5SaWdodENsaWNrKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb25BY3RpdmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvbkFjdGl2YXRpb24oe1xuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufV07XG5cbmNvbnN0IGV2ZW50cyQyID0ge1xuICBtb3ZlOiB7XG4gICAgbmFtZTogJ3RvdWNobW92ZSdcbiAgfSxcbiAgZW5kOiB7XG4gICAgbmFtZTogJ3RvdWNoZW5kJ1xuICB9XG59O1xuY2xhc3MgVG91Y2hTZW5zb3IgZXh0ZW5kcyBBYnN0cmFjdFBvaW50ZXJTZW5zb3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzLCBldmVudHMkMik7XG4gIH1cblxuICBzdGF0aWMgc2V0dXAoKSB7XG4gICAgLy8gQWRkaW5nIGEgbm9uLWNhcHR1cmUgYW5kIG5vbi1wYXNzaXZlIGB0b3VjaG1vdmVgIGxpc3RlbmVyIGluIG9yZGVyXG4gICAgLy8gdG8gZm9yY2UgYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIGNhbGxzIHRvIHdvcmsgaW4gZHluYW1pY2FsbHkgYWRkZWRcbiAgICAvLyB0b3VjaG1vdmUgZXZlbnQgaGFuZGxlcnMuIFRoaXMgaXMgcmVxdWlyZWQgZm9yIGlPUyBTYWZhcmkuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzJDIubW92ZS5uYW1lLCBub29wLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRlYXJkb3duKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRzJDIubW92ZS5uYW1lLCBub29wKTtcbiAgICB9OyAvLyBXZSBjcmVhdGUgYSBuZXcgaGFuZGxlciBiZWNhdXNlIHRoZSB0ZWFyZG93biBmdW5jdGlvbiBvZiBhbm90aGVyIHNlbnNvclxuICAgIC8vIGNvdWxkIHJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXIgaWYgd2UgdXNlIGEgcmVmZXJlbnRpYWxseSBlcXVhbCBsaXN0ZW5lci5cblxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICB9XG5cbn1cblRvdWNoU2Vuc29yLmFjdGl2YXRvcnMgPSBbe1xuICBldmVudE5hbWU6ICdvblRvdWNoU3RhcnQnLFxuICBoYW5kbGVyOiAoX3JlZiwgX3JlZjIpID0+IHtcbiAgICBsZXQge1xuICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgfSA9IF9yZWY7XG4gICAgbGV0IHtcbiAgICAgIG9uQWN0aXZhdGlvblxuICAgIH0gPSBfcmVmMjtcbiAgICBjb25zdCB7XG4gICAgICB0b3VjaGVzXG4gICAgfSA9IGV2ZW50O1xuXG4gICAgaWYgKHRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9uQWN0aXZhdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb25BY3RpdmF0aW9uKHtcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1dO1xuXG52YXIgQXV0b1Njcm9sbEFjdGl2YXRvcjtcblxuKGZ1bmN0aW9uIChBdXRvU2Nyb2xsQWN0aXZhdG9yKSB7XG4gIEF1dG9TY3JvbGxBY3RpdmF0b3JbQXV0b1Njcm9sbEFjdGl2YXRvcltcIlBvaW50ZXJcIl0gPSAwXSA9IFwiUG9pbnRlclwiO1xuICBBdXRvU2Nyb2xsQWN0aXZhdG9yW0F1dG9TY3JvbGxBY3RpdmF0b3JbXCJEcmFnZ2FibGVSZWN0XCJdID0gMV0gPSBcIkRyYWdnYWJsZVJlY3RcIjtcbn0pKEF1dG9TY3JvbGxBY3RpdmF0b3IgfHwgKEF1dG9TY3JvbGxBY3RpdmF0b3IgPSB7fSkpO1xuXG52YXIgVHJhdmVyc2FsT3JkZXI7XG5cbihmdW5jdGlvbiAoVHJhdmVyc2FsT3JkZXIpIHtcbiAgVHJhdmVyc2FsT3JkZXJbVHJhdmVyc2FsT3JkZXJbXCJUcmVlT3JkZXJcIl0gPSAwXSA9IFwiVHJlZU9yZGVyXCI7XG4gIFRyYXZlcnNhbE9yZGVyW1RyYXZlcnNhbE9yZGVyW1wiUmV2ZXJzZWRUcmVlT3JkZXJcIl0gPSAxXSA9IFwiUmV2ZXJzZWRUcmVlT3JkZXJcIjtcbn0pKFRyYXZlcnNhbE9yZGVyIHx8IChUcmF2ZXJzYWxPcmRlciA9IHt9KSk7XG5cbmZ1bmN0aW9uIHVzZUF1dG9TY3JvbGxlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgYWNjZWxlcmF0aW9uLFxuICAgIGFjdGl2YXRvciA9IEF1dG9TY3JvbGxBY3RpdmF0b3IuUG9pbnRlcixcbiAgICBjYW5TY3JvbGwsXG4gICAgZHJhZ2dpbmdSZWN0LFxuICAgIGVuYWJsZWQsXG4gICAgaW50ZXJ2YWwgPSA1LFxuICAgIG9yZGVyID0gVHJhdmVyc2FsT3JkZXIuVHJlZU9yZGVyLFxuICAgIHBvaW50ZXJDb29yZGluYXRlcyxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JzLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzLFxuICAgIGRlbHRhLFxuICAgIHRocmVzaG9sZFxuICB9ID0gX3JlZjtcbiAgY29uc3Qgc2Nyb2xsSW50ZW50ID0gdXNlU2Nyb2xsSW50ZW50KHtcbiAgICBkZWx0YSxcbiAgICBkaXNhYmxlZDogIWVuYWJsZWRcbiAgfSk7XG4gIGNvbnN0IFtzZXRBdXRvU2Nyb2xsSW50ZXJ2YWwsIGNsZWFyQXV0b1Njcm9sbEludGVydmFsXSA9IHVzZUludGVydmFsKCk7XG4gIGNvbnN0IHNjcm9sbFNwZWVkID0gdXNlUmVmKHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSk7XG4gIGNvbnN0IHNjcm9sbERpcmVjdGlvbiA9IHVzZVJlZih7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH0pO1xuICBjb25zdCByZWN0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgc3dpdGNoIChhY3RpdmF0b3IpIHtcbiAgICAgIGNhc2UgQXV0b1Njcm9sbEFjdGl2YXRvci5Qb2ludGVyOlxuICAgICAgICByZXR1cm4gcG9pbnRlckNvb3JkaW5hdGVzID8ge1xuICAgICAgICAgIHRvcDogcG9pbnRlckNvb3JkaW5hdGVzLnksXG4gICAgICAgICAgYm90dG9tOiBwb2ludGVyQ29vcmRpbmF0ZXMueSxcbiAgICAgICAgICBsZWZ0OiBwb2ludGVyQ29vcmRpbmF0ZXMueCxcbiAgICAgICAgICByaWdodDogcG9pbnRlckNvb3JkaW5hdGVzLnhcbiAgICAgICAgfSA6IG51bGw7XG5cbiAgICAgIGNhc2UgQXV0b1Njcm9sbEFjdGl2YXRvci5EcmFnZ2FibGVSZWN0OlxuICAgICAgICByZXR1cm4gZHJhZ2dpbmdSZWN0O1xuICAgIH1cbiAgfSwgW2FjdGl2YXRvciwgZHJhZ2dpbmdSZWN0LCBwb2ludGVyQ29vcmRpbmF0ZXNdKTtcbiAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBhdXRvU2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lciA9IHNjcm9sbENvbnRhaW5lclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKCFzY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGxMZWZ0ID0gc2Nyb2xsU3BlZWQuY3VycmVudC54ICogc2Nyb2xsRGlyZWN0aW9uLmN1cnJlbnQueDtcbiAgICBjb25zdCBzY3JvbGxUb3AgPSBzY3JvbGxTcGVlZC5jdXJyZW50LnkgKiBzY3JvbGxEaXJlY3Rpb24uY3VycmVudC55O1xuICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxCeShzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApO1xuICB9LCBbXSk7XG4gIGNvbnN0IHNvcnRlZFNjcm9sbGFibGVBbmNlc3RvcnMgPSB1c2VNZW1vKCgpID0+IG9yZGVyID09PSBUcmF2ZXJzYWxPcmRlci5UcmVlT3JkZXIgPyBbLi4uc2Nyb2xsYWJsZUFuY2VzdG9yc10ucmV2ZXJzZSgpIDogc2Nyb2xsYWJsZUFuY2VzdG9ycywgW29yZGVyLCBzY3JvbGxhYmxlQW5jZXN0b3JzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkIHx8ICFzY3JvbGxhYmxlQW5jZXN0b3JzLmxlbmd0aCB8fCAhcmVjdCkge1xuICAgICAgY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHNjcm9sbENvbnRhaW5lciBvZiBzb3J0ZWRTY3JvbGxhYmxlQW5jZXN0b3JzKSB7XG4gICAgICBpZiAoKGNhblNjcm9sbCA9PSBudWxsID8gdm9pZCAwIDogY2FuU2Nyb2xsKHNjcm9sbENvbnRhaW5lcikpID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSBzY3JvbGxhYmxlQW5jZXN0b3JzLmluZGV4T2Yoc2Nyb2xsQ29udGFpbmVyKTtcbiAgICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lclJlY3QgPSBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0c1tpbmRleF07XG5cbiAgICAgIGlmICghc2Nyb2xsQ29udGFpbmVyUmVjdCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIHNwZWVkXG4gICAgICB9ID0gZ2V0U2Nyb2xsRGlyZWN0aW9uQW5kU3BlZWQoc2Nyb2xsQ29udGFpbmVyLCBzY3JvbGxDb250YWluZXJSZWN0LCByZWN0LCBhY2NlbGVyYXRpb24sIHRocmVzaG9sZCk7XG5cbiAgICAgIGZvciAoY29uc3QgYXhpcyBvZiBbJ3gnLCAneSddKSB7XG4gICAgICAgIGlmICghc2Nyb2xsSW50ZW50W2F4aXNdW2RpcmVjdGlvbltheGlzXV0pIHtcbiAgICAgICAgICBzcGVlZFtheGlzXSA9IDA7XG4gICAgICAgICAgZGlyZWN0aW9uW2F4aXNdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3BlZWQueCA+IDAgfHwgc3BlZWQueSA+IDApIHtcbiAgICAgICAgY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWwoKTtcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyUmVmLmN1cnJlbnQgPSBzY3JvbGxDb250YWluZXI7XG4gICAgICAgIHNldEF1dG9TY3JvbGxJbnRlcnZhbChhdXRvU2Nyb2xsLCBpbnRlcnZhbCk7XG4gICAgICAgIHNjcm9sbFNwZWVkLmN1cnJlbnQgPSBzcGVlZDtcbiAgICAgICAgc2Nyb2xsRGlyZWN0aW9uLmN1cnJlbnQgPSBkaXJlY3Rpb247XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY3JvbGxTcGVlZC5jdXJyZW50ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIHNjcm9sbERpcmVjdGlvbi5jdXJyZW50ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIGNsZWFyQXV0b1Njcm9sbEludGVydmFsKCk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2FjY2VsZXJhdGlvbiwgYXV0b1Njcm9sbCwgY2FuU2Nyb2xsLCBjbGVhckF1dG9TY3JvbGxJbnRlcnZhbCwgZW5hYmxlZCwgaW50ZXJ2YWwsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgSlNPTi5zdHJpbmdpZnkocmVjdCksIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgSlNPTi5zdHJpbmdpZnkoc2Nyb2xsSW50ZW50KSwgc2V0QXV0b1Njcm9sbEludGVydmFsLCBzY3JvbGxhYmxlQW5jZXN0b3JzLCBzb3J0ZWRTY3JvbGxhYmxlQW5jZXN0b3JzLCBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cywgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBKU09OLnN0cmluZ2lmeSh0aHJlc2hvbGQpXSk7XG59XG5jb25zdCBkZWZhdWx0U2Nyb2xsSW50ZW50ID0ge1xuICB4OiB7XG4gICAgW0RpcmVjdGlvbi5CYWNrd2FyZF06IGZhbHNlLFxuICAgIFtEaXJlY3Rpb24uRm9yd2FyZF06IGZhbHNlXG4gIH0sXG4gIHk6IHtcbiAgICBbRGlyZWN0aW9uLkJhY2t3YXJkXTogZmFsc2UsXG4gICAgW0RpcmVjdGlvbi5Gb3J3YXJkXTogZmFsc2VcbiAgfVxufTtcblxuZnVuY3Rpb24gdXNlU2Nyb2xsSW50ZW50KF9yZWYyKSB7XG4gIGxldCB7XG4gICAgZGVsdGEsXG4gICAgZGlzYWJsZWRcbiAgfSA9IF9yZWYyO1xuICBjb25zdCBwcmV2aW91c0RlbHRhID0gdXNlUHJldmlvdXMoZGVsdGEpO1xuICByZXR1cm4gdXNlTGF6eU1lbW8ocHJldmlvdXNJbnRlbnQgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhcHJldmlvdXNEZWx0YSB8fCAhcHJldmlvdXNJbnRlbnQpIHtcbiAgICAgIC8vIFJlc2V0IHNjcm9sbCBpbnRlbnQgdHJhY2tpbmcgd2hlbiBhdXRvLXNjcm9sbGluZyBpcyBkaXNhYmxlZFxuICAgICAgcmV0dXJuIGRlZmF1bHRTY3JvbGxJbnRlbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0ge1xuICAgICAgeDogTWF0aC5zaWduKGRlbHRhLnggLSBwcmV2aW91c0RlbHRhLngpLFxuICAgICAgeTogTWF0aC5zaWduKGRlbHRhLnkgLSBwcmV2aW91c0RlbHRhLnkpXG4gICAgfTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgdXNlciBpbnRlbnQgdG8gc2Nyb2xsIGluIGVhY2ggZGlyZWN0aW9uIGZvciBib3RoIGF4aXNcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB7XG4gICAgICAgIFtEaXJlY3Rpb24uQmFja3dhcmRdOiBwcmV2aW91c0ludGVudC54W0RpcmVjdGlvbi5CYWNrd2FyZF0gfHwgZGlyZWN0aW9uLnggPT09IC0xLFxuICAgICAgICBbRGlyZWN0aW9uLkZvcndhcmRdOiBwcmV2aW91c0ludGVudC54W0RpcmVjdGlvbi5Gb3J3YXJkXSB8fCBkaXJlY3Rpb24ueCA9PT0gMVxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgW0RpcmVjdGlvbi5CYWNrd2FyZF06IHByZXZpb3VzSW50ZW50LnlbRGlyZWN0aW9uLkJhY2t3YXJkXSB8fCBkaXJlY3Rpb24ueSA9PT0gLTEsXG4gICAgICAgIFtEaXJlY3Rpb24uRm9yd2FyZF06IHByZXZpb3VzSW50ZW50LnlbRGlyZWN0aW9uLkZvcndhcmRdIHx8IGRpcmVjdGlvbi55ID09PSAxXG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBkZWx0YSwgcHJldmlvdXNEZWx0YV0pO1xufVxuXG5mdW5jdGlvbiB1c2VDYWNoZWROb2RlKGRyYWdnYWJsZU5vZGVzLCBpZCkge1xuICBjb25zdCBkcmFnZ2FibGVOb2RlID0gaWQgIT09IG51bGwgPyBkcmFnZ2FibGVOb2Rlcy5nZXQoaWQpIDogdW5kZWZpbmVkO1xuICBjb25zdCBub2RlID0gZHJhZ2dhYmxlTm9kZSA/IGRyYWdnYWJsZU5vZGUubm9kZS5jdXJyZW50IDogbnVsbDtcbiAgcmV0dXJuIHVzZUxhenlNZW1vKGNhY2hlZE5vZGUgPT4ge1xuICAgIHZhciBfcmVmO1xuXG4gICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIEluIHNvbWUgY2FzZXMsIHRoZSBkcmFnZ2FibGUgbm9kZSBjYW4gdW5tb3VudCB3aGlsZSBkcmFnZ2luZ1xuICAgIC8vIFRoaXMgaXMgdGhlIGNhc2UgZm9yIHZpcnR1YWxpemVkIGxpc3RzLiBJbiB0aG9zZSBzaXR1YXRpb25zLFxuICAgIC8vIHdlIGZhbGwgYmFjayB0byB0aGUgbGFzdCBrbm93biB2YWx1ZSBmb3IgdGhhdCBub2RlLlxuXG5cbiAgICByZXR1cm4gKF9yZWYgPSBub2RlICE9IG51bGwgPyBub2RlIDogY2FjaGVkTm9kZSkgIT0gbnVsbCA/IF9yZWYgOiBudWxsO1xuICB9LCBbbm9kZSwgaWRdKTtcbn1cblxuZnVuY3Rpb24gdXNlQ29tYmluZUFjdGl2YXRvcnMoc2Vuc29ycywgZ2V0U3ludGhldGljSGFuZGxlcikge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBzZW5zb3JzLnJlZHVjZSgoYWNjdW11bGF0b3IsIHNlbnNvcikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlbnNvcjogU2Vuc29yXG4gICAgfSA9IHNlbnNvcjtcbiAgICBjb25zdCBzZW5zb3JBY3RpdmF0b3JzID0gU2Vuc29yLmFjdGl2YXRvcnMubWFwKGFjdGl2YXRvciA9PiAoe1xuICAgICAgZXZlbnROYW1lOiBhY3RpdmF0b3IuZXZlbnROYW1lLFxuICAgICAgaGFuZGxlcjogZ2V0U3ludGhldGljSGFuZGxlcihhY3RpdmF0b3IuaGFuZGxlciwgc2Vuc29yKVxuICAgIH0pKTtcbiAgICByZXR1cm4gWy4uLmFjY3VtdWxhdG9yLCAuLi5zZW5zb3JBY3RpdmF0b3JzXTtcbiAgfSwgW10pLCBbc2Vuc29ycywgZ2V0U3ludGhldGljSGFuZGxlcl0pO1xufVxuXG52YXIgTWVhc3VyaW5nU3RyYXRlZ3k7XG5cbihmdW5jdGlvbiAoTWVhc3VyaW5nU3RyYXRlZ3kpIHtcbiAgTWVhc3VyaW5nU3RyYXRlZ3lbTWVhc3VyaW5nU3RyYXRlZ3lbXCJBbHdheXNcIl0gPSAwXSA9IFwiQWx3YXlzXCI7XG4gIE1lYXN1cmluZ1N0cmF0ZWd5W01lYXN1cmluZ1N0cmF0ZWd5W1wiQmVmb3JlRHJhZ2dpbmdcIl0gPSAxXSA9IFwiQmVmb3JlRHJhZ2dpbmdcIjtcbiAgTWVhc3VyaW5nU3RyYXRlZ3lbTWVhc3VyaW5nU3RyYXRlZ3lbXCJXaGlsZURyYWdnaW5nXCJdID0gMl0gPSBcIldoaWxlRHJhZ2dpbmdcIjtcbn0pKE1lYXN1cmluZ1N0cmF0ZWd5IHx8IChNZWFzdXJpbmdTdHJhdGVneSA9IHt9KSk7XG5cbnZhciBNZWFzdXJpbmdGcmVxdWVuY3k7XG5cbihmdW5jdGlvbiAoTWVhc3VyaW5nRnJlcXVlbmN5KSB7XG4gIE1lYXN1cmluZ0ZyZXF1ZW5jeVtcIk9wdGltaXplZFwiXSA9IFwib3B0aW1pemVkXCI7XG59KShNZWFzdXJpbmdGcmVxdWVuY3kgfHwgKE1lYXN1cmluZ0ZyZXF1ZW5jeSA9IHt9KSk7XG5cbmNvbnN0IGRlZmF1bHRWYWx1ZSA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKCk7XG5mdW5jdGlvbiB1c2VEcm9wcGFibGVNZWFzdXJpbmcoY29udGFpbmVycywgX3JlZikge1xuICBsZXQge1xuICAgIGRyYWdnaW5nLFxuICAgIGRlcGVuZGVuY2llcyxcbiAgICBjb25maWdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFtxdWV1ZSwgc2V0UXVldWVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBmcmVxdWVuY3ksXG4gICAgbWVhc3VyZSxcbiAgICBzdHJhdGVneVxuICB9ID0gY29uZmlnO1xuICBjb25zdCBjb250YWluZXJzUmVmID0gdXNlUmVmKGNvbnRhaW5lcnMpO1xuICBjb25zdCBkaXNhYmxlZCA9IGlzRGlzYWJsZWQoKTtcbiAgY29uc3QgZGlzYWJsZWRSZWYgPSB1c2VMYXRlc3RWYWx1ZShkaXNhYmxlZCk7XG4gIGNvbnN0IG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGlkcykge1xuICAgIGlmIChpZHMgPT09IHZvaWQgMCkge1xuICAgICAgaWRzID0gW107XG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRRdWV1ZSh2YWx1ZSA9PiB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlLmNvbmNhdChpZHMuZmlsdGVyKGlkID0+ICF2YWx1ZS5pbmNsdWRlcyhpZCkpKTtcbiAgICB9KTtcbiAgfSwgW2Rpc2FibGVkUmVmXSk7XG4gIGNvbnN0IHRpbWVvdXRJZCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZHJvcHBhYmxlUmVjdHMgPSB1c2VMYXp5TWVtbyhwcmV2aW91c1ZhbHVlID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgJiYgIWRyYWdnaW5nKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGlmICghcHJldmlvdXNWYWx1ZSB8fCBwcmV2aW91c1ZhbHVlID09PSBkZWZhdWx0VmFsdWUgfHwgY29udGFpbmVyc1JlZi5jdXJyZW50ICE9PSBjb250YWluZXJzIHx8IHF1ZXVlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcblxuICAgICAgZm9yIChsZXQgY29udGFpbmVyIG9mIGNvbnRhaW5lcnMpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChxdWV1ZSAmJiBxdWV1ZS5sZW5ndGggPiAwICYmICFxdWV1ZS5pbmNsdWRlcyhjb250YWluZXIuaWQpICYmIGNvbnRhaW5lci5yZWN0LmN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBUaGlzIGNvbnRhaW5lciBkb2VzIG5vdCBuZWVkIHRvIGJlIHJlLW1lYXN1cmVkXG4gICAgICAgICAgbWFwLnNldChjb250YWluZXIuaWQsIGNvbnRhaW5lci5yZWN0LmN1cnJlbnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRhaW5lci5ub2RlLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBub2RlID8gbmV3IFJlY3QobWVhc3VyZShub2RlKSwgbm9kZSkgOiBudWxsO1xuICAgICAgICBjb250YWluZXIucmVjdC5jdXJyZW50ID0gcmVjdDtcblxuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgIG1hcC5zZXQoY29udGFpbmVyLmlkLCByZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xuICB9LCBbY29udGFpbmVycywgcXVldWUsIGRyYWdnaW5nLCBkaXNhYmxlZCwgbWVhc3VyZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnRhaW5lcnNSZWYuY3VycmVudCA9IGNvbnRhaW5lcnM7XG4gIH0sIFtjb250YWluZXJzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMoKTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbZHJhZ2dpbmcsIGRpc2FibGVkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHF1ZXVlICYmIHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHNldFF1ZXVlKG51bGwpO1xuICAgIH1cbiAgfSwgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtKU09OLnN0cmluZ2lmeShxdWV1ZSldKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgdHlwZW9mIGZyZXF1ZW5jeSAhPT0gJ251bWJlcicgfHwgdGltZW91dElkLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1lb3V0SWQuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMoKTtcbiAgICAgIHRpbWVvdXRJZC5jdXJyZW50ID0gbnVsbDtcbiAgICB9LCBmcmVxdWVuY3kpO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtmcmVxdWVuY3ksIGRpc2FibGVkLCBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycywgLi4uZGVwZW5kZW5jaWVzXSk7XG4gIHJldHVybiB7XG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgbWVhc3VyaW5nU2NoZWR1bGVkOiBxdWV1ZSAhPSBudWxsXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNEaXNhYmxlZCgpIHtcbiAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICBjYXNlIE1lYXN1cmluZ1N0cmF0ZWd5LkFsd2F5czpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjYXNlIE1lYXN1cmluZ1N0cmF0ZWd5LkJlZm9yZURyYWdnaW5nOlxuICAgICAgICByZXR1cm4gZHJhZ2dpbmc7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAhZHJhZ2dpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUluaXRpYWxWYWx1ZSh2YWx1ZSwgY29tcHV0ZUZuKSB7XG4gIHJldHVybiB1c2VMYXp5TWVtbyhwcmV2aW91c1ZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVvZiBjb21wdXRlRm4gPT09ICdmdW5jdGlvbicgPyBjb21wdXRlRm4odmFsdWUpIDogdmFsdWU7XG4gIH0sIFtjb21wdXRlRm4sIHZhbHVlXSk7XG59XG5cbmZ1bmN0aW9uIHVzZUluaXRpYWxSZWN0KG5vZGUsIG1lYXN1cmUpIHtcbiAgcmV0dXJuIHVzZUluaXRpYWxWYWx1ZShub2RlLCBtZWFzdXJlKTtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgTXV0YXRpb25PYnNlcnZlciBpbnN0YW5jZS5cclxuICogSWYgYE11dGF0aW9uT2JzZXJ2ZXJgIGlzIHVuZGVmaW5lZCBpbiB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50LCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG4gKi9cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgY2FsbGJhY2ssXG4gICAgZGlzYWJsZWRcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGhhbmRsZU11dGF0aW9ucyA9IHVzZUV2ZW50KGNhbGxiYWNrKTtcbiAgY29uc3QgbXV0YXRpb25PYnNlcnZlciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIE11dGF0aW9uT2JzZXJ2ZXJcbiAgICB9ID0gd2luZG93O1xuICAgIHJldHVybiBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbnMpO1xuICB9LCBbaGFuZGxlTXV0YXRpb25zLCBkaXNhYmxlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiBtdXRhdGlvbk9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfSwgW211dGF0aW9uT2JzZXJ2ZXJdKTtcbiAgcmV0dXJuIG11dGF0aW9uT2JzZXJ2ZXI7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIGJvdW5kIHRvIHRoZSBgb25SZXNpemVgIGNhbGxiYWNrLlxyXG4gKiBJZiBgUmVzaXplT2JzZXJ2ZXJgIGlzIHVuZGVmaW5lZCBpbiB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50LCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG4gKi9cblxuZnVuY3Rpb24gdXNlUmVzaXplT2JzZXJ2ZXIoX3JlZikge1xuICBsZXQge1xuICAgIGNhbGxiYWNrLFxuICAgIGRpc2FibGVkXG4gIH0gPSBfcmVmO1xuICBjb25zdCBoYW5kbGVSZXNpemUgPSB1c2VFdmVudChjYWxsYmFjayk7XG4gIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIFJlc2l6ZU9ic2VydmVyXG4gICAgfSA9IHdpbmRvdztcbiAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyKGhhbmRsZVJlc2l6ZSk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2Rpc2FibGVkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHJlc2l6ZU9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0sIFtyZXNpemVPYnNlcnZlcl0pO1xuICByZXR1cm4gcmVzaXplT2JzZXJ2ZXI7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRNZWFzdXJlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBSZWN0KGdldENsaWVudFJlY3QoZWxlbWVudCksIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWN0KGVsZW1lbnQsIG1lYXN1cmUsIGZhbGxiYWNrUmVjdCkge1xuICBpZiAobWVhc3VyZSA9PT0gdm9pZCAwKSB7XG4gICAgbWVhc3VyZSA9IGRlZmF1bHRNZWFzdXJlO1xuICB9XG5cbiAgY29uc3QgW3JlY3QsIG1lYXN1cmVSZWN0XSA9IHVzZVJlZHVjZXIocmVkdWNlciwgbnVsbCk7XG4gIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSB1c2VNdXRhdGlvbk9ic2VydmVyKHtcbiAgICBjYWxsYmFjayhyZWNvcmRzKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHRhcmdldFxuICAgICAgICB9ID0gcmVjb3JkO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnY2hpbGRMaXN0JyAmJiB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0YXJnZXQuY29udGFpbnMoZWxlbWVudCkpIHtcbiAgICAgICAgICBtZWFzdXJlUmVjdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZVJlc2l6ZU9ic2VydmVyKHtcbiAgICBjYWxsYmFjazogbWVhc3VyZVJlY3RcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIG1lYXN1cmVSZWN0KCk7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICBtdXRhdGlvbk9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgbXV0YXRpb25PYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9LCBbZWxlbWVudF0pO1xuICByZXR1cm4gcmVjdDtcblxuICBmdW5jdGlvbiByZWR1Y2VyKGN1cnJlbnRSZWN0KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5pc0Nvbm5lY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICAvLyBGYWxsIGJhY2sgdG8gbGFzdCByZWN0IHdlIG1lYXN1cmVkIGlmIHRoZSBlbGVtZW50IGlzXG4gICAgICAvLyBubyBsb25nZXIgY29ubmVjdGVkIHRvIHRoZSBET00uXG4gICAgICByZXR1cm4gKF9yZWYgPSBjdXJyZW50UmVjdCAhPSBudWxsID8gY3VycmVudFJlY3QgOiBmYWxsYmFja1JlY3QpICE9IG51bGwgPyBfcmVmIDogbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdSZWN0ID0gbWVhc3VyZShlbGVtZW50KTtcblxuICAgIGlmIChKU09OLnN0cmluZ2lmeShjdXJyZW50UmVjdCkgPT09IEpTT04uc3RyaW5naWZ5KG5ld1JlY3QpKSB7XG4gICAgICByZXR1cm4gY3VycmVudFJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1JlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlUmVjdERlbHRhKHJlY3QpIHtcbiAgY29uc3QgaW5pdGlhbFJlY3QgPSB1c2VJbml0aWFsVmFsdWUocmVjdCk7XG4gIHJldHVybiBnZXRSZWN0RGVsdGEocmVjdCwgaW5pdGlhbFJlY3QpO1xufVxuXG5jb25zdCBkZWZhdWx0VmFsdWUkMSA9IFtdO1xuZnVuY3Rpb24gdXNlU2Nyb2xsYWJsZUFuY2VzdG9ycyhub2RlKSB7XG4gIGNvbnN0IHByZXZpb3VzTm9kZSA9IHVzZVJlZihub2RlKTtcbiAgY29uc3QgYW5jZXN0b3JzID0gdXNlTGF6eU1lbW8ocHJldmlvdXNWYWx1ZSA9PiB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlJDE7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzVmFsdWUgJiYgcHJldmlvdXNWYWx1ZSAhPT0gZGVmYXVsdFZhbHVlJDEgJiYgbm9kZSAmJiBwcmV2aW91c05vZGUuY3VycmVudCAmJiBub2RlLnBhcmVudE5vZGUgPT09IHByZXZpb3VzTm9kZS5jdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzKG5vZGUpO1xuICB9LCBbbm9kZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHByZXZpb3VzTm9kZS5jdXJyZW50ID0gbm9kZTtcbiAgfSwgW25vZGVdKTtcbiAgcmV0dXJuIGFuY2VzdG9ycztcbn1cblxuZnVuY3Rpb24gdXNlU2Nyb2xsT2Zmc2V0cyhlbGVtZW50cykge1xuICBjb25zdCBbc2Nyb2xsQ29vcmRpbmF0ZXMsIHNldFNjcm9sbENvb3JkaW5hdGVzXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBwcmV2RWxlbWVudHMgPSB1c2VSZWYoZWxlbWVudHMpOyAvLyBUby1kbzogVGhyb3R0bGUgdGhlIGhhbmRsZVNjcm9sbCBjYWxsYmFja1xuXG4gIGNvbnN0IGhhbmRsZVNjcm9sbCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBjb25zdCBzY3JvbGxpbmdFbGVtZW50ID0gZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcblxuICAgIGlmICghc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFNjcm9sbENvb3JkaW5hdGVzKHNjcm9sbENvb3JkaW5hdGVzID0+IHtcbiAgICAgIGlmICghc2Nyb2xsQ29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHNjcm9sbENvb3JkaW5hdGVzLnNldChzY3JvbGxpbmdFbGVtZW50LCBnZXRTY3JvbGxDb29yZGluYXRlcyhzY3JvbGxpbmdFbGVtZW50KSk7XG4gICAgICByZXR1cm4gbmV3IE1hcChzY3JvbGxDb29yZGluYXRlcyk7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c0VsZW1lbnRzID0gcHJldkVsZW1lbnRzLmN1cnJlbnQ7XG5cbiAgICBpZiAoZWxlbWVudHMgIT09IHByZXZpb3VzRWxlbWVudHMpIHtcbiAgICAgIGNsZWFudXAocHJldmlvdXNFbGVtZW50cyk7XG4gICAgICBjb25zdCBlbnRyaWVzID0gZWxlbWVudHMubWFwKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IGdldFNjcm9sbGFibGVFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChzY3JvbGxhYmxlRWxlbWVudCkge1xuICAgICAgICAgIHNjcm9sbGFibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBbc2Nyb2xsYWJsZUVsZW1lbnQsIGdldFNjcm9sbENvb3JkaW5hdGVzKHNjcm9sbGFibGVFbGVtZW50KV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pLmZpbHRlcihlbnRyeSA9PiBlbnRyeSAhPSBudWxsKTtcbiAgICAgIHNldFNjcm9sbENvb3JkaW5hdGVzKGVudHJpZXMubGVuZ3RoID8gbmV3IE1hcChlbnRyaWVzKSA6IG51bGwpO1xuICAgICAgcHJldkVsZW1lbnRzLmN1cnJlbnQgPSBlbGVtZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cChlbGVtZW50cyk7XG4gICAgICBjbGVhbnVwKHByZXZpb3VzRWxlbWVudHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwKGVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IGdldFNjcm9sbGFibGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsYWJsZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2hhbmRsZVNjcm9sbCwgZWxlbWVudHNdKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzY3JvbGxDb29yZGluYXRlcyA/IEFycmF5LmZyb20oc2Nyb2xsQ29vcmRpbmF0ZXMudmFsdWVzKCkpLnJlZHVjZSgoYWNjLCBjb29yZGluYXRlcykgPT4gYWRkKGFjYywgY29vcmRpbmF0ZXMpLCBkZWZhdWx0Q29vcmRpbmF0ZXMpIDogZ2V0U2Nyb2xsT2Zmc2V0cyhlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRDb29yZGluYXRlcztcbiAgfSwgW2VsZW1lbnRzLCBzY3JvbGxDb29yZGluYXRlc10pO1xufVxuXG5mdW5jdGlvbiB1c2VTY3JvbGxPZmZzZXRzRGVsdGEoc2Nyb2xsT2Zmc2V0cywgZGVwZW5kZW5jaWVzKSB7XG4gIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkge1xuICAgIGRlcGVuZGVuY2llcyA9IFtdO1xuICB9XG5cbiAgY29uc3QgaW5pdGlhbFNjcm9sbE9mZnNldHMgPSB1c2VSZWYobnVsbCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaW5pdGlhbFNjcm9sbE9mZnNldHMuY3VycmVudCA9IG51bGw7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgZGVwZW5kZW5jaWVzKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYXNTY3JvbGxPZmZzZXRzID0gc2Nyb2xsT2Zmc2V0cyAhPT0gZGVmYXVsdENvb3JkaW5hdGVzO1xuXG4gICAgaWYgKGhhc1Njcm9sbE9mZnNldHMgJiYgIWluaXRpYWxTY3JvbGxPZmZzZXRzLmN1cnJlbnQpIHtcbiAgICAgIGluaXRpYWxTY3JvbGxPZmZzZXRzLmN1cnJlbnQgPSBzY3JvbGxPZmZzZXRzO1xuICAgIH1cblxuICAgIGlmICghaGFzU2Nyb2xsT2Zmc2V0cyAmJiBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50KSB7XG4gICAgICBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtzY3JvbGxPZmZzZXRzXSk7XG4gIHJldHVybiBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50ID8gc3VidHJhY3Qoc2Nyb2xsT2Zmc2V0cywgaW5pdGlhbFNjcm9sbE9mZnNldHMuY3VycmVudCkgOiBkZWZhdWx0Q29vcmRpbmF0ZXM7XG59XG5cbmZ1bmN0aW9uIHVzZVNlbnNvclNldHVwKHNlbnNvcnMpIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNhblVzZURPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRlYXJkb3duRm5zID0gc2Vuc29ycy5tYXAoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBzZW5zb3JcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIHNlbnNvci5zZXR1cCA9PSBudWxsID8gdm9pZCAwIDogc2Vuc29yLnNldHVwKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdGVhcmRvd24gb2YgdGVhcmRvd25GbnMpIHtcbiAgICAgICAgdGVhcmRvd24gPT0gbnVsbCA/IHZvaWQgMCA6IHRlYXJkb3duKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgLy8gVE8tRE86IFNlbnNvcnMgbGVuZ3RoIGNvdWxkIHRoZW9yZXRpY2FsbHkgY2hhbmdlIHdoaWNoIHdvdWxkIG5vdCBiZSBhIHZhbGlkIGRlcGVuZGVuY3lcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBzZW5zb3JzLm1hcChfcmVmMiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHNlbnNvclxuICAgIH0gPSBfcmVmMjtcbiAgICByZXR1cm4gc2Vuc29yO1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHVzZVN5bnRoZXRpY0xpc3RlbmVycyhsaXN0ZW5lcnMsIGlkKSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gbGlzdGVuZXJzLnJlZHVjZSgoYWNjLCBfcmVmKSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBldmVudE5hbWUsXG4gICAgICAgIGhhbmRsZXJcbiAgICAgIH0gPSBfcmVmO1xuXG4gICAgICBhY2NbZXZlbnROYW1lXSA9IGV2ZW50ID0+IHtcbiAgICAgICAgaGFuZGxlcihldmVudCwgaWQpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH0sIFtsaXN0ZW5lcnMsIGlkXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVdpbmRvd1JlY3QoZWxlbWVudCkge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBlbGVtZW50ID8gZ2V0V2luZG93Q2xpZW50UmVjdChlbGVtZW50KSA6IG51bGwsIFtlbGVtZW50XSk7XG59XG5cbmNvbnN0IGRlZmF1bHRWYWx1ZSQyID0gW107XG5mdW5jdGlvbiB1c2VSZWN0cyhlbGVtZW50cywgbWVhc3VyZSkge1xuICBpZiAobWVhc3VyZSA9PT0gdm9pZCAwKSB7XG4gICAgbWVhc3VyZSA9IGdldENsaWVudFJlY3Q7XG4gIH1cblxuICBjb25zdCBbZmlyc3RFbGVtZW50XSA9IGVsZW1lbnRzO1xuICBjb25zdCB3aW5kb3dSZWN0ID0gdXNlV2luZG93UmVjdChmaXJzdEVsZW1lbnQgPyBnZXRXaW5kb3coZmlyc3RFbGVtZW50KSA6IG51bGwpO1xuICBjb25zdCBbcmVjdHMsIG1lYXN1cmVSZWN0c10gPSB1c2VSZWR1Y2VyKHJlZHVjZXIsIGRlZmF1bHRWYWx1ZSQyKTtcbiAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcih7XG4gICAgY2FsbGJhY2s6IG1lYXN1cmVSZWN0c1xuICB9KTtcblxuICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCAmJiByZWN0cyA9PT0gZGVmYXVsdFZhbHVlJDIpIHtcbiAgICBtZWFzdXJlUmVjdHMoKTtcbiAgfVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBtZWFzdXJlUmVjdHMoKTtcbiAgICB9XG4gIH0sIFtlbGVtZW50c10pO1xuICByZXR1cm4gcmVjdHM7XG5cbiAgZnVuY3Rpb24gcmVkdWNlcigpIHtcbiAgICBpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSQyO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50cy5tYXAoZWxlbWVudCA9PiBpc0RvY3VtZW50U2Nyb2xsaW5nRWxlbWVudChlbGVtZW50KSA/IHdpbmRvd1JlY3QgOiBuZXcgUmVjdChtZWFzdXJlKGVsZW1lbnQpLCBlbGVtZW50KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVhc3VyYWJsZU5vZGUobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChmaXJzdENoaWxkKSA/IGZpcnN0Q2hpbGQgOiBub2RlO1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnT3ZlcmxheU1lYXN1cmluZyhfcmVmKSB7XG4gIGxldCB7XG4gICAgbWVhc3VyZVxuICB9ID0gX3JlZjtcbiAgY29uc3QgW3JlY3QsIHNldFJlY3RdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGhhbmRsZVJlc2l6ZSA9IHVzZUNhbGxiYWNrKGVudHJpZXMgPT4ge1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgdGFyZ2V0XG4gICAgfSBvZiBlbnRyaWVzKSB7XG4gICAgICBpZiAoaXNIVE1MRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgIHNldFJlY3QocmVjdCA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3UmVjdCA9IG1lYXN1cmUodGFyZ2V0KTtcbiAgICAgICAgICByZXR1cm4gcmVjdCA/IHsgLi4ucmVjdCxcbiAgICAgICAgICAgIHdpZHRoOiBuZXdSZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBuZXdSZWN0LmhlaWdodFxuICAgICAgICAgIH0gOiBuZXdSZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCBbbWVhc3VyZV0pO1xuICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZVJlc2l6ZU9ic2VydmVyKHtcbiAgICBjYWxsYmFjazogaGFuZGxlUmVzaXplXG4gIH0pO1xuICBjb25zdCBoYW5kbGVOb2RlQ2hhbmdlID0gdXNlQ2FsbGJhY2soZWxlbWVudCA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGdldE1lYXN1cmFibGVOb2RlKGVsZW1lbnQpO1xuICAgIHJlc2l6ZU9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUobm9kZSk7XG4gICAgfVxuXG4gICAgc2V0UmVjdChub2RlID8gbWVhc3VyZShub2RlKSA6IG51bGwpO1xuICB9LCBbbWVhc3VyZSwgcmVzaXplT2JzZXJ2ZXJdKTtcbiAgY29uc3QgW25vZGVSZWYsIHNldFJlZl0gPSB1c2VOb2RlUmVmKGhhbmRsZU5vZGVDaGFuZ2UpO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiAoe1xuICAgIG5vZGVSZWYsXG4gICAgcmVjdCxcbiAgICBzZXRSZWZcbiAgfSksIFtyZWN0LCBub2RlUmVmLCBzZXRSZWZdKTtcbn1cblxuY29uc3QgZGVmYXVsdFNlbnNvcnMgPSBbe1xuICBzZW5zb3I6IFBvaW50ZXJTZW5zb3IsXG4gIG9wdGlvbnM6IHt9XG59LCB7XG4gIHNlbnNvcjogS2V5Ym9hcmRTZW5zb3IsXG4gIG9wdGlvbnM6IHt9XG59XTtcbmNvbnN0IGRlZmF1bHREYXRhID0ge1xuICBjdXJyZW50OiB7fVxufTtcbmNvbnN0IGRlZmF1bHRNZWFzdXJpbmdDb25maWd1cmF0aW9uID0ge1xuICBkcmFnZ2FibGU6IHtcbiAgICBtZWFzdXJlOiBnZXRUcmFuc2Zvcm1BZ25vc3RpY0NsaWVudFJlY3RcbiAgfSxcbiAgZHJvcHBhYmxlOiB7XG4gICAgbWVhc3VyZTogZ2V0VHJhbnNmb3JtQWdub3N0aWNDbGllbnRSZWN0LFxuICAgIHN0cmF0ZWd5OiBNZWFzdXJpbmdTdHJhdGVneS5XaGlsZURyYWdnaW5nLFxuICAgIGZyZXF1ZW5jeTogTWVhc3VyaW5nRnJlcXVlbmN5Lk9wdGltaXplZFxuICB9LFxuICBkcmFnT3ZlcmxheToge1xuICAgIG1lYXN1cmU6IGdldENsaWVudFJlY3RcbiAgfVxufTtcblxuY2xhc3MgRHJvcHBhYmxlQ29udGFpbmVyc01hcCBleHRlbmRzIE1hcCB7XG4gIGdldChpZCkge1xuICAgIHZhciBfc3VwZXIkZ2V0O1xuXG4gICAgcmV0dXJuIGlkICE9IG51bGwgPyAoX3N1cGVyJGdldCA9IHN1cGVyLmdldChpZCkpICE9IG51bGwgPyBfc3VwZXIkZ2V0IDogdW5kZWZpbmVkIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnZhbHVlcygpKTtcbiAgfVxuXG4gIGdldEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbHRlcihfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGRpc2FibGVkXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiAhZGlzYWJsZWQ7XG4gICAgfSk7XG4gIH1cblxuICBnZXROb2RlRm9yKGlkKSB7XG4gICAgdmFyIF90aGlzJGdldCRub2RlJGN1cnJlbiwgX3RoaXMkZ2V0O1xuXG4gICAgcmV0dXJuIChfdGhpcyRnZXQkbm9kZSRjdXJyZW4gPSAoX3RoaXMkZ2V0ID0gdGhpcy5nZXQoaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZ2V0Lm5vZGUuY3VycmVudCkgIT0gbnVsbCA/IF90aGlzJGdldCRub2RlJGN1cnJlbiA6IHVuZGVmaW5lZDtcbiAgfVxuXG59XG5cbmNvbnN0IGRlZmF1bHRQdWJsaWNDb250ZXh0ID0ge1xuICBhY3RpdmF0b3JFdmVudDogbnVsbCxcbiAgYWN0aXZlOiBudWxsLFxuICBhY3RpdmVOb2RlOiBudWxsLFxuICBhY3RpdmVOb2RlUmVjdDogbnVsbCxcbiAgY29sbGlzaW9uczogbnVsbCxcbiAgY29udGFpbmVyTm9kZVJlY3Q6IG51bGwsXG4gIGRyYWdnYWJsZU5vZGVzOiAvKiNfX1BVUkVfXyovbmV3IE1hcCgpLFxuICBkcm9wcGFibGVSZWN0czogLyojX19QVVJFX18qL25ldyBNYXAoKSxcbiAgZHJvcHBhYmxlQ29udGFpbmVyczogLyojX19QVVJFX18qL25ldyBEcm9wcGFibGVDb250YWluZXJzTWFwKCksXG4gIG92ZXI6IG51bGwsXG4gIGRyYWdPdmVybGF5OiB7XG4gICAgbm9kZVJlZjoge1xuICAgICAgY3VycmVudDogbnVsbFxuICAgIH0sXG4gICAgcmVjdDogbnVsbCxcbiAgICBzZXRSZWY6IG5vb3BcbiAgfSxcbiAgc2Nyb2xsYWJsZUFuY2VzdG9yczogW10sXG4gIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzOiBbXSxcbiAgbWVhc3VyaW5nQ29uZmlndXJhdGlvbjogZGVmYXVsdE1lYXN1cmluZ0NvbmZpZ3VyYXRpb24sXG4gIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzOiBub29wLFxuICB3aW5kb3dSZWN0OiBudWxsLFxuICBtZWFzdXJpbmdTY2hlZHVsZWQ6IGZhbHNlXG59O1xuY29uc3QgZGVmYXVsdEludGVybmFsQ29udGV4dCA9IHtcbiAgYWN0aXZhdG9yRXZlbnQ6IG51bGwsXG4gIGFjdGl2YXRvcnM6IFtdLFxuICBhY3RpdmU6IG51bGwsXG4gIGFjdGl2ZU5vZGVSZWN0OiBudWxsLFxuICBhcmlhRGVzY3JpYmVkQnlJZDoge1xuICAgIGRyYWdnYWJsZTogJydcbiAgfSxcbiAgZGlzcGF0Y2g6IG5vb3AsXG4gIGRyYWdnYWJsZU5vZGVzOiAvKiNfX1BVUkVfXyovbmV3IE1hcCgpLFxuICBvdmVyOiBudWxsLFxuICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVyczogbm9vcFxufTtcbmNvbnN0IEludGVybmFsQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGRlZmF1bHRJbnRlcm5hbENvbnRleHQpO1xuY29uc3QgUHVibGljQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGRlZmF1bHRQdWJsaWNDb250ZXh0KTtcblxuZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICByZXR1cm4ge1xuICAgIGRyYWdnYWJsZToge1xuICAgICAgYWN0aXZlOiBudWxsLFxuICAgICAgaW5pdGlhbENvb3JkaW5hdGVzOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICBub2RlczogbmV3IE1hcCgpLFxuICAgICAgdHJhbnNsYXRlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyb3BwYWJsZToge1xuICAgICAgY29udGFpbmVyczogbmV3IERyb3BwYWJsZUNvbnRhaW5lcnNNYXAoKVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBBY3Rpb24uRHJhZ1N0YXJ0OlxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgIGRyYWdnYWJsZTogeyAuLi5zdGF0ZS5kcmFnZ2FibGUsXG4gICAgICAgICAgaW5pdGlhbENvb3JkaW5hdGVzOiBhY3Rpb24uaW5pdGlhbENvb3JkaW5hdGVzLFxuICAgICAgICAgIGFjdGl2ZTogYWN0aW9uLmFjdGl2ZVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgY2FzZSBBY3Rpb24uRHJhZ01vdmU6XG4gICAgICBpZiAoIXN0YXRlLmRyYWdnYWJsZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgZHJhZ2dhYmxlOiB7IC4uLnN0YXRlLmRyYWdnYWJsZSxcbiAgICAgICAgICB0cmFuc2xhdGU6IHtcbiAgICAgICAgICAgIHg6IGFjdGlvbi5jb29yZGluYXRlcy54IC0gc3RhdGUuZHJhZ2dhYmxlLmluaXRpYWxDb29yZGluYXRlcy54LFxuICAgICAgICAgICAgeTogYWN0aW9uLmNvb3JkaW5hdGVzLnkgLSBzdGF0ZS5kcmFnZ2FibGUuaW5pdGlhbENvb3JkaW5hdGVzLnlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICBjYXNlIEFjdGlvbi5EcmFnRW5kOlxuICAgIGNhc2UgQWN0aW9uLkRyYWdDYW5jZWw6XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgZHJhZ2dhYmxlOiB7IC4uLnN0YXRlLmRyYWdnYWJsZSxcbiAgICAgICAgICBhY3RpdmU6IG51bGwsXG4gICAgICAgICAgaW5pdGlhbENvb3JkaW5hdGVzOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJhbnNsYXRlOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIGNhc2UgQWN0aW9uLlJlZ2lzdGVyRHJvcHBhYmxlOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZWxlbWVudFxuICAgICAgICB9ID0gYWN0aW9uO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBuZXcgRHJvcHBhYmxlQ29udGFpbmVyc01hcChzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycyk7XG4gICAgICAgIGNvbnRhaW5lcnMuc2V0KGlkLCBlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgZHJvcHBhYmxlOiB7IC4uLnN0YXRlLmRyb3BwYWJsZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcnNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlIEFjdGlvbi5TZXREcm9wcGFibGVEaXNhYmxlZDpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICB9ID0gYWN0aW9uO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gc3RhdGUuZHJvcHBhYmxlLmNvbnRhaW5lcnMuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWVsZW1lbnQgfHwga2V5ICE9PSBlbGVtZW50LmtleSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBuZXcgRHJvcHBhYmxlQ29udGFpbmVyc01hcChzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycyk7XG4gICAgICAgIGNvbnRhaW5lcnMuc2V0KGlkLCB7IC4uLmVsZW1lbnQsXG4gICAgICAgICAgZGlzYWJsZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICAgIGRyb3BwYWJsZTogeyAuLi5zdGF0ZS5kcm9wcGFibGUsXG4gICAgICAgICAgICBjb250YWluZXJzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSBBY3Rpb24uVW5yZWdpc3RlckRyb3BwYWJsZTpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGtleVxuICAgICAgICB9ID0gYWN0aW9uO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gc3RhdGUuZHJvcHBhYmxlLmNvbnRhaW5lcnMuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWVsZW1lbnQgfHwga2V5ICE9PSBlbGVtZW50LmtleSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBuZXcgRHJvcHBhYmxlQ29udGFpbmVyc01hcChzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycyk7XG4gICAgICAgIGNvbnRhaW5lcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgZHJvcHBhYmxlOiB7IC4uLnN0YXRlLmRyb3BwYWJsZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcnNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVzdG9yZUZvY3VzKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBkaXNhYmxlZFxuICB9ID0gX3JlZjtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBkcmFnZ2FibGVOb2Rlc1xuICB9ID0gdXNlQ29udGV4dChJbnRlcm5hbENvbnRleHQpO1xuICBjb25zdCBwcmV2aW91c0FjdGl2YXRvckV2ZW50ID0gdXNlUHJldmlvdXMoYWN0aXZhdG9yRXZlbnQpO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUlkID0gdXNlUHJldmlvdXMoYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaWQpOyAvLyBSZXN0b3JlIGtleWJvYXJkIGZvY3VzIG9uIHRoZSBhY3RpdmF0b3Igbm9kZVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFhY3RpdmF0b3JFdmVudCAmJiBwcmV2aW91c0FjdGl2YXRvckV2ZW50ICYmIHByZXZpb3VzQWN0aXZlSWQgIT0gbnVsbCkge1xuICAgICAgaWYgKCFpc0tleWJvYXJkRXZlbnQocHJldmlvdXNBY3RpdmF0b3JFdmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gcHJldmlvdXNBY3RpdmF0b3JFdmVudC50YXJnZXQpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byByZXN0b3JlIGZvY3VzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZHJhZ2dhYmxlTm9kZSA9IGRyYWdnYWJsZU5vZGVzLmdldChwcmV2aW91c0FjdGl2ZUlkKTtcblxuICAgICAgaWYgKCFkcmFnZ2FibGVOb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RpdmF0b3JOb2RlLFxuICAgICAgICBub2RlXG4gICAgICB9ID0gZHJhZ2dhYmxlTm9kZTtcblxuICAgICAgaWYgKCFhY3RpdmF0b3JOb2RlLmN1cnJlbnQgJiYgIW5vZGUuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbYWN0aXZhdG9yTm9kZS5jdXJyZW50LCBub2RlLmN1cnJlbnRdKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBmb2N1c2FibGVOb2RlID0gZmluZEZpcnN0Rm9jdXNhYmxlTm9kZShlbGVtZW50KTtcblxuICAgICAgICAgIGlmIChmb2N1c2FibGVOb2RlKSB7XG4gICAgICAgICAgICBmb2N1c2FibGVOb2RlLmZvY3VzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2FjdGl2YXRvckV2ZW50LCBkaXNhYmxlZCwgZHJhZ2dhYmxlTm9kZXMsIHByZXZpb3VzQWN0aXZlSWQsIHByZXZpb3VzQWN0aXZhdG9yRXZlbnRdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFwcGx5TW9kaWZpZXJzKG1vZGlmaWVycywgX3JlZikge1xuICBsZXQge1xuICAgIHRyYW5zZm9ybSxcbiAgICAuLi5hcmdzXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gbW9kaWZpZXJzICE9IG51bGwgJiYgbW9kaWZpZXJzLmxlbmd0aCA/IG1vZGlmaWVycy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBtb2RpZmllcikgPT4ge1xuICAgIHJldHVybiBtb2RpZmllcih7XG4gICAgICB0cmFuc2Zvcm06IGFjY3VtdWxhdG9yLFxuICAgICAgLi4uYXJnc1xuICAgIH0pO1xuICB9LCB0cmFuc2Zvcm0pIDogdHJhbnNmb3JtO1xufVxuXG5mdW5jdGlvbiB1c2VNZWFzdXJpbmdDb25maWd1cmF0aW9uKGNvbmZpZykge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiAoe1xuICAgIGRyYWdnYWJsZTogeyAuLi5kZWZhdWx0TWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnZ2FibGUsXG4gICAgICAuLi4oY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuZHJhZ2dhYmxlKVxuICAgIH0sXG4gICAgZHJvcHBhYmxlOiB7IC4uLmRlZmF1bHRNZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyb3BwYWJsZSxcbiAgICAgIC4uLihjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcm9wcGFibGUpXG4gICAgfSxcbiAgICBkcmFnT3ZlcmxheTogeyAuLi5kZWZhdWx0TWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnT3ZlcmxheSxcbiAgICAgIC4uLihjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcmFnT3ZlcmxheSlcbiAgICB9XG4gIH0pLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcmFnZ2FibGUsIGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmRyb3BwYWJsZSwgY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuZHJhZ092ZXJsYXldKTtcbn1cblxuZnVuY3Rpb24gdXNlTGF5b3V0U2hpZnRTY3JvbGxDb21wZW5zYXRpb24oX3JlZikge1xuICBsZXQge1xuICAgIGFjdGl2ZU5vZGUsXG4gICAgbWVhc3VyZSxcbiAgICBpbml0aWFsUmVjdCxcbiAgICBjb25maWcgPSB0cnVlXG4gIH0gPSBfcmVmO1xuICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IHR5cGVvZiBjb25maWcgPT09ICdib29sZWFuJyA/IHtcbiAgICB4OiBjb25maWcsXG4gICAgeTogY29uZmlnXG4gIH0gOiBjb25maWc7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGRpc2FibGVkID0gIXggJiYgIXk7XG5cbiAgICBpZiAoZGlzYWJsZWQgfHwgIWFjdGl2ZU5vZGUpIHtcbiAgICAgIGluaXRpYWxpemVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbGl6ZWQuY3VycmVudCB8fCAhaW5pdGlhbFJlY3QpIHtcbiAgICAgIC8vIFJldHVybiBlYXJseSBpZiBsYXlvdXQgc2hpZnQgc2Nyb2xsIGNvbXBlbnNhdGlvbiB3YXMgYWxyZWFkeSBhdHRlbXB0ZWRcbiAgICAgIC8vIG9yIGlmIHRoZXJlIGlzIG5vIGluaXRpYWxSZWN0IHRvIGNvbXBhcmUgdG8uXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBHZXQgdGhlIG1vc3QgdXAgdG8gZGF0ZSBub2RlIHJlZiBmb3IgdGhlIGFjdGl2ZSBkcmFnZ2FibGVcblxuXG4gICAgY29uc3Qgbm9kZSA9IGFjdGl2ZU5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZU5vZGUubm9kZS5jdXJyZW50O1xuXG4gICAgaWYgKCFub2RlIHx8IG5vZGUuaXNDb25uZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBSZXR1cm4gZWFybHkgaWYgdGhlcmUgaXMgbm8gYXR0YWNoZWQgbm9kZSByZWYgb3IgaWYgdGhlIG5vZGUgaXNcbiAgICAgIC8vIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZWN0ID0gbWVhc3VyZShub2RlKTtcbiAgICBjb25zdCByZWN0RGVsdGEgPSBnZXRSZWN0RGVsdGEocmVjdCwgaW5pdGlhbFJlY3QpO1xuXG4gICAgaWYgKCF4KSB7XG4gICAgICByZWN0RGVsdGEueCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCF5KSB7XG4gICAgICByZWN0RGVsdGEueSA9IDA7XG4gICAgfSAvLyBPbmx5IHBlcmZvcm0gbGF5b3V0IHNoaWZ0IHNjcm9sbCBjb21wZW5zYXRpb24gb25jZVxuXG5cbiAgICBpbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcblxuICAgIGlmIChNYXRoLmFicyhyZWN0RGVsdGEueCkgPiAwIHx8IE1hdGguYWJzKHJlY3REZWx0YS55KSA+IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yID0gZ2V0Rmlyc3RTY3JvbGxhYmxlQW5jZXN0b3Iobm9kZSk7XG5cbiAgICAgIGlmIChmaXJzdFNjcm9sbGFibGVBbmNlc3Rvcikge1xuICAgICAgICBmaXJzdFNjcm9sbGFibGVBbmNlc3Rvci5zY3JvbGxCeSh7XG4gICAgICAgICAgdG9wOiByZWN0RGVsdGEueSxcbiAgICAgICAgICBsZWZ0OiByZWN0RGVsdGEueFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFthY3RpdmVOb2RlLCB4LCB5LCBpbml0aWFsUmVjdCwgbWVhc3VyZV0pO1xufVxuXG5jb25zdCBBY3RpdmVEcmFnZ2FibGVDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoeyAuLi5kZWZhdWx0Q29vcmRpbmF0ZXMsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59KTtcbnZhciBTdGF0dXM7XG5cbihmdW5jdGlvbiAoU3RhdHVzKSB7XG4gIFN0YXR1c1tTdGF0dXNbXCJVbmluaXRpYWxpemVkXCJdID0gMF0gPSBcIlVuaW5pdGlhbGl6ZWRcIjtcbiAgU3RhdHVzW1N0YXR1c1tcIkluaXRpYWxpemluZ1wiXSA9IDFdID0gXCJJbml0aWFsaXppbmdcIjtcbiAgU3RhdHVzW1N0YXR1c1tcIkluaXRpYWxpemVkXCJdID0gMl0gPSBcIkluaXRpYWxpemVkXCI7XG59KShTdGF0dXMgfHwgKFN0YXR1cyA9IHt9KSk7XG5cbmNvbnN0IERuZENvbnRleHQgPSAvKiNfX1BVUkVfXyovbWVtbyhmdW5jdGlvbiBEbmRDb250ZXh0KF9yZWYpIHtcbiAgdmFyIF9zZW5zb3JDb250ZXh0JGN1cnJlbiwgX2RyYWdPdmVybGF5JG5vZGVSZWYkLCBfZHJhZ092ZXJsYXkkcmVjdCwgX292ZXIkcmVjdDtcblxuICBsZXQge1xuICAgIGlkLFxuICAgIGFjY2Vzc2liaWxpdHksXG4gICAgYXV0b1Njcm9sbCA9IHRydWUsXG4gICAgY2hpbGRyZW4sXG4gICAgc2Vuc29ycyA9IGRlZmF1bHRTZW5zb3JzLFxuICAgIGNvbGxpc2lvbkRldGVjdGlvbiA9IHJlY3RJbnRlcnNlY3Rpb24sXG4gICAgbWVhc3VyaW5nLFxuICAgIG1vZGlmaWVycyxcbiAgICAuLi5wcm9wc1xuICB9ID0gX3JlZjtcbiAgY29uc3Qgc3RvcmUgPSB1c2VSZWR1Y2VyKHJlZHVjZXIsIHVuZGVmaW5lZCwgZ2V0SW5pdGlhbFN0YXRlKTtcbiAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSBzdG9yZTtcbiAgY29uc3QgW2Rpc3BhdGNoTW9uaXRvckV2ZW50LCByZWdpc3Rlck1vbml0b3JMaXN0ZW5lcl0gPSB1c2VEbmRNb25pdG9yUHJvdmlkZXIoKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlKFN0YXR1cy5VbmluaXRpYWxpemVkKTtcbiAgY29uc3QgaXNJbml0aWFsaXplZCA9IHN0YXR1cyA9PT0gU3RhdHVzLkluaXRpYWxpemVkO1xuICBjb25zdCB7XG4gICAgZHJhZ2dhYmxlOiB7XG4gICAgICBhY3RpdmU6IGFjdGl2ZUlkLFxuICAgICAgbm9kZXM6IGRyYWdnYWJsZU5vZGVzLFxuICAgICAgdHJhbnNsYXRlXG4gICAgfSxcbiAgICBkcm9wcGFibGU6IHtcbiAgICAgIGNvbnRhaW5lcnM6IGRyb3BwYWJsZUNvbnRhaW5lcnNcbiAgICB9XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3Qgbm9kZSA9IGFjdGl2ZUlkID8gZHJhZ2dhYmxlTm9kZXMuZ2V0KGFjdGl2ZUlkKSA6IG51bGw7XG4gIGNvbnN0IGFjdGl2ZVJlY3RzID0gdXNlUmVmKHtcbiAgICBpbml0aWFsOiBudWxsLFxuICAgIHRyYW5zbGF0ZWQ6IG51bGxcbiAgfSk7XG4gIGNvbnN0IGFjdGl2ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHZhciBfbm9kZSRkYXRhO1xuXG4gICAgcmV0dXJuIGFjdGl2ZUlkICE9IG51bGwgPyB7XG4gICAgICBpZDogYWN0aXZlSWQsXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIGZvciB0aGUgYWN0aXZlIG5vZGUgdG8gdW5tb3VudCB3aGlsZSBkcmFnZ2luZ1xuICAgICAgZGF0YTogKF9ub2RlJGRhdGEgPSBub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLmRhdGEpICE9IG51bGwgPyBfbm9kZSRkYXRhIDogZGVmYXVsdERhdGEsXG4gICAgICByZWN0OiBhY3RpdmVSZWN0c1xuICAgIH0gOiBudWxsO1xuICB9LCBbYWN0aXZlSWQsIG5vZGVdKTtcbiAgY29uc3QgYWN0aXZlUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbYWN0aXZlU2Vuc29yLCBzZXRBY3RpdmVTZW5zb3JdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFthY3RpdmF0b3JFdmVudCwgc2V0QWN0aXZhdG9yRXZlbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGxhdGVzdFByb3BzID0gdXNlTGF0ZXN0VmFsdWUocHJvcHMsIE9iamVjdC52YWx1ZXMocHJvcHMpKTtcbiAgY29uc3QgZHJhZ2dhYmxlRGVzY3JpYmVkQnlJZCA9IHVzZVVuaXF1ZUlkKFwiRG5kRGVzY3JpYmVkQnlcIiwgaWQpO1xuICBjb25zdCBlbmFibGVkRHJvcHBhYmxlQ29udGFpbmVycyA9IHVzZU1lbW8oKCkgPT4gZHJvcHBhYmxlQ29udGFpbmVycy5nZXRFbmFibGVkKCksIFtkcm9wcGFibGVDb250YWluZXJzXSk7XG4gIGNvbnN0IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24gPSB1c2VNZWFzdXJpbmdDb25maWd1cmF0aW9uKG1lYXN1cmluZyk7XG4gIGNvbnN0IHtcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICBtZWFzdXJpbmdTY2hlZHVsZWRcbiAgfSA9IHVzZURyb3BwYWJsZU1lYXN1cmluZyhlbmFibGVkRHJvcHBhYmxlQ29udGFpbmVycywge1xuICAgIGRyYWdnaW5nOiBpc0luaXRpYWxpemVkLFxuICAgIGRlcGVuZGVuY2llczogW3RyYW5zbGF0ZS54LCB0cmFuc2xhdGUueV0sXG4gICAgY29uZmlnOiBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyb3BwYWJsZVxuICB9KTtcbiAgY29uc3QgYWN0aXZlTm9kZSA9IHVzZUNhY2hlZE5vZGUoZHJhZ2dhYmxlTm9kZXMsIGFjdGl2ZUlkKTtcbiAgY29uc3QgYWN0aXZhdGlvbkNvb3JkaW5hdGVzID0gdXNlTWVtbygoKSA9PiBhY3RpdmF0b3JFdmVudCA/IGdldEV2ZW50Q29vcmRpbmF0ZXMoYWN0aXZhdG9yRXZlbnQpIDogbnVsbCwgW2FjdGl2YXRvckV2ZW50XSk7XG4gIGNvbnN0IGF1dG9TY3JvbGxPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICBjb25zdCBpbml0aWFsQWN0aXZlTm9kZVJlY3QgPSB1c2VJbml0aWFsUmVjdChhY3RpdmVOb2RlLCBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdnYWJsZS5tZWFzdXJlKTtcbiAgdXNlTGF5b3V0U2hpZnRTY3JvbGxDb21wZW5zYXRpb24oe1xuICAgIGFjdGl2ZU5vZGU6IGFjdGl2ZUlkID8gZHJhZ2dhYmxlTm9kZXMuZ2V0KGFjdGl2ZUlkKSA6IG51bGwsXG4gICAgY29uZmlnOiBhdXRvU2Nyb2xsT3B0aW9ucy5sYXlvdXRTaGlmdENvbXBlbnNhdGlvbixcbiAgICBpbml0aWFsUmVjdDogaW5pdGlhbEFjdGl2ZU5vZGVSZWN0LFxuICAgIG1lYXN1cmU6IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ2dhYmxlLm1lYXN1cmVcbiAgfSk7XG4gIGNvbnN0IGFjdGl2ZU5vZGVSZWN0ID0gdXNlUmVjdChhY3RpdmVOb2RlLCBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdnYWJsZS5tZWFzdXJlLCBpbml0aWFsQWN0aXZlTm9kZVJlY3QpO1xuICBjb25zdCBjb250YWluZXJOb2RlUmVjdCA9IHVzZVJlY3QoYWN0aXZlTm9kZSA/IGFjdGl2ZU5vZGUucGFyZW50RWxlbWVudCA6IG51bGwpO1xuICBjb25zdCBzZW5zb3JDb250ZXh0ID0gdXNlUmVmKHtcbiAgICBhY3RpdmF0b3JFdmVudDogbnVsbCxcbiAgICBhY3RpdmU6IG51bGwsXG4gICAgYWN0aXZlTm9kZSxcbiAgICBjb2xsaXNpb25SZWN0OiBudWxsLFxuICAgIGNvbGxpc2lvbnM6IG51bGwsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgZHJhZ2dhYmxlTm9kZXMsXG4gICAgZHJhZ2dpbmdOb2RlOiBudWxsLFxuICAgIGRyYWdnaW5nTm9kZVJlY3Q6IG51bGwsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICBvdmVyOiBudWxsLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnM6IFtdLFxuICAgIHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlOiBudWxsXG4gIH0pO1xuICBjb25zdCBvdmVyTm9kZSA9IGRyb3BwYWJsZUNvbnRhaW5lcnMuZ2V0Tm9kZUZvcigoX3NlbnNvckNvbnRleHQkY3VycmVuID0gc2Vuc29yQ29udGV4dC5jdXJyZW50Lm92ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfc2Vuc29yQ29udGV4dCRjdXJyZW4uaWQpO1xuICBjb25zdCBkcmFnT3ZlcmxheSA9IHVzZURyYWdPdmVybGF5TWVhc3VyaW5nKHtcbiAgICBtZWFzdXJlOiBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdPdmVybGF5Lm1lYXN1cmVcbiAgfSk7IC8vIFVzZSB0aGUgcmVjdCBvZiB0aGUgZHJhZyBvdmVybGF5IGlmIGl0IGlzIG1vdW50ZWRcblxuICBjb25zdCBkcmFnZ2luZ05vZGUgPSAoX2RyYWdPdmVybGF5JG5vZGVSZWYkID0gZHJhZ092ZXJsYXkubm9kZVJlZi5jdXJyZW50KSAhPSBudWxsID8gX2RyYWdPdmVybGF5JG5vZGVSZWYkIDogYWN0aXZlTm9kZTtcbiAgY29uc3QgZHJhZ2dpbmdOb2RlUmVjdCA9IGlzSW5pdGlhbGl6ZWQgPyAoX2RyYWdPdmVybGF5JHJlY3QgPSBkcmFnT3ZlcmxheS5yZWN0KSAhPSBudWxsID8gX2RyYWdPdmVybGF5JHJlY3QgOiBhY3RpdmVOb2RlUmVjdCA6IG51bGw7XG4gIGNvbnN0IHVzZXNEcmFnT3ZlcmxheSA9IEJvb2xlYW4oZHJhZ092ZXJsYXkubm9kZVJlZi5jdXJyZW50ICYmIGRyYWdPdmVybGF5LnJlY3QpOyAvLyBUaGUgZGVsdGEgYmV0d2VlbiB0aGUgcHJldmlvdXMgYW5kIG5ldyBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dhYmxlIG5vZGVcbiAgLy8gaXMgb25seSByZWxldmFudCB3aGVuIHRoZXJlIGlzIG5vIGRyYWcgb3ZlcmxheVxuXG4gIGNvbnN0IG5vZGVSZWN0RGVsdGEgPSB1c2VSZWN0RGVsdGEodXNlc0RyYWdPdmVybGF5ID8gbnVsbCA6IGFjdGl2ZU5vZGVSZWN0KTsgLy8gR2V0IHRoZSB3aW5kb3cgcmVjdCBvZiB0aGUgZHJhZ2dpbmcgbm9kZVxuXG4gIGNvbnN0IHdpbmRvd1JlY3QgPSB1c2VXaW5kb3dSZWN0KGRyYWdnaW5nTm9kZSA/IGdldFdpbmRvdyhkcmFnZ2luZ05vZGUpIDogbnVsbCk7IC8vIEdldCBzY3JvbGxhYmxlIGFuY2VzdG9ycyBvZiB0aGUgZHJhZ2dpbmcgbm9kZVxuXG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvcnMgPSB1c2VTY3JvbGxhYmxlQW5jZXN0b3JzKGlzSW5pdGlhbGl6ZWQgPyBvdmVyTm9kZSAhPSBudWxsID8gb3Zlck5vZGUgOiBhY3RpdmVOb2RlIDogbnVsbCk7XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvclJlY3RzID0gdXNlUmVjdHMoc2Nyb2xsYWJsZUFuY2VzdG9ycyk7IC8vIEFwcGx5IG1vZGlmaWVyc1xuXG4gIGNvbnN0IG1vZGlmaWVkVHJhbnNsYXRlID0gYXBwbHlNb2RpZmllcnMobW9kaWZpZXJzLCB7XG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICB4OiB0cmFuc2xhdGUueCAtIG5vZGVSZWN0RGVsdGEueCxcbiAgICAgIHk6IHRyYW5zbGF0ZS55IC0gbm9kZVJlY3REZWx0YS55LFxuICAgICAgc2NhbGVYOiAxLFxuICAgICAgc2NhbGVZOiAxXG4gICAgfSxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmUsXG4gICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgY29udGFpbmVyTm9kZVJlY3QsXG4gICAgZHJhZ2dpbmdOb2RlUmVjdCxcbiAgICBvdmVyOiBzZW5zb3JDb250ZXh0LmN1cnJlbnQub3ZlcixcbiAgICBvdmVybGF5Tm9kZVJlY3Q6IGRyYWdPdmVybGF5LnJlY3QsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cyxcbiAgICB3aW5kb3dSZWN0XG4gIH0pO1xuICBjb25zdCBwb2ludGVyQ29vcmRpbmF0ZXMgPSBhY3RpdmF0aW9uQ29vcmRpbmF0ZXMgPyBhZGQoYWN0aXZhdGlvbkNvb3JkaW5hdGVzLCB0cmFuc2xhdGUpIDogbnVsbDtcbiAgY29uc3Qgc2Nyb2xsT2Zmc2V0cyA9IHVzZVNjcm9sbE9mZnNldHMoc2Nyb2xsYWJsZUFuY2VzdG9ycyk7IC8vIFJlcHJlc2VudHMgdGhlIHNjcm9sbCBkZWx0YSBzaW5jZSBkcmFnZ2luZyB3YXMgaW5pdGlhdGVkXG5cbiAgY29uc3Qgc2Nyb2xsQWRqdXN0bWVudCA9IHVzZVNjcm9sbE9mZnNldHNEZWx0YShzY3JvbGxPZmZzZXRzKTsgLy8gUmVwcmVzZW50cyB0aGUgc2Nyb2xsIGRlbHRhIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGFjdGl2ZSBub2RlIHJlY3Qgd2FzIG1lYXN1cmVkXG5cbiAgY29uc3QgYWN0aXZlTm9kZVNjcm9sbERlbHRhID0gdXNlU2Nyb2xsT2Zmc2V0c0RlbHRhKHNjcm9sbE9mZnNldHMsIFthY3RpdmVOb2RlUmVjdF0pO1xuICBjb25zdCBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZSA9IGFkZChtb2RpZmllZFRyYW5zbGF0ZSwgc2Nyb2xsQWRqdXN0bWVudCk7XG4gIGNvbnN0IGNvbGxpc2lvblJlY3QgPSBkcmFnZ2luZ05vZGVSZWN0ID8gZ2V0QWRqdXN0ZWRSZWN0KGRyYWdnaW5nTm9kZVJlY3QsIG1vZGlmaWVkVHJhbnNsYXRlKSA6IG51bGw7XG4gIGNvbnN0IGNvbGxpc2lvbnMgPSBhY3RpdmUgJiYgY29sbGlzaW9uUmVjdCA/IGNvbGxpc2lvbkRldGVjdGlvbih7XG4gICAgYWN0aXZlLFxuICAgIGNvbGxpc2lvblJlY3QsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVyczogZW5hYmxlZERyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgcG9pbnRlckNvb3JkaW5hdGVzXG4gIH0pIDogbnVsbDtcbiAgY29uc3Qgb3ZlcklkID0gZ2V0Rmlyc3RDb2xsaXNpb24oY29sbGlzaW9ucywgJ2lkJyk7XG4gIGNvbnN0IFtvdmVyLCBzZXRPdmVyXSA9IHVzZVN0YXRlKG51bGwpOyAvLyBXaGVuIHRoZXJlIGlzIG5vIGRyYWcgb3ZlcmxheSB1c2VkLCB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoZVxuICAvLyB3aW5kb3cgc2Nyb2xsIGRlbHRhXG5cbiAgY29uc3QgYXBwbGllZFRyYW5zbGF0ZSA9IHVzZXNEcmFnT3ZlcmxheSA/IG1vZGlmaWVkVHJhbnNsYXRlIDogYWRkKG1vZGlmaWVkVHJhbnNsYXRlLCBhY3RpdmVOb2RlU2Nyb2xsRGVsdGEpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSBhZGp1c3RTY2FsZShhcHBsaWVkVHJhbnNsYXRlLCAoX292ZXIkcmVjdCA9IG92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXIucmVjdCkgIT0gbnVsbCA/IF9vdmVyJHJlY3QgOiBudWxsLCBhY3RpdmVOb2RlUmVjdCk7XG4gIGNvbnN0IGluc3RhbnRpYXRlU2Vuc29yID0gdXNlQ2FsbGJhY2soKGV2ZW50LCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBzZW5zb3I6IFNlbnNvcixcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gX3JlZjI7XG5cbiAgICBpZiAoYWN0aXZlUmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZU5vZGUgPSBkcmFnZ2FibGVOb2Rlcy5nZXQoYWN0aXZlUmVmLmN1cnJlbnQpO1xuXG4gICAgaWYgKCFhY3RpdmVOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZhdG9yRXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICBjb25zdCBzZW5zb3JJbnN0YW5jZSA9IG5ldyBTZW5zb3Ioe1xuICAgICAgYWN0aXZlOiBhY3RpdmVSZWYuY3VycmVudCxcbiAgICAgIGFjdGl2ZU5vZGUsXG4gICAgICBldmVudDogYWN0aXZhdG9yRXZlbnQsXG4gICAgICBvcHRpb25zLFxuICAgICAgLy8gU2Vuc29ycyBuZWVkIHRvIGJlIGluc3RhbnRpYXRlZCB3aXRoIHJlZnMgZm9yIGFyZ3VtZW50cyB0aGF0IGNoYW5nZSBvdmVyIHRpbWVcbiAgICAgIC8vIG90aGVyd2lzZSB0aGV5IGFyZSBmcm96ZW4gaW4gdGltZSB3aXRoIHRoZSBzdGFsZSBhcmd1bWVudHNcbiAgICAgIGNvbnRleHQ6IHNlbnNvckNvbnRleHQsXG5cbiAgICAgIG9uU3RhcnQoaW5pdGlhbENvb3JkaW5hdGVzKSB7XG4gICAgICAgIGNvbnN0IGlkID0gYWN0aXZlUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkcmFnZ2FibGVOb2RlID0gZHJhZ2dhYmxlTm9kZXMuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWRyYWdnYWJsZU5vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgb25EcmFnU3RhcnRcbiAgICAgICAgfSA9IGxhdGVzdFByb3BzLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBkcmFnZ2FibGVOb2RlLmRhdGEsXG4gICAgICAgICAgICByZWN0OiBhY3RpdmVSZWN0c1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIG9uRHJhZ1N0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkRyYWdTdGFydChldmVudCk7XG4gICAgICAgICAgc2V0U3RhdHVzKFN0YXR1cy5Jbml0aWFsaXppbmcpO1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IEFjdGlvbi5EcmFnU3RhcnQsXG4gICAgICAgICAgICBpbml0aWFsQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgICBhY3RpdmU6IGlkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGlzcGF0Y2hNb25pdG9yRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ29uRHJhZ1N0YXJ0JyxcbiAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgb25Nb3ZlKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBBY3Rpb24uRHJhZ01vdmUsXG4gICAgICAgICAgY29vcmRpbmF0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBvbkVuZDogY3JlYXRlSGFuZGxlcihBY3Rpb24uRHJhZ0VuZCksXG4gICAgICBvbkNhbmNlbDogY3JlYXRlSGFuZGxlcihBY3Rpb24uRHJhZ0NhbmNlbClcbiAgICB9KTtcbiAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICBzZXRBY3RpdmVTZW5zb3Ioc2Vuc29ySW5zdGFuY2UpO1xuICAgICAgc2V0QWN0aXZhdG9yRXZlbnQoZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlSGFuZGxlcih0eXBlKSB7XG4gICAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFjdGl2ZSxcbiAgICAgICAgICBjb2xsaXNpb25zLFxuICAgICAgICAgIG92ZXIsXG4gICAgICAgICAgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGVcbiAgICAgICAgfSA9IHNlbnNvckNvbnRleHQuY3VycmVudDtcbiAgICAgICAgbGV0IGV2ZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAoYWN0aXZlICYmIHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY2FuY2VsRHJvcFxuICAgICAgICAgIH0gPSBsYXRlc3RQcm9wcy5jdXJyZW50O1xuICAgICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcbiAgICAgICAgICAgIGNvbGxpc2lvbnMsXG4gICAgICAgICAgICBkZWx0YTogc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUsXG4gICAgICAgICAgICBvdmVyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0eXBlID09PSBBY3Rpb24uRHJhZ0VuZCAmJiB0eXBlb2YgY2FuY2VsRHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkQ2FuY2VsID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGNhbmNlbERyb3AoZXZlbnQpKTtcblxuICAgICAgICAgICAgaWYgKHNob3VsZENhbmNlbCkge1xuICAgICAgICAgICAgICB0eXBlID0gQWN0aW9uLkRyYWdDYW5jZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWN0aXZlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldFN0YXR1cyhTdGF0dXMuVW5pbml0aWFsaXplZCk7XG4gICAgICAgICAgc2V0T3ZlcihudWxsKTtcbiAgICAgICAgICBzZXRBY3RpdmVTZW5zb3IobnVsbCk7XG4gICAgICAgICAgc2V0QWN0aXZhdG9yRXZlbnQobnVsbCk7XG4gICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gdHlwZSA9PT0gQWN0aW9uLkRyYWdFbmQgPyAnb25EcmFnRW5kJyA6ICdvbkRyYWdDYW5jZWwnO1xuXG4gICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gbGF0ZXN0UHJvcHMuY3VycmVudFtldmVudE5hbWVdO1xuICAgICAgICAgICAgaGFuZGxlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICBkaXNwYXRjaE1vbml0b3JFdmVudCh7XG4gICAgICAgICAgICAgIHR5cGU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbZHJhZ2dhYmxlTm9kZXNdKTtcbiAgY29uc3QgYmluZEFjdGl2YXRvclRvU2Vuc29ySW5zdGFudGlhdG9yID0gdXNlQ2FsbGJhY2soKGhhbmRsZXIsIHNlbnNvcikgPT4ge1xuICAgIHJldHVybiAoZXZlbnQsIGFjdGl2ZSkgPT4ge1xuICAgICAgY29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICAgIGNvbnN0IGFjdGl2ZURyYWdnYWJsZU5vZGUgPSBkcmFnZ2FibGVOb2Rlcy5nZXQoYWN0aXZlKTtcblxuICAgICAgaWYgKCAvLyBBbm90aGVyIHNlbnNvciBpcyBhbHJlYWR5IGluc3RhbnRpYXRpbmdcbiAgICAgIGFjdGl2ZVJlZi5jdXJyZW50ICE9PSBudWxsIHx8IC8vIE5vIGFjdGl2ZSBkcmFnZ2FibGVcbiAgICAgICFhY3RpdmVEcmFnZ2FibGVOb2RlIHx8IC8vIEV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWRcbiAgICAgIG5hdGl2ZUV2ZW50LmRuZEtpdCB8fCBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0aXZhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGFjdGl2ZTogYWN0aXZlRHJhZ2dhYmxlTm9kZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNob3VsZEFjdGl2YXRlID0gaGFuZGxlcihldmVudCwgc2Vuc29yLm9wdGlvbnMsIGFjdGl2YXRpb25Db250ZXh0KTtcblxuICAgICAgaWYgKHNob3VsZEFjdGl2YXRlID09PSB0cnVlKSB7XG4gICAgICAgIG5hdGl2ZUV2ZW50LmRuZEtpdCA9IHtcbiAgICAgICAgICBjYXB0dXJlZEJ5OiBzZW5zb3Iuc2Vuc29yXG4gICAgICAgIH07XG4gICAgICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gYWN0aXZlO1xuICAgICAgICBpbnN0YW50aWF0ZVNlbnNvcihldmVudCwgc2Vuc29yKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZHJhZ2dhYmxlTm9kZXMsIGluc3RhbnRpYXRlU2Vuc29yXSk7XG4gIGNvbnN0IGFjdGl2YXRvcnMgPSB1c2VDb21iaW5lQWN0aXZhdG9ycyhzZW5zb3JzLCBiaW5kQWN0aXZhdG9yVG9TZW5zb3JJbnN0YW50aWF0b3IpO1xuICB1c2VTZW5zb3JTZXR1cChzZW5zb3JzKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGFjdGl2ZU5vZGVSZWN0ICYmIHN0YXR1cyA9PT0gU3RhdHVzLkluaXRpYWxpemluZykge1xuICAgICAgc2V0U3RhdHVzKFN0YXR1cy5Jbml0aWFsaXplZCk7XG4gICAgfVxuICB9LCBbYWN0aXZlTm9kZVJlY3QsIHN0YXR1c10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uRHJhZ01vdmVcbiAgICB9ID0gbGF0ZXN0UHJvcHMuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmUsXG4gICAgICBhY3RpdmF0b3JFdmVudCxcbiAgICAgIGNvbGxpc2lvbnMsXG4gICAgICBvdmVyXG4gICAgfSA9IHNlbnNvckNvbnRleHQuY3VycmVudDtcblxuICAgIGlmICghYWN0aXZlIHx8ICFhY3RpdmF0b3JFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBjb2xsaXNpb25zLFxuICAgICAgZGVsdGE6IHtcbiAgICAgICAgeDogc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueCxcbiAgICAgICAgeTogc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueVxuICAgICAgfSxcbiAgICAgIG92ZXJcbiAgICB9O1xuICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgIG9uRHJhZ01vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRHJhZ01vdmUoZXZlbnQpO1xuICAgICAgZGlzcGF0Y2hNb25pdG9yRXZlbnQoe1xuICAgICAgICB0eXBlOiAnb25EcmFnTW92ZScsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueCwgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGFjdGl2YXRvckV2ZW50LFxuICAgICAgY29sbGlzaW9ucyxcbiAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgICBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZVxuICAgIH0gPSBzZW5zb3JDb250ZXh0LmN1cnJlbnQ7XG5cbiAgICBpZiAoIWFjdGl2ZSB8fCBhY3RpdmVSZWYuY3VycmVudCA9PSBudWxsIHx8ICFhY3RpdmF0b3JFdmVudCB8fCAhc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBvbkRyYWdPdmVyXG4gICAgfSA9IGxhdGVzdFByb3BzLmN1cnJlbnQ7XG4gICAgY29uc3Qgb3ZlckNvbnRhaW5lciA9IGRyb3BwYWJsZUNvbnRhaW5lcnMuZ2V0KG92ZXJJZCk7XG4gICAgY29uc3Qgb3ZlciA9IG92ZXJDb250YWluZXIgJiYgb3ZlckNvbnRhaW5lci5yZWN0LmN1cnJlbnQgPyB7XG4gICAgICBpZDogb3ZlckNvbnRhaW5lci5pZCxcbiAgICAgIHJlY3Q6IG92ZXJDb250YWluZXIucmVjdC5jdXJyZW50LFxuICAgICAgZGF0YTogb3ZlckNvbnRhaW5lci5kYXRhLFxuICAgICAgZGlzYWJsZWQ6IG92ZXJDb250YWluZXIuZGlzYWJsZWRcbiAgICB9IDogbnVsbDtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGFjdGl2YXRvckV2ZW50LFxuICAgICAgY29sbGlzaW9ucyxcbiAgICAgIGRlbHRhOiB7XG4gICAgICAgIHg6IHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlLngsXG4gICAgICAgIHk6IHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlLnlcbiAgICAgIH0sXG4gICAgICBvdmVyXG4gICAgfTtcbiAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICBzZXRPdmVyKG92ZXIpO1xuICAgICAgb25EcmFnT3ZlciA9PSBudWxsID8gdm9pZCAwIDogb25EcmFnT3ZlcihldmVudCk7XG4gICAgICBkaXNwYXRjaE1vbml0b3JFdmVudCh7XG4gICAgICAgIHR5cGU6ICdvbkRyYWdPdmVyJyxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtvdmVySWRdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2Vuc29yQ29udGV4dC5jdXJyZW50ID0ge1xuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBhY3RpdmUsXG4gICAgICBhY3RpdmVOb2RlLFxuICAgICAgY29sbGlzaW9uUmVjdCxcbiAgICAgIGNvbGxpc2lvbnMsXG4gICAgICBkcm9wcGFibGVSZWN0cyxcbiAgICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgICAgZHJhZ2dpbmdOb2RlLFxuICAgICAgZHJhZ2dpbmdOb2RlUmVjdCxcbiAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgICBvdmVyLFxuICAgICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICAgIHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlXG4gICAgfTtcbiAgICBhY3RpdmVSZWN0cy5jdXJyZW50ID0ge1xuICAgICAgaW5pdGlhbDogZHJhZ2dpbmdOb2RlUmVjdCxcbiAgICAgIHRyYW5zbGF0ZWQ6IGNvbGxpc2lvblJlY3RcbiAgICB9O1xuICB9LCBbYWN0aXZlLCBhY3RpdmVOb2RlLCBjb2xsaXNpb25zLCBjb2xsaXNpb25SZWN0LCBkcmFnZ2FibGVOb2RlcywgZHJhZ2dpbmdOb2RlLCBkcmFnZ2luZ05vZGVSZWN0LCBkcm9wcGFibGVSZWN0cywgZHJvcHBhYmxlQ29udGFpbmVycywgb3Zlciwgc2Nyb2xsYWJsZUFuY2VzdG9ycywgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGVdKTtcbiAgdXNlQXV0b1Njcm9sbGVyKHsgLi4uYXV0b1Njcm9sbE9wdGlvbnMsXG4gICAgZGVsdGE6IHRyYW5zbGF0ZSxcbiAgICBkcmFnZ2luZ1JlY3Q6IGNvbGxpc2lvblJlY3QsXG4gICAgcG9pbnRlckNvb3JkaW5hdGVzLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHNcbiAgfSk7XG4gIGNvbnN0IHB1YmxpY0NvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZlTm9kZSxcbiAgICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBjb2xsaXNpb25zLFxuICAgICAgY29udGFpbmVyTm9kZVJlY3QsXG4gICAgICBkcmFnT3ZlcmxheSxcbiAgICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgICAgb3ZlcixcbiAgICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzLFxuICAgICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICAgIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzLFxuICAgICAgbWVhc3VyaW5nQ29uZmlndXJhdGlvbixcbiAgICAgIG1lYXN1cmluZ1NjaGVkdWxlZCxcbiAgICAgIHdpbmRvd1JlY3RcbiAgICB9O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9LCBbYWN0aXZlLCBhY3RpdmVOb2RlLCBhY3RpdmVOb2RlUmVjdCwgYWN0aXZhdG9yRXZlbnQsIGNvbGxpc2lvbnMsIGNvbnRhaW5lck5vZGVSZWN0LCBkcmFnT3ZlcmxheSwgZHJhZ2dhYmxlTm9kZXMsIGRyb3BwYWJsZUNvbnRhaW5lcnMsIGRyb3BwYWJsZVJlY3RzLCBvdmVyLCBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycywgc2Nyb2xsYWJsZUFuY2VzdG9ycywgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24sIG1lYXN1cmluZ1NjaGVkdWxlZCwgd2luZG93UmVjdF0pO1xuICBjb25zdCBpbnRlcm5hbENvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBhY3RpdmF0b3JzLFxuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgICBhcmlhRGVzY3JpYmVkQnlJZDoge1xuICAgICAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZURlc2NyaWJlZEJ5SWRcbiAgICAgIH0sXG4gICAgICBkaXNwYXRjaCxcbiAgICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgICAgb3ZlcixcbiAgICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzXG4gICAgfTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfSwgW2FjdGl2YXRvckV2ZW50LCBhY3RpdmF0b3JzLCBhY3RpdmUsIGFjdGl2ZU5vZGVSZWN0LCBkaXNwYXRjaCwgZHJhZ2dhYmxlRGVzY3JpYmVkQnlJZCwgZHJhZ2dhYmxlTm9kZXMsIG92ZXIsIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERuZE1vbml0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJlZ2lzdGVyTW9uaXRvckxpc3RlbmVyXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW50ZXJuYWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGludGVybmFsQ29udGV4dFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFB1YmxpY0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcHVibGljQ29udGV4dFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEFjdGl2ZURyYWdnYWJsZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJhbnNmb3JtXG4gIH0sIGNoaWxkcmVuKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzdG9yZUZvY3VzLCB7XG4gICAgZGlzYWJsZWQ6IChhY2Nlc3NpYmlsaXR5ID09IG51bGwgPyB2b2lkIDAgOiBhY2Nlc3NpYmlsaXR5LnJlc3RvcmVGb2N1cykgPT09IGZhbHNlXG4gIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChBY2Nlc3NpYmlsaXR5LCB7IC4uLmFjY2Vzc2liaWxpdHksXG4gICAgaGlkZGVuVGV4dERlc2NyaWJlZEJ5SWQ6IGRyYWdnYWJsZURlc2NyaWJlZEJ5SWRcbiAgfSkpO1xuXG4gIGZ1bmN0aW9uIGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKSB7XG4gICAgY29uc3QgYWN0aXZlU2Vuc29yRGlzYWJsZXNBdXRvc2Nyb2xsID0gKGFjdGl2ZVNlbnNvciA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlU2Vuc29yLmF1dG9TY3JvbGxFbmFibGVkKSA9PT0gZmFsc2U7XG4gICAgY29uc3QgYXV0b1Njcm9sbEdsb2JhbGx5RGlzYWJsZWQgPSB0eXBlb2YgYXV0b1Njcm9sbCA9PT0gJ29iamVjdCcgPyBhdXRvU2Nyb2xsLmVuYWJsZWQgPT09IGZhbHNlIDogYXV0b1Njcm9sbCA9PT0gZmFsc2U7XG4gICAgY29uc3QgZW5hYmxlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgIWFjdGl2ZVNlbnNvckRpc2FibGVzQXV0b3Njcm9sbCAmJiAhYXV0b1Njcm9sbEdsb2JhbGx5RGlzYWJsZWQ7XG5cbiAgICBpZiAodHlwZW9mIGF1dG9TY3JvbGwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4geyAuLi5hdXRvU2Nyb2xsLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbmFibGVkXG4gICAgfTtcbiAgfVxufSk7XG5cbmNvbnN0IE51bGxDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBkZWZhdWx0Um9sZSA9ICdidXR0b24nO1xuY29uc3QgSURfUFJFRklYID0gJ0Ryb3BwYWJsZSc7XG5mdW5jdGlvbiB1c2VEcmFnZ2FibGUoX3JlZikge1xuICBsZXQge1xuICAgIGlkLFxuICAgIGRhdGEsXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBhdHRyaWJ1dGVzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBrZXkgPSB1c2VVbmlxdWVJZChJRF9QUkVGSVgpO1xuICBjb25zdCB7XG4gICAgYWN0aXZhdG9ycyxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmUsXG4gICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgYXJpYURlc2NyaWJlZEJ5SWQsXG4gICAgZHJhZ2dhYmxlTm9kZXMsXG4gICAgb3ZlclxuICB9ID0gdXNlQ29udGV4dChJbnRlcm5hbENvbnRleHQpO1xuICBjb25zdCB7XG4gICAgcm9sZSA9IGRlZmF1bHRSb2xlLFxuICAgIHJvbGVEZXNjcmlwdGlvbiA9ICdkcmFnZ2FibGUnLFxuICAgIHRhYkluZGV4ID0gMFxuICB9ID0gYXR0cmlidXRlcyAhPSBudWxsID8gYXR0cmlidXRlcyA6IHt9O1xuICBjb25zdCBpc0RyYWdnaW5nID0gKGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLmlkKSA9PT0gaWQ7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IHVzZUNvbnRleHQoaXNEcmFnZ2luZyA/IEFjdGl2ZURyYWdnYWJsZUNvbnRleHQgOiBOdWxsQ29udGV4dCk7XG4gIGNvbnN0IFtub2RlLCBzZXROb2RlUmVmXSA9IHVzZU5vZGVSZWYoKTtcbiAgY29uc3QgW2FjdGl2YXRvck5vZGUsIHNldEFjdGl2YXRvck5vZGVSZWZdID0gdXNlTm9kZVJlZigpO1xuICBjb25zdCBsaXN0ZW5lcnMgPSB1c2VTeW50aGV0aWNMaXN0ZW5lcnMoYWN0aXZhdG9ycywgaWQpO1xuICBjb25zdCBkYXRhUmVmID0gdXNlTGF0ZXN0VmFsdWUoZGF0YSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGRyYWdnYWJsZU5vZGVzLnNldChpZCwge1xuICAgICAgaWQsXG4gICAgICBrZXksXG4gICAgICBub2RlLFxuICAgICAgYWN0aXZhdG9yTm9kZSxcbiAgICAgIGRhdGE6IGRhdGFSZWZcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IGRyYWdnYWJsZU5vZGVzLmdldChpZCk7XG5cbiAgICAgIGlmIChub2RlICYmIG5vZGUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgZHJhZ2dhYmxlTm9kZXMuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtkcmFnZ2FibGVOb2RlcywgaWRdKTtcbiAgY29uc3QgbWVtb2l6ZWRBdHRyaWJ1dGVzID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHJvbGUsXG4gICAgdGFiSW5kZXgsXG4gICAgJ2FyaWEtZGlzYWJsZWQnOiBkaXNhYmxlZCxcbiAgICAnYXJpYS1wcmVzc2VkJzogaXNEcmFnZ2luZyAmJiByb2xlID09PSBkZWZhdWx0Um9sZSA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogcm9sZURlc2NyaXB0aW9uLFxuICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogYXJpYURlc2NyaWJlZEJ5SWQuZHJhZ2dhYmxlXG4gIH0pLCBbZGlzYWJsZWQsIHJvbGUsIHRhYkluZGV4LCBpc0RyYWdnaW5nLCByb2xlRGVzY3JpcHRpb24sIGFyaWFEZXNjcmliZWRCeUlkLmRyYWdnYWJsZV0pO1xuICByZXR1cm4ge1xuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICBhdHRyaWJ1dGVzOiBtZW1vaXplZEF0dHJpYnV0ZXMsXG4gICAgaXNEcmFnZ2luZyxcbiAgICBsaXN0ZW5lcnM6IGRpc2FibGVkID8gdW5kZWZpbmVkIDogbGlzdGVuZXJzLFxuICAgIG5vZGUsXG4gICAgb3ZlcixcbiAgICBzZXROb2RlUmVmLFxuICAgIHNldEFjdGl2YXRvck5vZGVSZWYsXG4gICAgdHJhbnNmb3JtXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURuZENvbnRleHQoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KFB1YmxpY0NvbnRleHQpO1xufVxuXG5jb25zdCBJRF9QUkVGSVgkMSA9ICdEcm9wcGFibGUnO1xuY29uc3QgZGVmYXVsdFJlc2l6ZU9ic2VydmVyQ29uZmlnID0ge1xuICB0aW1lb3V0OiAyNVxufTtcbmZ1bmN0aW9uIHVzZURyb3BwYWJsZShfcmVmKSB7XG4gIGxldCB7XG4gICAgZGF0YSxcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgIGlkLFxuICAgIHJlc2l6ZU9ic2VydmVyQ29uZmlnXG4gIH0gPSBfcmVmO1xuICBjb25zdCBrZXkgPSB1c2VVbmlxdWVJZChJRF9QUkVGSVgkMSk7XG4gIGNvbnN0IHtcbiAgICBhY3RpdmUsXG4gICAgZGlzcGF0Y2gsXG4gICAgb3ZlcixcbiAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVyc1xuICB9ID0gdXNlQ29udGV4dChJbnRlcm5hbENvbnRleHQpO1xuICBjb25zdCBwcmV2aW91cyA9IHVzZVJlZih7XG4gICAgZGlzYWJsZWRcbiAgfSk7XG4gIGNvbnN0IHJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcmVjdCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgY2FsbGJhY2tJZCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgIGRpc2FibGVkOiByZXNpemVPYnNlcnZlckRpc2FibGVkLFxuICAgIHVwZGF0ZU1lYXN1cmVtZW50c0ZvcixcbiAgICB0aW1lb3V0OiByZXNpemVPYnNlcnZlclRpbWVvdXRcbiAgfSA9IHsgLi4uZGVmYXVsdFJlc2l6ZU9ic2VydmVyQ29uZmlnLFxuICAgIC4uLnJlc2l6ZU9ic2VydmVyQ29uZmlnXG4gIH07XG4gIGNvbnN0IGlkcyA9IHVzZUxhdGVzdFZhbHVlKHVwZGF0ZU1lYXN1cmVtZW50c0ZvciAhPSBudWxsID8gdXBkYXRlTWVhc3VyZW1lbnRzRm9yIDogaWQpO1xuICBjb25zdCBoYW5kbGVSZXNpemUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFyZXNpemVPYnNlcnZlckNvbm5lY3RlZC5jdXJyZW50KSB7XG4gICAgICAvLyBSZXNpemVPYnNlcnZlciBpbnZva2VzIHRoZSBgaGFuZGxlUmVzaXplYCBjYWxsYmFjayBhcyBzb29uIGFzIGBvYnNlcnZlYCBpcyBjYWxsZWQsXG4gICAgICAvLyBhc3N1bWluZyB0aGUgZWxlbWVudCBpcyByZW5kZXJlZCBhbmQgZGlzcGxheWVkLlxuICAgICAgcmVzaXplT2JzZXJ2ZXJDb25uZWN0ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrSWQuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY2FsbGJhY2tJZC5jdXJyZW50KTtcbiAgICB9XG5cbiAgICBjYWxsYmFja0lkLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzKEFycmF5LmlzQXJyYXkoaWRzLmN1cnJlbnQpID8gaWRzLmN1cnJlbnQgOiBbaWRzLmN1cnJlbnRdKTtcbiAgICAgIGNhbGxiYWNrSWQuY3VycmVudCA9IG51bGw7XG4gICAgfSwgcmVzaXplT2JzZXJ2ZXJUaW1lb3V0KTtcbiAgfSwgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtyZXNpemVPYnNlcnZlclRpbWVvdXRdKTtcbiAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcih7XG4gICAgY2FsbGJhY2s6IGhhbmRsZVJlc2l6ZSxcbiAgICBkaXNhYmxlZDogcmVzaXplT2JzZXJ2ZXJEaXNhYmxlZCB8fCAhYWN0aXZlXG4gIH0pO1xuICBjb25zdCBoYW5kbGVOb2RlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKG5ld0VsZW1lbnQsIHByZXZpb3VzRWxlbWVudCkgPT4ge1xuICAgIGlmICghcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNFbGVtZW50KSB7XG4gICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUocHJldmlvdXNFbGVtZW50KTtcbiAgICAgIHJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobmV3RWxlbWVudCkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShuZXdFbGVtZW50KTtcbiAgICB9XG4gIH0sIFtyZXNpemVPYnNlcnZlcl0pO1xuICBjb25zdCBbbm9kZVJlZiwgc2V0Tm9kZVJlZl0gPSB1c2VOb2RlUmVmKGhhbmRsZU5vZGVDaGFuZ2UpO1xuICBjb25zdCBkYXRhUmVmID0gdXNlTGF0ZXN0VmFsdWUoZGF0YSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFyZXNpemVPYnNlcnZlciB8fCAhbm9kZVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIHJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKG5vZGVSZWYuY3VycmVudCk7XG4gIH0sIFtub2RlUmVmLCByZXNpemVPYnNlcnZlcl0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBBY3Rpb24uUmVnaXN0ZXJEcm9wcGFibGUsXG4gICAgICBlbGVtZW50OiB7XG4gICAgICAgIGlkLFxuICAgICAgICBrZXksXG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICBub2RlOiBub2RlUmVmLFxuICAgICAgICByZWN0LFxuICAgICAgICBkYXRhOiBkYXRhUmVmXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IEFjdGlvbi5VbnJlZ2lzdGVyRHJvcHBhYmxlLFxuICAgICAga2V5LFxuICAgICAgaWRcbiAgICB9KTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbaWRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgIT09IHByZXZpb3VzLmN1cnJlbnQuZGlzYWJsZWQpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogQWN0aW9uLlNldERyb3BwYWJsZURpc2FibGVkLFxuICAgICAgICBpZCxcbiAgICAgICAga2V5LFxuICAgICAgICBkaXNhYmxlZFxuICAgICAgfSk7XG4gICAgICBwcmV2aW91cy5jdXJyZW50LmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICB9LCBbaWQsIGtleSwgZGlzYWJsZWQsIGRpc3BhdGNoXSk7XG4gIHJldHVybiB7XG4gICAgYWN0aXZlLFxuICAgIHJlY3QsXG4gICAgaXNPdmVyOiAob3ZlciA9PSBudWxsID8gdm9pZCAwIDogb3Zlci5pZCkgPT09IGlkLFxuICAgIG5vZGU6IG5vZGVSZWYsXG4gICAgb3ZlcixcbiAgICBzZXROb2RlUmVmXG4gIH07XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbk1hbmFnZXIoX3JlZikge1xuICBsZXQge1xuICAgIGFuaW1hdGlvbixcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgY29uc3QgW2Nsb25lZENoaWxkcmVuLCBzZXRDbG9uZWRDaGlsZHJlbl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHByZXZpb3VzQ2hpbGRyZW4gPSB1c2VQcmV2aW91cyhjaGlsZHJlbik7XG5cbiAgaWYgKCFjaGlsZHJlbiAmJiAhY2xvbmVkQ2hpbGRyZW4gJiYgcHJldmlvdXNDaGlsZHJlbikge1xuICAgIHNldENsb25lZENoaWxkcmVuKHByZXZpb3VzQ2hpbGRyZW4pO1xuICB9XG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gY2xvbmVkQ2hpbGRyZW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNsb25lZENoaWxkcmVuLmtleTtcbiAgICBjb25zdCBpZCA9IGNsb25lZENoaWxkcmVuID09IG51bGwgPyB2b2lkIDAgOiBjbG9uZWRDaGlsZHJlbi5wcm9wcy5pZDtcblxuICAgIGlmIChrZXkgPT0gbnVsbCB8fCBpZCA9PSBudWxsKSB7XG4gICAgICBzZXRDbG9uZWRDaGlsZHJlbihudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBQcm9taXNlLnJlc29sdmUoYW5pbWF0aW9uKGlkLCBlbGVtZW50KSkudGhlbigoKSA9PiB7XG4gICAgICBzZXRDbG9uZWRDaGlsZHJlbihudWxsKTtcbiAgICB9KTtcbiAgfSwgW2FuaW1hdGlvbiwgY2xvbmVkQ2hpbGRyZW4sIGVsZW1lbnRdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuLCBjbG9uZWRDaGlsZHJlbiA/IGNsb25lRWxlbWVudChjbG9uZWRDaGlsZHJlbiwge1xuICAgIHJlZjogc2V0RWxlbWVudFxuICB9KSA6IG51bGwpO1xufVxuXG5jb25zdCBkZWZhdWx0VHJhbnNmb3JtID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcbmZ1bmN0aW9uIE51bGxpZmllZENvbnRleHRQcm92aWRlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEludGVybmFsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkZWZhdWx0SW50ZXJuYWxDb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQWN0aXZlRHJhZ2dhYmxlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkZWZhdWx0VHJhbnNmb3JtXG4gIH0sIGNoaWxkcmVuKSk7XG59XG5cbmNvbnN0IGJhc2VTdHlsZXMgPSB7XG4gIHBvc2l0aW9uOiAnZml4ZWQnLFxuICB0b3VjaEFjdGlvbjogJ25vbmUnXG59O1xuXG5jb25zdCBkZWZhdWx0VHJhbnNpdGlvbiA9IGFjdGl2YXRvckV2ZW50ID0+IHtcbiAgY29uc3QgaXNLZXlib2FyZEFjdGl2YXRvciA9IGlzS2V5Ym9hcmRFdmVudChhY3RpdmF0b3JFdmVudCk7XG4gIHJldHVybiBpc0tleWJvYXJkQWN0aXZhdG9yID8gJ3RyYW5zZm9ybSAyNTBtcyBlYXNlJyA6IHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IFBvc2l0aW9uZWRPdmVybGF5ID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoKF9yZWYsIHJlZikgPT4ge1xuICBsZXQge1xuICAgIGFzLFxuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGFkanVzdFNjYWxlLFxuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZSxcbiAgICByZWN0LFxuICAgIHN0eWxlLFxuICAgIHRyYW5zZm9ybSxcbiAgICB0cmFuc2l0aW9uID0gZGVmYXVsdFRyYW5zaXRpb25cbiAgfSA9IF9yZWY7XG5cbiAgaWYgKCFyZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBzY2FsZUFkanVzdGVkVHJhbnNmb3JtID0gYWRqdXN0U2NhbGUgPyB0cmFuc2Zvcm0gOiB7IC4uLnRyYW5zZm9ybSxcbiAgICBzY2FsZVg6IDEsXG4gICAgc2NhbGVZOiAxXG4gIH07XG4gIGNvbnN0IHN0eWxlcyA9IHsgLi4uYmFzZVN0eWxlcyxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRyYW5zZm9ybTogQ1NTLlRyYW5zZm9ybS50b1N0cmluZyhzY2FsZUFkanVzdGVkVHJhbnNmb3JtKSxcbiAgICB0cmFuc2Zvcm1PcmlnaW46IGFkanVzdFNjYWxlICYmIGFjdGl2YXRvckV2ZW50ID8gZ2V0UmVsYXRpdmVUcmFuc2Zvcm1PcmlnaW4oYWN0aXZhdG9yRXZlbnQsIHJlY3QpIDogdW5kZWZpbmVkLFxuICAgIHRyYW5zaXRpb246IHR5cGVvZiB0cmFuc2l0aW9uID09PSAnZnVuY3Rpb24nID8gdHJhbnNpdGlvbihhY3RpdmF0b3JFdmVudCkgOiB0cmFuc2l0aW9uLFxuICAgIC4uLnN0eWxlXG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KGFzLCB7XG4gICAgY2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZXMsXG4gICAgcmVmXG4gIH0sIGNoaWxkcmVuKTtcbn0pO1xuXG5jb25zdCBkZWZhdWx0RHJvcEFuaW1hdGlvblNpZGVFZmZlY3RzID0gb3B0aW9ucyA9PiBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBhY3RpdmUsXG4gICAgZHJhZ092ZXJsYXlcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IG9yaWdpbmFsU3R5bGVzID0ge307XG4gIGNvbnN0IHtcbiAgICBzdHlsZXMsXG4gICAgY2xhc3NOYW1lXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmIChzdHlsZXMgIT0gbnVsbCAmJiBzdHlsZXMuYWN0aXZlKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3R5bGVzLmFjdGl2ZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5hbFN0eWxlc1trZXldID0gYWN0aXZlLm5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShrZXkpO1xuICAgICAgYWN0aXZlLm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0eWxlcyAhPSBudWxsICYmIHN0eWxlcy5kcmFnT3ZlcmxheSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcy5kcmFnT3ZlcmxheSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkcmFnT3ZlcmxheS5ub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjbGFzc05hbWUgIT0gbnVsbCAmJiBjbGFzc05hbWUuYWN0aXZlKSB7XG4gICAgYWN0aXZlLm5vZGUuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuYWN0aXZlKTtcbiAgfVxuXG4gIGlmIChjbGFzc05hbWUgIT0gbnVsbCAmJiBjbGFzc05hbWUuZHJhZ092ZXJsYXkpIHtcbiAgICBkcmFnT3ZlcmxheS5ub2RlLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLmRyYWdPdmVybGF5KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9yaWdpbmFsU3R5bGVzKSkge1xuICAgICAgYWN0aXZlLm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGNsYXNzTmFtZSAhPSBudWxsICYmIGNsYXNzTmFtZS5hY3RpdmUpIHtcbiAgICAgIGFjdGl2ZS5ub2RlLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lLmFjdGl2ZSk7XG4gICAgfVxuICB9O1xufTtcblxuY29uc3QgZGVmYXVsdEtleWZyYW1lUmVzb2x2ZXIgPSBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICBpbml0aWFsLFxuICAgICAgZmluYWxcbiAgICB9XG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIFt7XG4gICAgdHJhbnNmb3JtOiBDU1MuVHJhbnNmb3JtLnRvU3RyaW5nKGluaXRpYWwpXG4gIH0sIHtcbiAgICB0cmFuc2Zvcm06IENTUy5UcmFuc2Zvcm0udG9TdHJpbmcoZmluYWwpXG4gIH1dO1xufTtcblxuY29uc3QgZGVmYXVsdERyb3BBbmltYXRpb25Db25maWd1cmF0aW9uID0ge1xuICBkdXJhdGlvbjogMjUwLFxuICBlYXNpbmc6ICdlYXNlJyxcbiAga2V5ZnJhbWVzOiBkZWZhdWx0S2V5ZnJhbWVSZXNvbHZlcixcbiAgc2lkZUVmZmVjdHM6IC8qI19fUFVSRV9fKi9kZWZhdWx0RHJvcEFuaW1hdGlvblNpZGVFZmZlY3RzKHtcbiAgICBzdHlsZXM6IHtcbiAgICAgIGFjdGl2ZToge1xuICAgICAgICBvcGFjaXR5OiAnMCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59O1xuZnVuY3Rpb24gdXNlRHJvcEFuaW1hdGlvbihfcmVmMykge1xuICBsZXQge1xuICAgIGNvbmZpZyxcbiAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb25cbiAgfSA9IF9yZWYzO1xuICByZXR1cm4gdXNlRXZlbnQoKGlkLCBub2RlKSA9PiB7XG4gICAgaWYgKGNvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZURyYWdnYWJsZSA9IGRyYWdnYWJsZU5vZGVzLmdldChpZCk7XG5cbiAgICBpZiAoIWFjdGl2ZURyYWdnYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZU5vZGUgPSBhY3RpdmVEcmFnZ2FibGUubm9kZS5jdXJyZW50O1xuXG4gICAgaWYgKCFhY3RpdmVOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVhc3VyYWJsZU5vZGUgPSBnZXRNZWFzdXJhYmxlTm9kZShub2RlKTtcblxuICAgIGlmICghbWVhc3VyYWJsZU5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2Zvcm1cbiAgICB9ID0gZ2V0V2luZG93KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgcGFyc2VkVHJhbnNmb3JtID0gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKTtcblxuICAgIGlmICghcGFyc2VkVHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9uID0gdHlwZW9mIGNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyA/IGNvbmZpZyA6IGNyZWF0ZURlZmF1bHREcm9wQW5pbWF0aW9uKGNvbmZpZyk7XG4gICAgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChhY3RpdmVOb2RlLCBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdnYWJsZS5tZWFzdXJlKTtcbiAgICByZXR1cm4gYW5pbWF0aW9uKHtcbiAgICAgIGFjdGl2ZToge1xuICAgICAgICBpZCxcbiAgICAgICAgZGF0YTogYWN0aXZlRHJhZ2dhYmxlLmRhdGEsXG4gICAgICAgIG5vZGU6IGFjdGl2ZU5vZGUsXG4gICAgICAgIHJlY3Q6IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ2dhYmxlLm1lYXN1cmUoYWN0aXZlTm9kZSlcbiAgICAgIH0sXG4gICAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICAgIGRyYWdPdmVybGF5OiB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIHJlY3Q6IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ092ZXJsYXkubWVhc3VyZShtZWFzdXJhYmxlTm9kZSlcbiAgICAgIH0sXG4gICAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgICAgbWVhc3VyaW5nQ29uZmlndXJhdGlvbixcbiAgICAgIHRyYW5zZm9ybTogcGFyc2VkVHJhbnNmb3JtXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0RHJvcEFuaW1hdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBkdXJhdGlvbixcbiAgICBlYXNpbmcsXG4gICAgc2lkZUVmZmVjdHMsXG4gICAga2V5ZnJhbWVzXG4gIH0gPSB7IC4uLmRlZmF1bHREcm9wQW5pbWF0aW9uQ29uZmlndXJhdGlvbixcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIHJldHVybiBfcmVmNCA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGRyYWdPdmVybGF5LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBfcmVmNDtcblxuICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgIC8vIERvIG5vdCBhbmltYXRlIGlmIGFuaW1hdGlvbiBkdXJhdGlvbiBpcyB6ZXJvLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhID0ge1xuICAgICAgeDogZHJhZ092ZXJsYXkucmVjdC5sZWZ0IC0gYWN0aXZlLnJlY3QubGVmdCxcbiAgICAgIHk6IGRyYWdPdmVybGF5LnJlY3QudG9wIC0gYWN0aXZlLnJlY3QudG9wXG4gICAgfTtcbiAgICBjb25zdCBzY2FsZSA9IHtcbiAgICAgIHNjYWxlWDogdHJhbnNmb3JtLnNjYWxlWCAhPT0gMSA/IGFjdGl2ZS5yZWN0LndpZHRoICogdHJhbnNmb3JtLnNjYWxlWCAvIGRyYWdPdmVybGF5LnJlY3Qud2lkdGggOiAxLFxuICAgICAgc2NhbGVZOiB0cmFuc2Zvcm0uc2NhbGVZICE9PSAxID8gYWN0aXZlLnJlY3QuaGVpZ2h0ICogdHJhbnNmb3JtLnNjYWxlWSAvIGRyYWdPdmVybGF5LnJlY3QuaGVpZ2h0IDogMVxuICAgIH07XG4gICAgY29uc3QgZmluYWxUcmFuc2Zvcm0gPSB7XG4gICAgICB4OiB0cmFuc2Zvcm0ueCAtIGRlbHRhLngsXG4gICAgICB5OiB0cmFuc2Zvcm0ueSAtIGRlbHRhLnksXG4gICAgICAuLi5zY2FsZVxuICAgIH07XG4gICAgY29uc3QgYW5pbWF0aW9uS2V5ZnJhbWVzID0ga2V5ZnJhbWVzKHsgLi4ucmVzdCxcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGRyYWdPdmVybGF5LFxuICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIGluaXRpYWw6IHRyYW5zZm9ybSxcbiAgICAgICAgZmluYWw6IGZpbmFsVHJhbnNmb3JtXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgW2ZpcnN0S2V5ZnJhbWVdID0gYW5pbWF0aW9uS2V5ZnJhbWVzO1xuICAgIGNvbnN0IGxhc3RLZXlmcmFtZSA9IGFuaW1hdGlvbktleWZyYW1lc1thbmltYXRpb25LZXlmcmFtZXMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkoZmlyc3RLZXlmcmFtZSkgPT09IEpTT04uc3RyaW5naWZ5KGxhc3RLZXlmcmFtZSkpIHtcbiAgICAgIC8vIFRoZSBzdGFydCBhbmQgZW5kIGtleWZyYW1lcyBhcmUgdGhlIHNhbWUsIGluZmVyIHRoYXQgdGhlcmUgaXMgbm8gYW5pbWF0aW9uIG5lZWRlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjbGVhbnVwID0gc2lkZUVmZmVjdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNpZGVFZmZlY3RzKHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGRyYWdPdmVybGF5LFxuICAgICAgLi4ucmVzdFxuICAgIH0pO1xuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGRyYWdPdmVybGF5Lm5vZGUuYW5pbWF0ZShhbmltYXRpb25LZXlmcmFtZXMsIHtcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgZWFzaW5nLFxuICAgICAgZmlsbDogJ2ZvcndhcmRzJ1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGFuaW1hdGlvbi5vbmZpbmlzaCA9ICgpID0+IHtcbiAgICAgICAgY2xlYW51cCA9PSBudWxsID8gdm9pZCAwIDogY2xlYW51cCgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xufVxuXG5sZXQga2V5ID0gMDtcbmZ1bmN0aW9uIHVzZUtleShpZCkge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBrZXkrKztcbiAgICByZXR1cm4ga2V5O1xuICB9LCBbaWRdKTtcbn1cblxuY29uc3QgRHJhZ092ZXJsYXkgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBhZGp1c3RTY2FsZSA9IGZhbHNlLFxuICAgIGNoaWxkcmVuLFxuICAgIGRyb3BBbmltYXRpb246IGRyb3BBbmltYXRpb25Db25maWcsXG4gICAgc3R5bGUsXG4gICAgdHJhbnNpdGlvbixcbiAgICBtb2RpZmllcnMsXG4gICAgd3JhcHBlckVsZW1lbnQgPSAnZGl2JyxcbiAgICBjbGFzc05hbWUsXG4gICAgekluZGV4ID0gOTk5XG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgYWN0aXZlLFxuICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgIGNvbnRhaW5lck5vZGVSZWN0LFxuICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgZHJhZ092ZXJsYXksXG4gICAgb3ZlcixcbiAgICBtZWFzdXJpbmdDb25maWd1cmF0aW9uLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsXG4gICAgd2luZG93UmVjdFxuICB9ID0gdXNlRG5kQ29udGV4dCgpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSB1c2VDb250ZXh0KEFjdGl2ZURyYWdnYWJsZUNvbnRleHQpO1xuICBjb25zdCBrZXkgPSB1c2VLZXkoYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaWQpO1xuICBjb25zdCBtb2RpZmllZFRyYW5zZm9ybSA9IGFwcGx5TW9kaWZpZXJzKG1vZGlmaWVycywge1xuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICBjb250YWluZXJOb2RlUmVjdCxcbiAgICBkcmFnZ2luZ05vZGVSZWN0OiBkcmFnT3ZlcmxheS5yZWN0LFxuICAgIG92ZXIsXG4gICAgb3ZlcmxheU5vZGVSZWN0OiBkcmFnT3ZlcmxheS5yZWN0LFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsXG4gICAgdHJhbnNmb3JtLFxuICAgIHdpbmRvd1JlY3RcbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxSZWN0ID0gdXNlSW5pdGlhbFZhbHVlKGFjdGl2ZU5vZGVSZWN0KTtcbiAgY29uc3QgZHJvcEFuaW1hdGlvbiA9IHVzZURyb3BBbmltYXRpb24oe1xuICAgIGNvbmZpZzogZHJvcEFuaW1hdGlvbkNvbmZpZyxcbiAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb25cbiAgfSk7IC8vIFdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGFjdGl2ZSBub2RlIHRvIGJlIG1lYXN1cmVkIGJlZm9yZSBjb25uZWN0aW5nIHRoZSBkcmFnIG92ZXJsYXkgcmVmXG4gIC8vIG90aGVyd2lzZSBjb2xsaXNpb25zIGNhbiBiZSBjb21wdXRlZCBhZ2FpbnN0IGEgbWlzcG9zaXRpb25lZCBkcmFnIG92ZXJsYXlcblxuICBjb25zdCByZWYgPSBpbml0aWFsUmVjdCA/IGRyYWdPdmVybGF5LnNldFJlZiA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTnVsbGlmaWVkQ29udGV4dFByb3ZpZGVyLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEFuaW1hdGlvbk1hbmFnZXIsIHtcbiAgICBhbmltYXRpb246IGRyb3BBbmltYXRpb25cbiAgfSwgYWN0aXZlICYmIGtleSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUG9zaXRpb25lZE92ZXJsYXksIHtcbiAgICBrZXk6IGtleSxcbiAgICBpZDogYWN0aXZlLmlkLFxuICAgIHJlZjogcmVmLFxuICAgIGFzOiB3cmFwcGVyRWxlbWVudCxcbiAgICBhY3RpdmF0b3JFdmVudDogYWN0aXZhdG9yRXZlbnQsXG4gICAgYWRqdXN0U2NhbGU6IGFkanVzdFNjYWxlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgcmVjdDogaW5pdGlhbFJlY3QsXG4gICAgc3R5bGU6IHtcbiAgICAgIHpJbmRleCxcbiAgICAgIC4uLnN0eWxlXG4gICAgfSxcbiAgICB0cmFuc2Zvcm06IG1vZGlmaWVkVHJhbnNmb3JtXG4gIH0sIGNoaWxkcmVuKSA6IG51bGwpKTtcbn0pO1xuXG5leHBvcnQgeyBBdXRvU2Nyb2xsQWN0aXZhdG9yLCBEbmRDb250ZXh0LCBEcmFnT3ZlcmxheSwgS2V5Ym9hcmRDb2RlLCBLZXlib2FyZFNlbnNvciwgTWVhc3VyaW5nRnJlcXVlbmN5LCBNZWFzdXJpbmdTdHJhdGVneSwgTW91c2VTZW5zb3IsIFBvaW50ZXJTZW5zb3IsIFRvdWNoU2Vuc29yLCBUcmF2ZXJzYWxPcmRlciwgYXBwbHlNb2RpZmllcnMsIGNsb3Nlc3RDZW50ZXIsIGNsb3Nlc3RDb3JuZXJzLCBkZWZhdWx0QW5ub3VuY2VtZW50cywgZGVmYXVsdENvb3JkaW5hdGVzLCBkZWZhdWx0RHJvcEFuaW1hdGlvbkNvbmZpZ3VyYXRpb24gYXMgZGVmYXVsdERyb3BBbmltYXRpb24sIGRlZmF1bHREcm9wQW5pbWF0aW9uU2lkZUVmZmVjdHMsIGRlZmF1bHRTY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMsIGdldENsaWVudFJlY3QsIGdldEZpcnN0Q29sbGlzaW9uLCBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzLCBwb2ludGVyV2l0aGluLCByZWN0SW50ZXJzZWN0aW9uLCB1c2VEbmRDb250ZXh0LCB1c2VEbmRNb25pdG9yLCB1c2VEcmFnZ2FibGUsIHVzZURyb3BwYWJsZSwgdXNlU2Vuc29yLCB1c2VTZW5zb3JzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VSZWR1Y2VyIiwibWVtbyIsImNsb25lRWxlbWVudCIsImZvcndhcmRSZWYiLCJjcmVhdGVQb3J0YWwiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsInVzZVVuaXF1ZUlkIiwiZ2V0RXZlbnRDb29yZGluYXRlcyIsImdldFdpbmRvdyIsImlzRG9jdW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiaXNTVkdFbGVtZW50IiwiY2FuVXNlRE9NIiwiaXNXaW5kb3ciLCJpc05vZGUiLCJnZXRPd25lckRvY3VtZW50IiwiYWRkIiwiaXNLZXlib2FyZEV2ZW50Iiwic3VidHJhY3QiLCJ1c2VMYXp5TWVtbyIsInVzZUludGVydmFsIiwidXNlUHJldmlvdXMiLCJ1c2VMYXRlc3RWYWx1ZSIsInVzZUV2ZW50IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZU5vZGVSZWYiLCJmaW5kRmlyc3RGb2N1c2FibGVOb2RlIiwiQ1NTIiwidXNlQW5ub3VuY2VtZW50IiwiSGlkZGVuVGV4dCIsIkxpdmVSZWdpb24iLCJEbmRNb25pdG9yQ29udGV4dCIsInVzZURuZE1vbml0b3IiLCJsaXN0ZW5lciIsInJlZ2lzdGVyTGlzdGVuZXIiLCJFcnJvciIsInVuc3Vic2NyaWJlIiwidXNlRG5kTW9uaXRvclByb3ZpZGVyIiwibGlzdGVuZXJzIiwiU2V0IiwiZGVsZXRlIiwiZGlzcGF0Y2giLCJfcmVmIiwidHlwZSIsImV2ZW50IiwiZm9yRWFjaCIsIl9saXN0ZW5lciR0eXBlIiwiY2FsbCIsImRlZmF1bHRTY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMiLCJkcmFnZ2FibGUiLCJkZWZhdWx0QW5ub3VuY2VtZW50cyIsIm9uRHJhZ1N0YXJ0IiwiYWN0aXZlIiwiaWQiLCJvbkRyYWdPdmVyIiwiX3JlZjIiLCJvdmVyIiwib25EcmFnRW5kIiwiX3JlZjMiLCJvbkRyYWdDYW5jZWwiLCJfcmVmNCIsIkFjY2Vzc2liaWxpdHkiLCJhbm5vdW5jZW1lbnRzIiwiY29udGFpbmVyIiwiaGlkZGVuVGV4dERlc2NyaWJlZEJ5SWQiLCJzY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMiLCJhbm5vdW5jZSIsImFubm91bmNlbWVudCIsImxpdmVSZWdpb25JZCIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwib25EcmFnTW92ZSIsIl9yZWY1IiwiX3JlZjYiLCJtYXJrdXAiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJ2YWx1ZSIsIkFjdGlvbiIsIm5vb3AiLCJ1c2VTZW5zb3IiLCJzZW5zb3IiLCJvcHRpb25zIiwidXNlU2Vuc29ycyIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZW5zb3JzIiwiQXJyYXkiLCJfa2V5IiwiZmlsdGVyIiwiZGVmYXVsdENvb3JkaW5hdGVzIiwiT2JqZWN0IiwiZnJlZXplIiwieCIsInkiLCJkaXN0YW5jZUJldHdlZW4iLCJwMSIsInAyIiwiTWF0aCIsInNxcnQiLCJwb3ciLCJnZXRSZWxhdGl2ZVRyYW5zZm9ybU9yaWdpbiIsInJlY3QiLCJldmVudENvb3JkaW5hdGVzIiwidHJhbnNmb3JtT3JpZ2luIiwibGVmdCIsIndpZHRoIiwidG9wIiwiaGVpZ2h0Iiwic29ydENvbGxpc2lvbnNBc2MiLCJkYXRhIiwiYSIsImIiLCJzb3J0Q29sbGlzaW9uc0Rlc2MiLCJjb3JuZXJzT2ZSZWN0YW5nbGUiLCJnZXRGaXJzdENvbGxpc2lvbiIsImNvbGxpc2lvbnMiLCJwcm9wZXJ0eSIsImZpcnN0Q29sbGlzaW9uIiwiY2VudGVyT2ZSZWN0YW5nbGUiLCJjbG9zZXN0Q2VudGVyIiwiY29sbGlzaW9uUmVjdCIsImRyb3BwYWJsZVJlY3RzIiwiZHJvcHBhYmxlQ29udGFpbmVycyIsImNlbnRlclJlY3QiLCJkcm9wcGFibGVDb250YWluZXIiLCJnZXQiLCJkaXN0QmV0d2VlbiIsInB1c2giLCJzb3J0IiwiY2xvc2VzdENvcm5lcnMiLCJjb3JuZXJzIiwicmVjdENvcm5lcnMiLCJkaXN0YW5jZXMiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciIsImNvcm5lciIsImluZGV4IiwiZWZmZWN0aXZlRGlzdGFuY2UiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwiZ2V0SW50ZXJzZWN0aW9uUmF0aW8iLCJlbnRyeSIsInRhcmdldCIsIm1heCIsInJpZ2h0IiwibWluIiwiYm90dG9tIiwidGFyZ2V0QXJlYSIsImVudHJ5QXJlYSIsImludGVyc2VjdGlvbkFyZWEiLCJpbnRlcnNlY3Rpb25SYXRpbyIsInJlY3RJbnRlcnNlY3Rpb24iLCJpc1BvaW50V2l0aGluUmVjdCIsInBvaW50IiwicG9pbnRlcldpdGhpbiIsInBvaW50ZXJDb29yZGluYXRlcyIsImFkanVzdFNjYWxlIiwidHJhbnNmb3JtIiwicmVjdDEiLCJyZWN0MiIsInNjYWxlWCIsInNjYWxlWSIsImdldFJlY3REZWx0YSIsImNyZWF0ZVJlY3RBZGp1c3RtZW50Rm4iLCJtb2RpZmllciIsImFkanVzdENsaWVudFJlY3QiLCJhZGp1c3RtZW50cyIsImFjYyIsImFkanVzdG1lbnQiLCJnZXRBZGp1c3RlZFJlY3QiLCJwYXJzZVRyYW5zZm9ybSIsInN0YXJ0c1dpdGgiLCJ0cmFuc2Zvcm1BcnJheSIsInNsaWNlIiwic3BsaXQiLCJpbnZlcnNlVHJhbnNmb3JtIiwicGFyc2VkVHJhbnNmb3JtIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJwYXJzZUZsb2F0IiwiaW5kZXhPZiIsInciLCJoIiwiZGVmYXVsdE9wdGlvbnMiLCJpZ25vcmVUcmFuc2Zvcm0iLCJnZXRDbGllbnRSZWN0IiwiZWxlbWVudCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRUcmFuc2Zvcm1BZ25vc3RpY0NsaWVudFJlY3QiLCJnZXRXaW5kb3dDbGllbnRSZWN0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiaXNGaXhlZCIsIm5vZGUiLCJjb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJpc1Njcm9sbGFibGUiLCJvdmVyZmxvd1JlZ2V4IiwicHJvcGVydGllcyIsInNvbWUiLCJ0ZXN0IiwiZ2V0U2Nyb2xsYWJsZUFuY2VzdG9ycyIsImxpbWl0Iiwic2Nyb2xsUGFyZW50cyIsImZpbmRTY3JvbGxhYmxlQW5jZXN0b3JzIiwic2Nyb2xsaW5nRWxlbWVudCIsImluY2x1ZGVzIiwicGFyZW50Tm9kZSIsImdldEZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yIiwiZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IiLCJnZXRTY3JvbGxhYmxlRWxlbWVudCIsIndpbmRvdyIsImdldFNjcm9sbFhDb29yZGluYXRlIiwic2Nyb2xsWCIsInNjcm9sbExlZnQiLCJnZXRTY3JvbGxZQ29vcmRpbmF0ZSIsInNjcm9sbFkiLCJzY3JvbGxUb3AiLCJnZXRTY3JvbGxDb29yZGluYXRlcyIsIkRpcmVjdGlvbiIsImlzRG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRTY3JvbGxQb3NpdGlvbiIsInNjcm9sbGluZ0NvbnRhaW5lciIsIm1pblNjcm9sbCIsImRpbWVuc2lvbnMiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsIm1heFNjcm9sbCIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiaXNUb3AiLCJpc0xlZnQiLCJpc0JvdHRvbSIsImlzUmlnaHQiLCJkZWZhdWx0VGhyZXNob2xkIiwiZ2V0U2Nyb2xsRGlyZWN0aW9uQW5kU3BlZWQiLCJzY3JvbGxDb250YWluZXIiLCJzY3JvbGxDb250YWluZXJSZWN0IiwiYWNjZWxlcmF0aW9uIiwidGhyZXNob2xkUGVyY2VudGFnZSIsImRpcmVjdGlvbiIsInNwZWVkIiwidGhyZXNob2xkIiwiQmFja3dhcmQiLCJhYnMiLCJGb3J3YXJkIiwiZ2V0U2Nyb2xsRWxlbWVudFJlY3QiLCJnZXRTY3JvbGxPZmZzZXRzIiwic2Nyb2xsYWJsZUFuY2VzdG9ycyIsImdldFNjcm9sbFhPZmZzZXQiLCJnZXRTY3JvbGxZT2Zmc2V0Iiwic2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCIsIm1lYXN1cmUiLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiaW5saW5lIiwiUmVjdCIsImNvbnN0cnVjdG9yIiwic2Nyb2xsT2Zmc2V0cyIsImF4aXMiLCJrZXlzIiwiZ2V0U2Nyb2xsT2Zmc2V0Iiwia2V5IiwiZGVmaW5lUHJvcGVydHkiLCJjdXJyZW50T2Zmc2V0cyIsInNjcm9sbE9mZnNldHNEZWx0bGEiLCJlbnVtZXJhYmxlIiwiTGlzdGVuZXJzIiwiZXZlbnROYW1lIiwiaGFuZGxlciIsIl90aGlzJHRhcmdldDIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlQWxsIiwiX3RoaXMkdGFyZ2V0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImdldEV2ZW50TGlzdGVuZXJUYXJnZXQiLCJFdmVudFRhcmdldCIsImhhc0V4Y2VlZGVkRGlzdGFuY2UiLCJkZWx0YSIsIm1lYXN1cmVtZW50IiwiZHgiLCJkeSIsIkV2ZW50TmFtZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiS2V5Ym9hcmRDb2RlIiwiZGVmYXVsdEtleWJvYXJkQ29kZXMiLCJzdGFydCIsIlNwYWNlIiwiRW50ZXIiLCJjYW5jZWwiLCJFc2MiLCJlbmQiLCJkZWZhdWx0S2V5Ym9hcmRDb29yZGluYXRlR2V0dGVyIiwiY3VycmVudENvb3JkaW5hdGVzIiwiY29kZSIsIlJpZ2h0IiwiTGVmdCIsIkRvd24iLCJVcCIsInVuZGVmaW5lZCIsIktleWJvYXJkU2Vuc29yIiwiYXR0YWNoIiwiaGFuZGxlU3RhcnQiLCJ3aW5kb3dMaXN0ZW5lcnMiLCJSZXNpemUiLCJoYW5kbGVDYW5jZWwiLCJWaXNpYmlsaXR5Q2hhbmdlIiwic2V0VGltZW91dCIsIktleWRvd24iLCJoYW5kbGVLZXlEb3duIiwiYWN0aXZlTm9kZSIsIm9uU3RhcnQiLCJwcm9wcyIsImN1cnJlbnQiLCJjb250ZXh0Iiwia2V5Ym9hcmRDb2RlcyIsImNvb3JkaW5hdGVHZXR0ZXIiLCJzY3JvbGxCZWhhdmlvciIsImhhbmRsZUVuZCIsInJlZmVyZW5jZUNvb3JkaW5hdGVzIiwibmV3Q29vcmRpbmF0ZXMiLCJjb29yZGluYXRlc0RlbHRhIiwic2Nyb2xsRGVsdGEiLCJzY3JvbGxFbGVtZW50UmVjdCIsImNsYW1wZWRDb29yZGluYXRlcyIsImNhblNjcm9sbFgiLCJjYW5TY3JvbGxZIiwibmV3U2Nyb2xsQ29vcmRpbmF0ZXMiLCJjYW5TY3JvbGxUb05ld0Nvb3JkaW5hdGVzIiwic2Nyb2xsVG8iLCJiZWhhdmlvciIsInNjcm9sbEJ5IiwiaGFuZGxlTW92ZSIsImNvb3JkaW5hdGVzIiwib25Nb3ZlIiwib25FbmQiLCJkZXRhY2giLCJvbkNhbmNlbCIsImF1dG9TY3JvbGxFbmFibGVkIiwiYmluZCIsImFjdGl2YXRvcnMiLCJvbkFjdGl2YXRpb24iLCJuYXRpdmVFdmVudCIsImFjdGl2YXRvciIsImFjdGl2YXRvck5vZGUiLCJpc0Rpc3RhbmNlQ29uc3RyYWludCIsImNvbnN0cmFpbnQiLCJCb29sZWFuIiwiaXNEZWxheUNvbnN0cmFpbnQiLCJBYnN0cmFjdFBvaW50ZXJTZW5zb3IiLCJldmVudHMiLCJhY3RpdmF0aW9uQ29uc3RyYWludCIsImJ5cGFzc0FjdGl2YXRpb25Db25zdHJhaW50IiwibW92ZSIsIm5hbWUiLCJwYXNzaXZlIiwiRHJhZ1N0YXJ0IiwiQ29udGV4dE1lbnUiLCJkb2N1bWVudExpc3RlbmVycyIsImhhbmRsZUtleWRvd24iLCJ0aW1lb3V0SWQiLCJkZWxheSIsImNsZWFyVGltZW91dCIsImluaXRpYWxDb29yZGluYXRlcyIsImFjdGl2YXRlZCIsIkNsaWNrIiwiY2FwdHVyZSIsInJlbW92ZVRleHRTZWxlY3Rpb24iLCJTZWxlY3Rpb25DaGFuZ2UiLCJfZ2V0RXZlbnRDb29yZGluYXRlczIiLCJ0b2xlcmFuY2UiLCJkaXN0YW5jZSIsImNhbmNlbGFibGUiLCJfdGhpcyRkb2N1bWVudCRnZXRTZWwiLCJnZXRTZWxlY3Rpb24iLCJyZW1vdmVBbGxSYW5nZXMiLCJsaXN0ZW5lclRhcmdldCIsIl9nZXRFdmVudENvb3JkaW5hdGVzIiwiUG9pbnRlclNlbnNvciIsImlzUHJpbWFyeSIsImJ1dHRvbiIsImV2ZW50cyQxIiwiTW91c2VCdXR0b24iLCJNb3VzZVNlbnNvciIsIlJpZ2h0Q2xpY2siLCJldmVudHMkMiIsIlRvdWNoU2Vuc29yIiwic2V0dXAiLCJ0ZWFyZG93biIsInRvdWNoZXMiLCJBdXRvU2Nyb2xsQWN0aXZhdG9yIiwiVHJhdmVyc2FsT3JkZXIiLCJ1c2VBdXRvU2Nyb2xsZXIiLCJQb2ludGVyIiwiY2FuU2Nyb2xsIiwiZHJhZ2dpbmdSZWN0IiwiZW5hYmxlZCIsImludGVydmFsIiwib3JkZXIiLCJUcmVlT3JkZXIiLCJzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cyIsInNjcm9sbEludGVudCIsInVzZVNjcm9sbEludGVudCIsImRpc2FibGVkIiwic2V0QXV0b1Njcm9sbEludGVydmFsIiwiY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWwiLCJzY3JvbGxTcGVlZCIsInNjcm9sbERpcmVjdGlvbiIsIkRyYWdnYWJsZVJlY3QiLCJzY3JvbGxDb250YWluZXJSZWYiLCJhdXRvU2Nyb2xsIiwic29ydGVkU2Nyb2xsYWJsZUFuY2VzdG9ycyIsInJldmVyc2UiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVmYXVsdFNjcm9sbEludGVudCIsInByZXZpb3VzRGVsdGEiLCJwcmV2aW91c0ludGVudCIsInNpZ24iLCJ1c2VDYWNoZWROb2RlIiwiZHJhZ2dhYmxlTm9kZXMiLCJkcmFnZ2FibGVOb2RlIiwiY2FjaGVkTm9kZSIsInVzZUNvbWJpbmVBY3RpdmF0b3JzIiwiZ2V0U3ludGhldGljSGFuZGxlciIsIlNlbnNvciIsInNlbnNvckFjdGl2YXRvcnMiLCJtYXAiLCJNZWFzdXJpbmdTdHJhdGVneSIsIk1lYXN1cmluZ0ZyZXF1ZW5jeSIsImRlZmF1bHRWYWx1ZSIsIk1hcCIsInVzZURyb3BwYWJsZU1lYXN1cmluZyIsImNvbnRhaW5lcnMiLCJkcmFnZ2luZyIsImRlcGVuZGVuY2llcyIsImNvbmZpZyIsInF1ZXVlIiwic2V0UXVldWUiLCJmcmVxdWVuY3kiLCJzdHJhdGVneSIsImNvbnRhaW5lcnNSZWYiLCJpc0Rpc2FibGVkIiwiZGlzYWJsZWRSZWYiLCJtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycyIsImlkcyIsImNvbmNhdCIsInByZXZpb3VzVmFsdWUiLCJzZXQiLCJtZWFzdXJpbmdTY2hlZHVsZWQiLCJBbHdheXMiLCJCZWZvcmVEcmFnZ2luZyIsInVzZUluaXRpYWxWYWx1ZSIsImNvbXB1dGVGbiIsInVzZUluaXRpYWxSZWN0IiwidXNlTXV0YXRpb25PYnNlcnZlciIsImNhbGxiYWNrIiwiaGFuZGxlTXV0YXRpb25zIiwibXV0YXRpb25PYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwidXNlUmVzaXplT2JzZXJ2ZXIiLCJoYW5kbGVSZXNpemUiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwiZGVmYXVsdE1lYXN1cmUiLCJ1c2VSZWN0IiwiZmFsbGJhY2tSZWN0IiwibWVhc3VyZVJlY3QiLCJyZWR1Y2VyIiwicmVjb3JkcyIsInJlY29yZCIsIkhUTUxFbGVtZW50IiwiY29udGFpbnMiLCJvYnNlcnZlIiwiYm9keSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJjdXJyZW50UmVjdCIsImlzQ29ubmVjdGVkIiwibmV3UmVjdCIsInVzZVJlY3REZWx0YSIsImluaXRpYWxSZWN0IiwiZGVmYXVsdFZhbHVlJDEiLCJ1c2VTY3JvbGxhYmxlQW5jZXN0b3JzIiwicHJldmlvdXNOb2RlIiwiYW5jZXN0b3JzIiwidXNlU2Nyb2xsT2Zmc2V0cyIsImVsZW1lbnRzIiwic2Nyb2xsQ29vcmRpbmF0ZXMiLCJzZXRTY3JvbGxDb29yZGluYXRlcyIsInByZXZFbGVtZW50cyIsImhhbmRsZVNjcm9sbCIsInByZXZpb3VzRWxlbWVudHMiLCJjbGVhbnVwIiwiZW50cmllcyIsInNjcm9sbGFibGVFbGVtZW50IiwiZnJvbSIsInZhbHVlcyIsInVzZVNjcm9sbE9mZnNldHNEZWx0YSIsImluaXRpYWxTY3JvbGxPZmZzZXRzIiwiaGFzU2Nyb2xsT2Zmc2V0cyIsInVzZVNlbnNvclNldHVwIiwidGVhcmRvd25GbnMiLCJ1c2VTeW50aGV0aWNMaXN0ZW5lcnMiLCJ1c2VXaW5kb3dSZWN0IiwiZGVmYXVsdFZhbHVlJDIiLCJ1c2VSZWN0cyIsImZpcnN0RWxlbWVudCIsIndpbmRvd1JlY3QiLCJyZWN0cyIsIm1lYXN1cmVSZWN0cyIsImdldE1lYXN1cmFibGVOb2RlIiwiY2hpbGRyZW4iLCJmaXJzdENoaWxkIiwidXNlRHJhZ092ZXJsYXlNZWFzdXJpbmciLCJzZXRSZWN0IiwiaGFuZGxlTm9kZUNoYW5nZSIsIm5vZGVSZWYiLCJzZXRSZWYiLCJkZWZhdWx0U2Vuc29ycyIsImRlZmF1bHREYXRhIiwiZGVmYXVsdE1lYXN1cmluZ0NvbmZpZ3VyYXRpb24iLCJkcm9wcGFibGUiLCJXaGlsZURyYWdnaW5nIiwiT3B0aW1pemVkIiwiZHJhZ092ZXJsYXkiLCJEcm9wcGFibGVDb250YWluZXJzTWFwIiwiX3N1cGVyJGdldCIsInRvQXJyYXkiLCJnZXRFbmFibGVkIiwiZ2V0Tm9kZUZvciIsIl90aGlzJGdldCRub2RlJGN1cnJlbiIsIl90aGlzJGdldCIsImRlZmF1bHRQdWJsaWNDb250ZXh0IiwiYWN0aXZhdG9yRXZlbnQiLCJhY3RpdmVOb2RlUmVjdCIsImNvbnRhaW5lck5vZGVSZWN0IiwibWVhc3VyaW5nQ29uZmlndXJhdGlvbiIsImRlZmF1bHRJbnRlcm5hbENvbnRleHQiLCJhcmlhRGVzY3JpYmVkQnlJZCIsIkludGVybmFsQ29udGV4dCIsIlB1YmxpY0NvbnRleHQiLCJnZXRJbml0aWFsU3RhdGUiLCJub2RlcyIsInRyYW5zbGF0ZSIsInN0YXRlIiwiYWN0aW9uIiwiRHJhZ01vdmUiLCJEcmFnRW5kIiwiRHJhZ0NhbmNlbCIsIlJlZ2lzdGVyRHJvcHBhYmxlIiwiU2V0RHJvcHBhYmxlRGlzYWJsZWQiLCJVbnJlZ2lzdGVyRHJvcHBhYmxlIiwiUmVzdG9yZUZvY3VzIiwicHJldmlvdXNBY3RpdmF0b3JFdmVudCIsInByZXZpb3VzQWN0aXZlSWQiLCJhY3RpdmVFbGVtZW50IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZm9jdXNhYmxlTm9kZSIsImZvY3VzIiwiYXBwbHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJhcmdzIiwidXNlTWVhc3VyaW5nQ29uZmlndXJhdGlvbiIsInVzZUxheW91dFNoaWZ0U2Nyb2xsQ29tcGVuc2F0aW9uIiwiaW5pdGlhbGl6ZWQiLCJyZWN0RGVsdGEiLCJBY3RpdmVEcmFnZ2FibGVDb250ZXh0IiwiU3RhdHVzIiwiRG5kQ29udGV4dCIsIl9zZW5zb3JDb250ZXh0JGN1cnJlbiIsIl9kcmFnT3ZlcmxheSRub2RlUmVmJCIsIl9kcmFnT3ZlcmxheSRyZWN0IiwiX292ZXIkcmVjdCIsImFjY2Vzc2liaWxpdHkiLCJjb2xsaXNpb25EZXRlY3Rpb24iLCJtZWFzdXJpbmciLCJzdG9yZSIsImRpc3BhdGNoTW9uaXRvckV2ZW50IiwicmVnaXN0ZXJNb25pdG9yTGlzdGVuZXIiLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJVbmluaXRpYWxpemVkIiwiaXNJbml0aWFsaXplZCIsIkluaXRpYWxpemVkIiwiYWN0aXZlSWQiLCJhY3RpdmVSZWN0cyIsImluaXRpYWwiLCJ0cmFuc2xhdGVkIiwiX25vZGUkZGF0YSIsImFjdGl2ZVJlZiIsImFjdGl2ZVNlbnNvciIsInNldEFjdGl2ZVNlbnNvciIsInNldEFjdGl2YXRvckV2ZW50IiwibGF0ZXN0UHJvcHMiLCJkcmFnZ2FibGVEZXNjcmliZWRCeUlkIiwiZW5hYmxlZERyb3BwYWJsZUNvbnRhaW5lcnMiLCJhY3RpdmF0aW9uQ29vcmRpbmF0ZXMiLCJhdXRvU2Nyb2xsT3B0aW9ucyIsImdldEF1dG9TY3JvbGxlck9wdGlvbnMiLCJpbml0aWFsQWN0aXZlTm9kZVJlY3QiLCJsYXlvdXRTaGlmdENvbXBlbnNhdGlvbiIsInBhcmVudEVsZW1lbnQiLCJzZW5zb3JDb250ZXh0IiwiZHJhZ2dpbmdOb2RlIiwiZHJhZ2dpbmdOb2RlUmVjdCIsInNjcm9sbEFkanVzdGVkVHJhbnNsYXRlIiwib3Zlck5vZGUiLCJ1c2VzRHJhZ092ZXJsYXkiLCJub2RlUmVjdERlbHRhIiwibW9kaWZpZWRUcmFuc2xhdGUiLCJvdmVybGF5Tm9kZVJlY3QiLCJzY3JvbGxBZGp1c3RtZW50IiwiYWN0aXZlTm9kZVNjcm9sbERlbHRhIiwib3ZlcklkIiwic2V0T3ZlciIsImFwcGxpZWRUcmFuc2xhdGUiLCJpbnN0YW50aWF0ZVNlbnNvciIsInNlbnNvckluc3RhbmNlIiwiSW5pdGlhbGl6aW5nIiwiY3JlYXRlSGFuZGxlciIsImNhbmNlbERyb3AiLCJzaG91bGRDYW5jZWwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImJpbmRBY3RpdmF0b3JUb1NlbnNvckluc3RhbnRpYXRvciIsImFjdGl2ZURyYWdnYWJsZU5vZGUiLCJkbmRLaXQiLCJkZWZhdWx0UHJldmVudGVkIiwiYWN0aXZhdGlvbkNvbnRleHQiLCJzaG91bGRBY3RpdmF0ZSIsImNhcHR1cmVkQnkiLCJvdmVyQ29udGFpbmVyIiwicHVibGljQ29udGV4dCIsImludGVybmFsQ29udGV4dCIsIlByb3ZpZGVyIiwicmVzdG9yZUZvY3VzIiwiYWN0aXZlU2Vuc29yRGlzYWJsZXNBdXRvc2Nyb2xsIiwiYXV0b1Njcm9sbEdsb2JhbGx5RGlzYWJsZWQiLCJOdWxsQ29udGV4dCIsImRlZmF1bHRSb2xlIiwiSURfUFJFRklYIiwidXNlRHJhZ2dhYmxlIiwiYXR0cmlidXRlcyIsInJvbGUiLCJyb2xlRGVzY3JpcHRpb24iLCJ0YWJJbmRleCIsImlzRHJhZ2dpbmciLCJzZXROb2RlUmVmIiwic2V0QWN0aXZhdG9yTm9kZVJlZiIsImRhdGFSZWYiLCJtZW1vaXplZEF0dHJpYnV0ZXMiLCJ1c2VEbmRDb250ZXh0IiwiSURfUFJFRklYJDEiLCJkZWZhdWx0UmVzaXplT2JzZXJ2ZXJDb25maWciLCJ0aW1lb3V0IiwidXNlRHJvcHBhYmxlIiwicmVzaXplT2JzZXJ2ZXJDb25maWciLCJwcmV2aW91cyIsInJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkIiwiY2FsbGJhY2tJZCIsInJlc2l6ZU9ic2VydmVyRGlzYWJsZWQiLCJ1cGRhdGVNZWFzdXJlbWVudHNGb3IiLCJyZXNpemVPYnNlcnZlclRpbWVvdXQiLCJpc0FycmF5IiwibmV3RWxlbWVudCIsInByZXZpb3VzRWxlbWVudCIsInVub2JzZXJ2ZSIsImlzT3ZlciIsIkFuaW1hdGlvbk1hbmFnZXIiLCJhbmltYXRpb24iLCJjbG9uZWRDaGlsZHJlbiIsInNldENsb25lZENoaWxkcmVuIiwic2V0RWxlbWVudCIsInByZXZpb3VzQ2hpbGRyZW4iLCJ0aGVuIiwicmVmIiwiZGVmYXVsdFRyYW5zZm9ybSIsIk51bGxpZmllZENvbnRleHRQcm92aWRlciIsImJhc2VTdHlsZXMiLCJ0b3VjaEFjdGlvbiIsImRlZmF1bHRUcmFuc2l0aW9uIiwiaXNLZXlib2FyZEFjdGl2YXRvciIsIlBvc2l0aW9uZWRPdmVybGF5IiwiYXMiLCJjbGFzc05hbWUiLCJzdHlsZSIsInRyYW5zaXRpb24iLCJzY2FsZUFkanVzdGVkVHJhbnNmb3JtIiwic3R5bGVzIiwiVHJhbnNmb3JtIiwidG9TdHJpbmciLCJkZWZhdWx0RHJvcEFuaW1hdGlvblNpZGVFZmZlY3RzIiwib3JpZ2luYWxTdHlsZXMiLCJnZXRQcm9wZXJ0eVZhbHVlIiwic2V0UHJvcGVydHkiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJkZWZhdWx0S2V5ZnJhbWVSZXNvbHZlciIsImZpbmFsIiwiZGVmYXVsdERyb3BBbmltYXRpb25Db25maWd1cmF0aW9uIiwiZHVyYXRpb24iLCJlYXNpbmciLCJrZXlmcmFtZXMiLCJzaWRlRWZmZWN0cyIsIm9wYWNpdHkiLCJ1c2VEcm9wQW5pbWF0aW9uIiwiYWN0aXZlRHJhZ2dhYmxlIiwibWVhc3VyYWJsZU5vZGUiLCJjcmVhdGVEZWZhdWx0RHJvcEFuaW1hdGlvbiIsInJlc3QiLCJzY2FsZSIsImZpbmFsVHJhbnNmb3JtIiwiYW5pbWF0aW9uS2V5ZnJhbWVzIiwiZmlyc3RLZXlmcmFtZSIsImxhc3RLZXlmcmFtZSIsImFuaW1hdGUiLCJmaWxsIiwib25maW5pc2giLCJ1c2VLZXkiLCJEcmFnT3ZlcmxheSIsImRyb3BBbmltYXRpb24iLCJkcm9wQW5pbWF0aW9uQ29uZmlnIiwid3JhcHBlckVsZW1lbnQiLCJ6SW5kZXgiLCJtb2RpZmllZFRyYW5zZm9ybSIsImRlZmF1bHREcm9wQW5pbWF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dnd-kit/core/dist/core.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dnd-kit/utilities/dist/utilities.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@dnd-kit/utilities/dist/utilities.esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSS: function() { return /* binding */ CSS; },\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   canUseDOM: function() { return /* binding */ canUseDOM; },\n/* harmony export */   findFirstFocusableNode: function() { return /* binding */ findFirstFocusableNode; },\n/* harmony export */   getEventCoordinates: function() { return /* binding */ getEventCoordinates; },\n/* harmony export */   getOwnerDocument: function() { return /* binding */ getOwnerDocument; },\n/* harmony export */   getWindow: function() { return /* binding */ getWindow; },\n/* harmony export */   hasViewportRelativeCoordinates: function() { return /* binding */ hasViewportRelativeCoordinates; },\n/* harmony export */   isDocument: function() { return /* binding */ isDocument; },\n/* harmony export */   isHTMLElement: function() { return /* binding */ isHTMLElement; },\n/* harmony export */   isKeyboardEvent: function() { return /* binding */ isKeyboardEvent; },\n/* harmony export */   isNode: function() { return /* binding */ isNode; },\n/* harmony export */   isSVGElement: function() { return /* binding */ isSVGElement; },\n/* harmony export */   isTouchEvent: function() { return /* binding */ isTouchEvent; },\n/* harmony export */   isWindow: function() { return /* binding */ isWindow; },\n/* harmony export */   subtract: function() { return /* binding */ subtract; },\n/* harmony export */   useCombinedRefs: function() { return /* binding */ useCombinedRefs; },\n/* harmony export */   useEvent: function() { return /* binding */ useEvent; },\n/* harmony export */   useInterval: function() { return /* binding */ useInterval; },\n/* harmony export */   useIsomorphicLayoutEffect: function() { return /* binding */ useIsomorphicLayoutEffect; },\n/* harmony export */   useLatestValue: function() { return /* binding */ useLatestValue; },\n/* harmony export */   useLazyMemo: function() { return /* binding */ useLazyMemo; },\n/* harmony export */   useNodeRef: function() { return /* binding */ useNodeRef; },\n/* harmony export */   usePrevious: function() { return /* binding */ usePrevious; },\n/* harmony export */   useUniqueId: function() { return /* binding */ useUniqueId; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$();\n\nfunction useCombinedRefs() {\n    _s();\n    for(var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++){\n        refs[_key] = arguments[_key];\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(node)=>{\n            refs.forEach((ref)=>ref(node));\n        }, refs);\n}\n_s(useCombinedRefs, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nconst canUseDOM =  true && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nfunction isWindow(element) {\n    const elementString = Object.prototype.toString.call(element);\n    return elementString === \"[object Window]\" || // In Electron context the Window object serializes to [object global]\n    elementString === \"[object global]\";\n}\nfunction isNode(node) {\n    return \"nodeType\" in node;\n}\nfunction getWindow(target) {\n    var _target$ownerDocument, _target$ownerDocument2;\n    if (!target) {\n        return window;\n    }\n    if (isWindow(target)) {\n        return target;\n    }\n    if (!isNode(target)) {\n        return window;\n    }\n    return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;\n}\nfunction isDocument(node) {\n    const { Document } = getWindow(node);\n    return node instanceof Document;\n}\nfunction isHTMLElement(node) {\n    if (isWindow(node)) {\n        return false;\n    }\n    return node instanceof getWindow(node).HTMLElement;\n}\nfunction isSVGElement(node) {\n    return node instanceof getWindow(node).SVGElement;\n}\nfunction getOwnerDocument(target) {\n    if (!target) {\n        return document;\n    }\n    if (isWindow(target)) {\n        return target.document;\n    }\n    if (!isNode(target)) {\n        return document;\n    }\n    if (isDocument(target)) {\n        return target;\n    }\n    if (isHTMLElement(target) || isSVGElement(target)) {\n        return target.ownerDocument;\n    }\n    return document;\n}\n/**\r\n * A hook that resolves to useEffect on the server and useLayoutEffect on the client\r\n * @param callback {function} Callback function that is invoked when the dependencies of the hook change\r\n */ const useIsomorphicLayoutEffect = canUseDOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useEvent(handler) {\n    _s1();\n    const handlerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(handler);\n    useIsomorphicLayoutEffect(()=>{\n        handlerRef.current = handler;\n    });\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return handlerRef.current == null ? void 0 : handlerRef.current(...args);\n    }, []);\n}\n_s1(useEvent, \"2e4mWFGs6ND6cC3YF9LkPxrS3HI=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect\n    ];\n});\nfunction useInterval() {\n    _s2();\n    const intervalRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const set = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((listener, duration)=>{\n        intervalRef.current = setInterval(listener, duration);\n    }, []);\n    const clear = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (intervalRef.current !== null) {\n            clearInterval(intervalRef.current);\n            intervalRef.current = null;\n        }\n    }, []);\n    return [\n        set,\n        clear\n    ];\n}\n_s2(useInterval, \"85i/16M+Hkn3YV6I4ugnqmI7xbU=\");\nfunction useLatestValue(value, dependencies) {\n    _s3();\n    if (dependencies === void 0) {\n        dependencies = [\n            value\n        ];\n    }\n    const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    useIsomorphicLayoutEffect(()=>{\n        if (valueRef.current !== value) {\n            valueRef.current = value;\n        }\n    }, dependencies);\n    return valueRef;\n}\n_s3(useLatestValue, \"OrVZwD3EJ2ypPqUvU/Yar7oUs5w=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect\n    ];\n});\nfunction useLazyMemo(callback, dependencies) {\n    _s4();\n    const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const newValue = callback(valueRef.current);\n        valueRef.current = newValue;\n        return newValue;\n    }, [\n        ...dependencies\n    ]);\n}\n_s4(useLazyMemo, \"TBks6PApHAZpB4SBwCvBoTHGDhI=\");\nfunction useNodeRef(onChange) {\n    _s5();\n    const onChangeHandler = useEvent(onChange);\n    const node = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setNodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((element)=>{\n        if (element !== node.current) {\n            onChangeHandler == null ? void 0 : onChangeHandler(element, node.current);\n        }\n        node.current = element;\n    }, []);\n    return [\n        node,\n        setNodeRef\n    ];\n}\n_s5(useNodeRef, \"ubCe8D/nA8p/vlEaiRPFaks+B04=\", false, function() {\n    return [\n        useEvent\n    ];\n});\nfunction usePrevious(value) {\n    _s6();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref.current;\n}\n_s6(usePrevious, \"8uVE59eA/r6b92xF80p7sH8rXLk=\");\nlet ids = {};\nfunction useUniqueId(prefix, value) {\n    _s7();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (value) {\n            return value;\n        }\n        const id = ids[prefix] == null ? 0 : ids[prefix] + 1;\n        ids[prefix] = id;\n        return prefix + \"-\" + id;\n    }, [\n        prefix,\n        value\n    ]);\n}\n_s7(useUniqueId, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nfunction createAdjustmentFn(modifier) {\n    return function(object) {\n        for(var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            adjustments[_key - 1] = arguments[_key];\n        }\n        return adjustments.reduce((accumulator, adjustment)=>{\n            const entries = Object.entries(adjustment);\n            for (const [key, valueAdjustment] of entries){\n                const value = accumulator[key];\n                if (value != null) {\n                    accumulator[key] = value + modifier * valueAdjustment;\n                }\n            }\n            return accumulator;\n        }, {\n            ...object\n        });\n    };\n}\nconst add = /*#__PURE__*/ createAdjustmentFn(1);\nconst subtract = /*#__PURE__*/ createAdjustmentFn(-1);\nfunction hasViewportRelativeCoordinates(event) {\n    return \"clientX\" in event && \"clientY\" in event;\n}\nfunction isKeyboardEvent(event) {\n    if (!event) {\n        return false;\n    }\n    const { KeyboardEvent } = getWindow(event.target);\n    return KeyboardEvent && event instanceof KeyboardEvent;\n}\nfunction isTouchEvent(event) {\n    if (!event) {\n        return false;\n    }\n    const { TouchEvent } = getWindow(event.target);\n    return TouchEvent && event instanceof TouchEvent;\n}\n/**\r\n * Returns the normalized x and y coordinates for mouse and touch events.\r\n */ function getEventCoordinates(event) {\n    if (isTouchEvent(event)) {\n        if (event.touches && event.touches.length) {\n            const { clientX: x, clientY: y } = event.touches[0];\n            return {\n                x,\n                y\n            };\n        } else if (event.changedTouches && event.changedTouches.length) {\n            const { clientX: x, clientY: y } = event.changedTouches[0];\n            return {\n                x,\n                y\n            };\n        }\n    }\n    if (hasViewportRelativeCoordinates(event)) {\n        return {\n            x: event.clientX,\n            y: event.clientY\n        };\n    }\n    return null;\n}\nconst CSS = /*#__PURE__*/ Object.freeze({\n    Translate: {\n        toString (transform) {\n            if (!transform) {\n                return;\n            }\n            const { x, y } = transform;\n            return \"translate3d(\" + (x ? Math.round(x) : 0) + \"px, \" + (y ? Math.round(y) : 0) + \"px, 0)\";\n        }\n    },\n    Scale: {\n        toString (transform) {\n            if (!transform) {\n                return;\n            }\n            const { scaleX, scaleY } = transform;\n            return \"scaleX(\" + scaleX + \") scaleY(\" + scaleY + \")\";\n        }\n    },\n    Transform: {\n        toString (transform) {\n            if (!transform) {\n                return;\n            }\n            return [\n                CSS.Translate.toString(transform),\n                CSS.Scale.toString(transform)\n            ].join(\" \");\n        }\n    },\n    Transition: {\n        toString (_ref) {\n            let { property, duration, easing } = _ref;\n            return property + \" \" + duration + \"ms \" + easing;\n        }\n    }\n});\nconst SELECTOR = \"a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]\";\nfunction findFirstFocusableNode(element) {\n    if (element.matches(SELECTOR)) {\n        return element;\n    }\n    return element.querySelector(SELECTOR);\n}\n //# sourceMappingURL=utilities.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZG5kLWtpdC91dGlsaXRpZXMvZGlzdC91dGlsaXRpZXMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUY7QUFFakYsU0FBU0s7O0lBQ1AsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBT0ssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO1FBQ3ZGRixJQUFJLENBQUNFLEtBQUssR0FBR0osU0FBUyxDQUFDSSxLQUFLO0lBQzlCO0lBRUEsT0FBT1gsOENBQU9BLENBQUMsSUFBTVksQ0FBQUE7WUFDbkJILEtBQUtJLE9BQU8sQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSUY7UUFDMUIsR0FDQUg7QUFDRjtHQVRTSjtBQVdULHdGQUF3RjtBQUN4RixNQUFNVSxZQUFZLEtBQWtCLElBQWUsT0FBT0MsT0FBT0MsUUFBUSxLQUFLLGVBQWUsT0FBT0QsT0FBT0MsUUFBUSxDQUFDQyxhQUFhLEtBQUs7QUFFdEksU0FBU0MsU0FBU0MsT0FBTztJQUN2QixNQUFNQyxnQkFBZ0JDLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNMO0lBQ3JELE9BQU9DLGtCQUFrQixxQkFBcUIsc0VBQXNFO0lBQ3BIQSxrQkFBa0I7QUFDcEI7QUFFQSxTQUFTSyxPQUFPZCxJQUFJO0lBQ2xCLE9BQU8sY0FBY0E7QUFDdkI7QUFFQSxTQUFTZSxVQUFVQyxNQUFNO0lBQ3ZCLElBQUlDLHVCQUF1QkM7SUFFM0IsSUFBSSxDQUFDRixRQUFRO1FBQ1gsT0FBT1o7SUFDVDtJQUVBLElBQUlHLFNBQVNTLFNBQVM7UUFDcEIsT0FBT0E7SUFDVDtJQUVBLElBQUksQ0FBQ0YsT0FBT0UsU0FBUztRQUNuQixPQUFPWjtJQUNUO0lBRUEsT0FBTyxDQUFDYSx3QkFBd0IsQ0FBQ0MseUJBQXlCRixPQUFPRyxhQUFhLEtBQUssT0FB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QUFRLENBQUMwRTthQUFXLENBQUNPLElBQUksQ0FBQztRQUNqRjtJQUVGO0lBQ0FDLFlBQVk7UUFDVmxGLFVBQVNtRixJQUFJO1lBQ1gsSUFBSSxFQUNGQyxRQUFRLEVBQ1IxRCxRQUFRLEVBQ1IyRCxNQUFNLEVBQ1AsR0FBR0Y7WUFDSixPQUFPQyxXQUFXLE1BQU0xRCxXQUFXLFFBQVEyRDtRQUM3QztJQUVGO0FBQ0Y7QUFFQSxNQUFNQyxXQUFXO0FBQ2pCLFNBQVNDLHVCQUF1QjNGLE9BQU87SUFDckMsSUFBSUEsUUFBUTRGLE9BQU8sQ0FBQ0YsV0FBVztRQUM3QixPQUFPMUY7SUFDVDtJQUVBLE9BQU9BLFFBQVE2RixhQUFhLENBQUNIO0FBQy9CO0FBRW1YLENBQ25YLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvdXRpbGl0aWVzL2Rpc3QvdXRpbGl0aWVzLmVzbS5qcz8yNThmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZU1lbW8sIHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiB1c2VDb21iaW5lZFJlZnMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZWZzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHJlZnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gdXNlTWVtbygoKSA9PiBub2RlID0+IHtcbiAgICByZWZzLmZvckVhY2gocmVmID0+IHJlZihub2RlKSk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgcmVmcyk7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcbmNvbnN0IGNhblVzZURPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIGlzV2luZG93KGVsZW1lbnQpIHtcbiAgY29uc3QgZWxlbWVudFN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnRTdHJpbmcgPT09ICdbb2JqZWN0IFdpbmRvd10nIHx8IC8vIEluIEVsZWN0cm9uIGNvbnRleHQgdGhlIFdpbmRvdyBvYmplY3Qgc2VyaWFsaXplcyB0byBbb2JqZWN0IGdsb2JhbF1cbiAgZWxlbWVudFN0cmluZyA9PT0gJ1tvYmplY3QgZ2xvYmFsXSc7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gIHJldHVybiAnbm9kZVR5cGUnIGluIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvdyh0YXJnZXQpIHtcbiAgdmFyIF90YXJnZXQkb3duZXJEb2N1bWVudCwgX3RhcmdldCRvd25lckRvY3VtZW50MjtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAoaXNXaW5kb3codGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBpZiAoIWlzTm9kZSh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiAoX3RhcmdldCRvd25lckRvY3VtZW50ID0gKF90YXJnZXQkb3duZXJEb2N1bWVudDIgPSB0YXJnZXQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQkb3duZXJEb2N1bWVudDIuZGVmYXVsdFZpZXcpICE9IG51bGwgPyBfdGFyZ2V0JG93bmVyRG9jdW1lbnQgOiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGlzRG9jdW1lbnQobm9kZSkge1xuICBjb25zdCB7XG4gICAgRG9jdW1lbnRcbiAgfSA9IGdldFdpbmRvdyhub2RlKTtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIGlmIChpc1dpbmRvdyhub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NWR0VsZW1lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIGdldFdpbmRvdyhub2RlKS5TVkdFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50KHRhcmdldCkge1xuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybiBkb2N1bWVudDtcbiAgfVxuXG4gIGlmIChpc1dpbmRvdyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldC5kb2N1bWVudDtcbiAgfVxuXG4gIGlmICghaXNOb2RlKHRhcmdldCkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQ7XG4gIH1cblxuICBpZiAoaXNEb2N1bWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KHRhcmdldCkgfHwgaXNTVkdFbGVtZW50KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZG9jdW1lbnQ7XG59XG5cbi8qKlxyXG4gKiBBIGhvb2sgdGhhdCByZXNvbHZlcyB0byB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciBhbmQgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBjbGllbnRcclxuICogQHBhcmFtIGNhbGxiYWNrIHtmdW5jdGlvbn0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIHdoZW4gdGhlIGRlcGVuZGVuY2llcyBvZiB0aGUgaG9vayBjaGFuZ2VcclxuICovXG5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBjYW5Vc2VET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmZ1bmN0aW9uIHVzZUV2ZW50KGhhbmRsZXIpIHtcbiAgY29uc3QgaGFuZGxlclJlZiA9IHVzZVJlZihoYW5kbGVyKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaGFuZGxlclJlZi5jdXJyZW50ID0gaGFuZGxlcjtcbiAgfSk7XG4gIHJldHVybiB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGVyUmVmLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJSZWYuY3VycmVudCguLi5hcmdzKTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VJbnRlcnZhbCgpIHtcbiAgY29uc3QgaW50ZXJ2YWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldCA9IHVzZUNhbGxiYWNrKChsaXN0ZW5lciwgZHVyYXRpb24pID0+IHtcbiAgICBpbnRlcnZhbFJlZi5jdXJyZW50ID0gc2V0SW50ZXJ2YWwobGlzdGVuZXIsIGR1cmF0aW9uKTtcbiAgfSwgW10pO1xuICBjb25zdCBjbGVhciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoaW50ZXJ2YWxSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbFJlZi5jdXJyZW50KTtcbiAgICAgIGludGVydmFsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gW3NldCwgY2xlYXJdO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RWYWx1ZSh2YWx1ZSwgZGVwZW5kZW5jaWVzKSB7XG4gIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkge1xuICAgIGRlcGVuZGVuY2llcyA9IFt2YWx1ZV07XG4gIH1cblxuICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZih2YWx1ZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ICE9PSB2YWx1ZSkge1xuICAgICAgdmFsdWVSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgfSwgZGVwZW5kZW5jaWVzKTtcbiAgcmV0dXJuIHZhbHVlUmVmO1xufVxuXG5mdW5jdGlvbiB1c2VMYXp5TWVtbyhjYWxsYmFjaywgZGVwZW5kZW5jaWVzKSB7XG4gIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmKCk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IGNhbGxiYWNrKHZhbHVlUmVmLmN1cnJlbnQpO1xuICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXdWYWx1ZTtcbiAgICByZXR1cm4gbmV3VmFsdWU7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgWy4uLmRlcGVuZGVuY2llc10pO1xufVxuXG5mdW5jdGlvbiB1c2VOb2RlUmVmKG9uQ2hhbmdlKSB7XG4gIGNvbnN0IG9uQ2hhbmdlSGFuZGxlciA9IHVzZUV2ZW50KG9uQ2hhbmdlKTtcbiAgY29uc3Qgbm9kZSA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2V0Tm9kZVJlZiA9IHVzZUNhbGxiYWNrKGVsZW1lbnQgPT4ge1xuICAgIGlmIChlbGVtZW50ICE9PSBub2RlLmN1cnJlbnQpIHtcbiAgICAgIG9uQ2hhbmdlSGFuZGxlciA9PSBudWxsID8gdm9pZCAwIDogb25DaGFuZ2VIYW5kbGVyKGVsZW1lbnQsIG5vZGUuY3VycmVudCk7XG4gICAgfVxuXG4gICAgbm9kZS5jdXJyZW50ID0gZWxlbWVudDtcbiAgfSwgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgW10pO1xuICByZXR1cm4gW25vZGUsIHNldE5vZGVSZWZdO1xufVxuXG5mdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICBjb25zdCByZWYgPSB1c2VSZWYoKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG5sZXQgaWRzID0ge307XG5mdW5jdGlvbiB1c2VVbmlxdWVJZChwcmVmaXgsIHZhbHVlKSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGlkc1twcmVmaXhdID09IG51bGwgPyAwIDogaWRzW3ByZWZpeF0gKyAxO1xuICAgIGlkc1twcmVmaXhdID0gaWQ7XG4gICAgcmV0dXJuIHByZWZpeCArIFwiLVwiICsgaWQ7XG4gIH0sIFtwcmVmaXgsIHZhbHVlXSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFkanVzdG1lbnRGbihtb2RpZmllcikge1xuICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhZGp1c3RtZW50cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhZGp1c3RtZW50c1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkanVzdG1lbnRzLnJlZHVjZSgoYWNjdW11bGF0b3IsIGFkanVzdG1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhZGp1c3RtZW50KTtcblxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZUFkanVzdG1lbnRdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhY2N1bXVsYXRvcltrZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlICsgbW9kaWZpZXIgKiB2YWx1ZUFkanVzdG1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH0sIHsgLi4ub2JqZWN0XG4gICAgfSk7XG4gIH07XG59XG5cbmNvbnN0IGFkZCA9IC8qI19fUFVSRV9fKi9jcmVhdGVBZGp1c3RtZW50Rm4oMSk7XG5jb25zdCBzdWJ0cmFjdCA9IC8qI19fUFVSRV9fKi9jcmVhdGVBZGp1c3RtZW50Rm4oLTEpO1xuXG5mdW5jdGlvbiBoYXNWaWV3cG9ydFJlbGF0aXZlQ29vcmRpbmF0ZXMoZXZlbnQpIHtcbiAgcmV0dXJuICdjbGllbnRYJyBpbiBldmVudCAmJiAnY2xpZW50WScgaW4gZXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzS2V5Ym9hcmRFdmVudChldmVudCkge1xuICBpZiAoIWV2ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIEtleWJvYXJkRXZlbnRcbiAgfSA9IGdldFdpbmRvdyhldmVudC50YXJnZXQpO1xuICByZXR1cm4gS2V5Ym9hcmRFdmVudCAmJiBldmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzVG91Y2hFdmVudChldmVudCkge1xuICBpZiAoIWV2ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIFRvdWNoRXZlbnRcbiAgfSA9IGdldFdpbmRvdyhldmVudC50YXJnZXQpO1xuICByZXR1cm4gVG91Y2hFdmVudCAmJiBldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQ7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIHggYW5kIHkgY29vcmRpbmF0ZXMgZm9yIG1vdXNlIGFuZCB0b3VjaCBldmVudHMuXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudENvb3JkaW5hdGVzKGV2ZW50KSB7XG4gIGlmIChpc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgaWYgKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WDogeCxcbiAgICAgICAgY2xpZW50WTogeVxuICAgICAgfSA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFg6IHgsXG4gICAgICAgIGNsaWVudFk6IHlcbiAgICAgIH0gPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc1ZpZXdwb3J0UmVsYXRpdmVDb29yZGluYXRlcyhldmVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IENTUyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgVHJhbnNsYXRlOiB7XG4gICAgdG9TdHJpbmcodHJhbnNmb3JtKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRyYW5zZm9ybTtcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKFwiICsgKHggPyBNYXRoLnJvdW5kKHgpIDogMCkgKyBcInB4LCBcIiArICh5ID8gTWF0aC5yb3VuZCh5KSA6IDApICsgXCJweCwgMClcIjtcbiAgICB9XG5cbiAgfSxcbiAgU2NhbGU6IHtcbiAgICB0b1N0cmluZyh0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBzY2FsZVgsXG4gICAgICAgIHNjYWxlWVxuICAgICAgfSA9IHRyYW5zZm9ybTtcbiAgICAgIHJldHVybiBcInNjYWxlWChcIiArIHNjYWxlWCArIFwiKSBzY2FsZVkoXCIgKyBzY2FsZVkgKyBcIilcIjtcbiAgICB9XG5cbiAgfSxcbiAgVHJhbnNmb3JtOiB7XG4gICAgdG9TdHJpbmcodHJhbnNmb3JtKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbQ1NTLlRyYW5zbGF0ZS50b1N0cmluZyh0cmFuc2Zvcm0pLCBDU1MuU2NhbGUudG9TdHJpbmcodHJhbnNmb3JtKV0uam9pbignICcpO1xuICAgIH1cblxuICB9LFxuICBUcmFuc2l0aW9uOiB7XG4gICAgdG9TdHJpbmcoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcHJvcGVydHksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmdcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIHByb3BlcnR5ICsgXCIgXCIgKyBkdXJhdGlvbiArIFwibXMgXCIgKyBlYXNpbmc7XG4gICAgfVxuXG4gIH1cbn0pO1xuXG5jb25zdCBTRUxFQ1RPUiA9ICdhLGZyYW1lLGlmcmFtZSxpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSk6bm90KDpkaXNhYmxlZCksc2VsZWN0Om5vdCg6ZGlzYWJsZWQpLHRleHRhcmVhOm5vdCg6ZGlzYWJsZWQpLGJ1dHRvbjpub3QoOmRpc2FibGVkKSwqW3RhYmluZGV4XSc7XG5mdW5jdGlvbiBmaW5kRmlyc3RGb2N1c2FibGVOb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubWF0Y2hlcyhTRUxFQ1RPUikpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1IpO1xufVxuXG5leHBvcnQgeyBDU1MsIGFkZCwgY2FuVXNlRE9NLCBmaW5kRmlyc3RGb2N1c2FibGVOb2RlLCBnZXRFdmVudENvb3JkaW5hdGVzLCBnZXRPd25lckRvY3VtZW50LCBnZXRXaW5kb3csIGhhc1ZpZXdwb3J0UmVsYXRpdmVDb29yZGluYXRlcywgaXNEb2N1bWVudCwgaXNIVE1MRWxlbWVudCwgaXNLZXlib2FyZEV2ZW50LCBpc05vZGUsIGlzU1ZHRWxlbWVudCwgaXNUb3VjaEV2ZW50LCBpc1dpbmRvdywgc3VidHJhY3QsIHVzZUNvbWJpbmVkUmVmcywgdXNlRXZlbnQsIHVzZUludGVydmFsLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCB1c2VMYXRlc3RWYWx1ZSwgdXNlTGF6eU1lbW8sIHVzZU5vZGVSZWYsIHVzZVByZXZpb3VzLCB1c2VVbmlxdWVJZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbGl0aWVzLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VNZW1vIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VDb21iaW5lZFJlZnMiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwicmVmcyIsIkFycmF5IiwiX2tleSIsIm5vZGUiLCJmb3JFYWNoIiwicmVmIiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNXaW5kb3ciLCJlbGVtZW50IiwiZWxlbWVudFN0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImlzTm9kZSIsImdldFdpbmRvdyIsInRhcmdldCIsIl90YXJnZXQkb3duZXJEb2N1bWVudCIsIl90YXJnZXQkb3duZXJEb2N1bWVudDIiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0RvY3VtZW50IiwiRG9jdW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1NWR0VsZW1lbnQiLCJTVkdFbGVtZW50IiwiZ2V0T3duZXJEb2N1bWVudCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ1c2VFdmVudCIsImhhbmRsZXIiLCJoYW5kbGVyUmVmIiwiY3VycmVudCIsImFyZ3MiLCJ1c2VJbnRlcnZhbCIsImludGVydmFsUmVmIiwic2V0IiwibGlzdGVuZXIiLCJkdXJhdGlvbiIsInNldEludGVydmFsIiwiY2xlYXIiLCJjbGVhckludGVydmFsIiwidXNlTGF0ZXN0VmFsdWUiLCJ2YWx1ZSIsImRlcGVuZGVuY2llcyIsInZhbHVlUmVmIiwidXNlTGF6eU1lbW8iLCJjYWxsYmFjayIsIm5ld1ZhbHVlIiwidXNlTm9kZVJlZiIsIm9uQ2hhbmdlIiwib25DaGFuZ2VIYW5kbGVyIiwic2V0Tm9kZVJlZiIsInVzZVByZXZpb3VzIiwiaWRzIiwidXNlVW5pcXVlSWQiLCJwcmVmaXgiLCJpZCIsImNyZWF0ZUFkanVzdG1lbnRGbiIsIm1vZGlmaWVyIiwib2JqZWN0IiwiYWRqdXN0bWVudHMiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciIsImFkanVzdG1lbnQiLCJlbnRyaWVzIiwia2V5IiwidmFsdWVBZGp1c3RtZW50IiwiYWRkIiwic3VidHJhY3QiLCJoYXNWaWV3cG9ydFJlbGF0aXZlQ29vcmRpbmF0ZXMiLCJldmVudCIsImlzS2V5Ym9hcmRFdmVudCIsIktleWJvYXJkRXZlbnQiLCJpc1RvdWNoRXZlbnQiLCJUb3VjaEV2ZW50IiwiZ2V0RXZlbnRDb29yZGluYXRlcyIsInRvdWNoZXMiLCJjbGllbnRYIiwieCIsImNsaWVudFkiLCJ5IiwiY2hhbmdlZFRvdWNoZXMiLCJDU1MiLCJmcmVlemUiLCJUcmFuc2xhdGUiLCJ0cmFuc2Zvcm0iLCJNYXRoIiwicm91bmQiLCJTY2FsZSIsInNjYWxlWCIsInNjYWxlWSIsIlRyYW5zZm9ybSIsImpvaW4iLCJUcmFuc2l0aW9uIiwiX3JlZiIsInByb3BlcnR5IiwiZWFzaW5nIiwiU0VMRUNUT1IiLCJmaW5kRmlyc3RGb2N1c2FibGVOb2RlIiwibWF0Y2hlcyIsInF1ZXJ5U2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dnd-kit/utilities/dist/utilities.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./api/card.ts":
/*!*********************!*\
  !*** ./api/card.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getProducts: function() { return /* binding */ getProducts; }\n/* harmony export */ });\nconst getProducts = async ()=>{\n    try {\n        const response = await fetch(\"/mocks/product.json\");\n        if (!response.ok) {\n            throw new Error(\"Network response was not ok\");\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching data:\", error);\n        return null;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwaS9jYXJkLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxjQUFjO0lBQ3ZCLElBQUk7UUFDQSxNQUFNQyxXQUFXLE1BQU1DLE1BQU07UUFDN0IsSUFBSSxDQUFDRCxTQUFTRSxFQUFFLEVBQUU7WUFDZCxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxNQUFNQyxPQUFPLE1BQU1KLFNBQVNLLElBQUk7UUFDaEMsT0FBT0Q7SUFDWCxFQUFFLE9BQU9FLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLHdCQUF3QkE7UUFDdEMsT0FBTztJQUNYO0FBQ0osRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcGkvY2FyZC50cz82YTEyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBnZXRQcm9kdWN0cyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvbW9ja3MvcHJvZHVjdC5qc29uJyk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayByZXNwb25zZSB3YXMgbm90IG9rJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZGF0YTonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07Il0sIm5hbWVzIjpbImdldFByb2R1Y3RzIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJkYXRhIiwianNvbiIsImVycm9yIiwiY29uc29sZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./api/card.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/[id]/page.tsx":
/*!***************************!*\
  !*** ./app/[id]/page.tsx ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _components_home_home__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/home/home */ \"(app-pages-browser)/./components/home/home.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nconst Page = (param)=>{\n    let { params } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_home_home__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n        params: params\n    }, void 0, false, {\n        fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/app/[id]/page.tsx\",\n        lineNumber: 11,\n        columnNumber: 10\n    }, undefined);\n};\n_c = Page;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Page);\nvar _c;\n$RefreshReg$(_c, \"Page\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9baWRdL3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7QUFHMEM7QUFNMUMsTUFBTUMsT0FBd0I7UUFBQyxFQUFFQyxNQUFNLEVBQUU7SUFDdkMscUJBQU8sOERBQUNGLDZEQUFJQTtRQUFDRSxRQUFRQTs7Ozs7O0FBQ3ZCO0tBRk1EO0FBSU4sK0RBQWVBLElBQUlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL1tpZF0vcGFnZS50c3g/Njc1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgTmV4dFBhZ2UgfSBmcm9tIFwibmV4dFwiO1xuaW1wb3J0IEhvbWUgZnJvbSBcIkAvY29tcG9uZW50cy9ob21lL2hvbWVcIjtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcGFyYW1zOiB7IGlkOiBzdHJpbmcgfTtcbn1cblxuY29uc3QgUGFnZTogTmV4dFBhZ2U8UHJvcHM+ID0gKHsgcGFyYW1zIH0pID0+IHtcbiAgcmV0dXJuIDxIb21lIHBhcmFtcz17cGFyYW1zfSAvPjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFBhZ2U7XG4iXSwibmFtZXMiOlsiSG9tZSIsIlBhZ2UiLCJwYXJhbXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/[id]/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/checkbox/checkbox.tsx":
/*!******************************************!*\
  !*** ./components/checkbox/checkbox.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nconst Checkbox = (param)=>{\n    let { onChange } = param;\n    _s();\n    const [_, setSelectedValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const handleCheckboxChange = (event)=>{\n        const { value } = event.target;\n        setSelectedValue(value);\n        onChange(value);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"radio-inputs\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                    className: \"radio\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            className: \"mr-2\",\n                            defaultChecked: true,\n                            type: \"radio\",\n                            id: \"centro\",\n                            name: \"alineacion\",\n                            value: \"center\",\n                            onChange: handleCheckboxChange\n                        }, void 0, false, {\n                            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/checkbox/checkbox.tsx\",\n                            lineNumber: 20,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"name\",\n                            children: \"Center\"\n                        }, void 0, false, {\n                            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/checkbox/checkbox.tsx\",\n                            lineNumber: 29,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/checkbox/checkbox.tsx\",\n                    lineNumber: 19,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                    className: \"radio\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            className: \"mr-2\",\n                            type: \"radio\",\n                            id: \"derecha\",\n                            name: \"alineacion\",\n                            value: \"end\",\n                            onChange: handleCheckboxChange\n                        }, void 0, false, {\n                            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/checkbox/checkbox.tsx\",\n                            lineNumber: 32,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"name\",\n                            children: \"Right\"\n                        }, void 0, false, {\n                            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/checkbox/checkbox.tsx\",\n                            lineNumber: 40,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/checkbox/checkbox.tsx\",\n                    lineNumber: 31,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                    className: \"radio\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            className: \"mr-2\",\n                            type: \"radio\",\n                            id: \"izquierda\",\n                            name: \"alineacion\",\n                            value: \"start\",\n                            onChange: handleCheckboxChange\n                        }, void 0, false, {\n                            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/checkbox/checkbox.tsx\",\n                            lineNumber: 44,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"name\",\n                            children: \"Left\"\n                        }, void 0, false, {\n                            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/checkbox/checkbox.tsx\",\n                            lineNumber: 52,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/checkbox/checkbox.tsx\",\n                    lineNumber: 43,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/checkbox/checkbox.tsx\",\n            lineNumber: 18,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/checkbox/checkbox.tsx\",\n        lineNumber: 17,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Checkbox, \"1+G+TllS3XIZOeXl0afJXRSbyFc=\");\n_c = Checkbox;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Checkbox);\nvar _c;\n$RefreshReg$(_c, \"Checkbox\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvY2hlY2tib3gvY2hlY2tib3gudHN4IiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3QztBQU14QyxNQUFNRSxXQUE0QjtRQUFDLEVBQUVDLFFBQVEsRUFBRTs7SUFDN0MsTUFBTSxDQUFDQyxHQUFHQyxpQkFBaUIsR0FBR0osK0NBQVFBLENBQVM7SUFFL0MsTUFBTUssdUJBQXVCLENBQUNDO1FBQzVCLE1BQU0sRUFBRUMsS0FBSyxFQUFFLEdBQUdELE1BQU1FLE1BQU07UUFDOUJKLGlCQUFpQkc7UUFDakJMLFNBQVNLO0lBQ1g7SUFFQSxxQkFDRSw4REFBQ0U7UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ0Q7WUFBSUMsV0FBVTs7OEJBQ2IsOERBQUNDO29CQUFNRCxXQUFVOztzQ0FDZiw4REFBQ0U7NEJBQ0NGLFdBQVU7NEJBQ1ZHLGNBQWM7NEJBQ2RDLE1BQUs7NEJBQ0xDLElBQUc7NEJBQ0hDLE1BQUs7NEJBQ0xULE9BQU07NEJBQ05MLFVBQVVHOzs7Ozs7c0NBRVosOERBQUNZOzRCQUFLUCxXQUFVO3NDQUFPOzs7Ozs7Ozs7Ozs7OEJBRXpCLDhEQUFDQztvQkFBTUQsV0FBVTs7c0NBQ2YsOERBQUNFOzRCQUNDRixXQUFVOzRCQUNWSSxNQUFLOzRCQUNMQyxJQUFHOzRCQUNIQyxNQUFLOzRCQUNMVCxPQUFNOzRCQUNOTCxVQUFVRzs7Ozs7O3NDQUVaLDhEQUFDWTs0QkFBS1AsV0FBVTtzQ0FBTzs7Ozs7Ozs7Ozs7OzhCQUd6Qiw4REFBQ0M7b0JBQU1ELFdBQVU7O3NDQUNmLDhEQUFDRTs0QkFDQ0YsV0FBVTs0QkFDVkksTUFBSzs0QkFDTEMsSUFBRzs0QkFDSEMsTUFBSzs0QkFDTFQsT0FBTTs0QkFDTkwsVUFBVUc7Ozs7OztzQ0FFWiw4REFBQ1k7NEJBQUtQLFdBQVU7c0NBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS2pDO0dBbERNVDtLQUFBQTtBQW9ETiwrREFBZUEsUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2NoZWNrYm94L2NoZWNrYm94LnRzeD9mMmFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBvbkNoYW5nZTogKHZhbHVlOiBzdHJpbmcpID0+IHZvaWQ7XG59XG5cbmNvbnN0IENoZWNrYm94OiBSZWFjdC5GQzxQcm9wcz4gPSAoeyBvbkNoYW5nZSB9KSA9PiB7XG4gIGNvbnN0IFtfLCBzZXRTZWxlY3RlZFZhbHVlXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG5cbiAgY29uc3QgaGFuZGxlQ2hlY2tib3hDaGFuZ2UgPSAoZXZlbnQ6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gZXZlbnQudGFyZ2V0O1xuICAgIHNldFNlbGVjdGVkVmFsdWUodmFsdWUpO1xuICAgIG9uQ2hhbmdlKHZhbHVlKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleFwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyYWRpby1pbnB1dHNcIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cInJhZGlvXCI+XG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtci0yXCJcbiAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkXG4gICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgICAgaWQ9XCJjZW50cm9cIlxuICAgICAgICAgICAgbmFtZT1cImFsaW5lYWNpb25cIlxuICAgICAgICAgICAgdmFsdWU9XCJjZW50ZXJcIlxuICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoZWNrYm94Q2hhbmdlfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibmFtZVwiPkNlbnRlcjwvc3Bhbj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cInJhZGlvXCI+XG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtci0yXCJcbiAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICBpZD1cImRlcmVjaGFcIlxuICAgICAgICAgICAgbmFtZT1cImFsaW5lYWNpb25cIlxuICAgICAgICAgICAgdmFsdWU9XCJlbmRcIlxuICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoZWNrYm94Q2hhbmdlfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibmFtZVwiPlJpZ2h0PC9zcGFuPlxuICAgICAgICA8L2xhYmVsPlxuXG4gICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJyYWRpb1wiPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibXItMlwiXG4gICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgICAgaWQ9XCJpenF1aWVyZGFcIlxuICAgICAgICAgICAgbmFtZT1cImFsaW5lYWNpb25cIlxuICAgICAgICAgICAgdmFsdWU9XCJzdGFydFwiXG4gICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hlY2tib3hDaGFuZ2V9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJuYW1lXCI+TGVmdDwvc3Bhbj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2hlY2tib3g7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsIkNoZWNrYm94Iiwib25DaGFuZ2UiLCJfIiwic2V0U2VsZWN0ZWRWYWx1ZSIsImhhbmRsZUNoZWNrYm94Q2hhbmdlIiwiZXZlbnQiLCJ2YWx1ZSIsInRhcmdldCIsImRpdiIsImNsYXNzTmFtZSIsImxhYmVsIiwiaW5wdXQiLCJkZWZhdWx0Q2hlY2tlZCIsInR5cGUiLCJpZCIsIm5hbWUiLCJzcGFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/checkbox/checkbox.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/home/home.tsx":
/*!**********************************!*\
  !*** ./components/home/home.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _public_mocks_product_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/public/mocks/product.json */ \"(app-pages-browser)/./public/mocks/product.json\");\n/* harmony import */ var _components_products_Products__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/products/Products */ \"(app-pages-browser)/./components/products/Products.tsx\");\n/* harmony import */ var _dnd_kit_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @dnd-kit/core */ \"(app-pages-browser)/./node_modules/@dnd-kit/core/dist/core.esm.js\");\n/* harmony import */ var _checkbox_checkbox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../checkbox/checkbox */ \"(app-pages-browser)/./components/checkbox/checkbox.tsx\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\nconst Home = (param)=>{\n    let { params } = param;\n    _s();\n    const numProducts = Number(params.id);\n    const numContainers = Math.ceil(numProducts / 3);\n    const [containerPositions, setContainerPositions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Array.from({\n        length: numContainers\n    }, (_, index)=>({\n            position: index + 1,\n            alignment: \"\"\n        })));\n    const handleDragEnd = (event)=>{\n        const { active, over } = event;\n        if (!over) return;\n        const sourceIndex = Number(active.id);\n        const destinationIndex = Number(over.id);\n        if (sourceIndex === destinationIndex) return;\n        const newPosition = [\n            ...containerPositions\n        ];\n        const movedContainer = newPosition.splice(sourceIndex, 1)[0];\n        newPosition.splice(destinationIndex, 0, movedContainer);\n        setContainerPositions(newPosition);\n    };\n    const handleAlignmentChange = (value, index)=>{\n        setContainerPositions((prevPositions)=>prevPositions.map((container, idx)=>idx === index ? {\n                    ...container,\n                    alignment: value\n                } : container));\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col  justify-between\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_dnd_kit_core__WEBPACK_IMPORTED_MODULE_4__.DndContext, {\n            onDragEnd: handleDragEnd,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col justify-center\",\n                children: containerPositions.map((container, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-start justify-between\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mb-10\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mb-4 flex\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"bg-[#EEEEEE] p-3 rounded-lg\",\n                                            children: [\n                                                \"Fila \",\n                                                index + 1\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n                                            lineNumber: 55,\n                                            columnNumber: 19\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n                                        lineNumber: 54,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_checkbox_checkbox__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                        onChange: (value)=>handleAlignmentChange(value, index)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n                                        lineNumber: 59,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n                                lineNumber: 53,\n                                columnNumber: 15\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Container, {\n                                    index: index,\n                                    position: container.position,\n                                    alignment: container.alignment,\n                                    numProducts: numProducts\n                                }, void 0, false, {\n                                    fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n                                    lineNumber: 65,\n                                    columnNumber: 17\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n                                lineNumber: 64,\n                                columnNumber: 15\n                            }, undefined)\n                        ]\n                    }, index, true, {\n                        fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n                        lineNumber: 51,\n                        columnNumber: 13\n                    }, undefined))\n            }, void 0, false, {\n                fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n                lineNumber: 49,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n            lineNumber: 48,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n        lineNumber: 47,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Home, \"LDd7oTbg2LCZF5Nf4C7Cg7/NoN8=\");\n_c = Home;\nconst Container = (param)=>{\n    let { index, position, numProducts, alignment } = param;\n    _s1();\n    const { attributes, listeners, setNodeRef, transform, isDragging } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_4__.useDraggable)({\n        id: index.toString()\n    });\n    const { isOver, setNodeRef: setDropNodeRef } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_4__.useDroppable)({\n        id: index.toString()\n    });\n    const startProductIndex = (position - 1) * 3 + 1;\n    const endProductIndex = Math.min(position * 3, numProducts);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-[50rem]\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            ref: setNodeRef,\n            ...attributes,\n            ...listeners,\n            className: \"relative  bg-[#EEEEEE] p-4 m-4 cursor-grab rounded-lg w-full\".concat(isOver ? \"bg-gray-200\" : \"\", \" \").concat(isDragging ? \"opacity-50\" : \"\", \" transition-opacity duration-300\"),\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: setDropNodeRef,\n                className: \"flex flex-row justify-\".concat(alignment, \" items-center h-44 p-2\"),\n                style: {\n                    minHeight: \"200px\"\n                },\n                children: _public_mocks_product_json__WEBPACK_IMPORTED_MODULE_2__.slice(startProductIndex - 1, endProductIndex).map((product, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"m-1 md:m-10\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_products_Products__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                            id: Number(product.id)\n                        }, void 0, false, {\n                            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n                            lineNumber: 118,\n                            columnNumber: 17\n                        }, undefined)\n                    }, index, false, {\n                        fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n                        lineNumber: 117,\n                        columnNumber: 15\n                    }, undefined))\n            }, void 0, false, {\n                fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n                lineNumber: 109,\n                columnNumber: 9\n            }, undefined)\n        }, position, false, {\n            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n            lineNumber: 100,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/home/home.tsx\",\n        lineNumber: 99,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(Container, \"B29bdDOjK6hWugGKfMp2tf4R1m8=\", false, function() {\n    return [\n        _dnd_kit_core__WEBPACK_IMPORTED_MODULE_4__.useDraggable,\n        _dnd_kit_core__WEBPACK_IMPORTED_MODULE_4__.useDroppable\n    ];\n});\n_c1 = Container;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Home);\nvar _c, _c1;\n$RefreshReg$(_c, \"Home\");\n$RefreshReg$(_c1, \"Container\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaG9tZS9ob21lLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWlDO0FBQ2M7QUFDTztBQUNpQjtBQUMzQjtBQU01QyxNQUFNTyxPQUF3QjtRQUFDLEVBQUVDLE1BQU0sRUFBRTs7SUFDdkMsTUFBTUMsY0FBY0MsT0FBT0YsT0FBT0csRUFBRTtJQUNwQyxNQUFNQyxnQkFBZ0JDLEtBQUtDLElBQUksQ0FBQ0wsY0FBYztJQUM5QyxNQUFNLENBQUNNLG9CQUFvQkMsc0JBQXNCLEdBQUdoQiwrQ0FBUUEsQ0FDMURpQixNQUFNQyxJQUFJLENBQUM7UUFBRUMsUUFBUVA7SUFBYyxHQUFHLENBQUNRLEdBQUdDLFFBQVc7WUFDbkRDLFVBQVVELFFBQVE7WUFDbEJFLFdBQVc7UUFDYjtJQUdGLE1BQU1DLGdCQUFnQixDQUFDQztRQUNyQixNQUFNLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUdGO1FBRXpCLElBQUksQ0FBQ0UsTUFBTTtRQUVYLE1BQU1DLGNBQWNsQixPQUFPZ0IsT0FBT2YsRUFBRTtRQUNwQyxNQUFNa0IsbUJBQW1CbkIsT0FBT2lCLEtBQUtoQixFQUFFO1FBRXZDLElBQUlpQixnQkFBZ0JDLGtCQUFrQjtRQUV0QyxNQUFNQyxjQUFjO2VBQUlmO1NBQW1CO1FBQzNDLE1BQU1nQixpQkFBaUJELFlBQVlFLE1BQU0sQ0FBQ0osYUFBYSxFQUFFLENBQUMsRUFBRTtRQUM1REUsWUFBWUUsTUFBTSxDQUFDSCxrQkFBa0IsR0FBR0U7UUFFeENmLHNCQUFzQmM7SUFDeEI7SUFFQSxNQUFNRyx3QkFBd0IsQ0FBQ0MsT0FBZWI7UUFDNUNMLHNCQUFzQixDQUFDbUIsZ0JBQ3JCQSxjQUFjQyxHQUFHLENBQUMsQ0FBQ0MsV0FBV0MsTUFDNUJBLFFBQVFqQixRQUFRO29CQUFFLEdBQUdnQixTQUFTO29CQUFFZCxXQUFXVztnQkFBTSxJQUFJRztJQUczRDtJQUVBLHFCQUNFLDhEQUFDRTtRQUFJQyxXQUFVO2tCQUNiLDRFQUFDckMscURBQVVBO1lBQUNzQyxXQUFXakI7c0JBQ3JCLDRFQUFDZTtnQkFBSUMsV0FBVTswQkFDWnpCLG1CQUFtQnFCLEdBQUcsQ0FBQyxDQUFDQyxXQUFXaEIsc0JBQ2xDLDhEQUFDa0I7d0JBQWdCQyxXQUFVOzswQ0FFekIsOERBQUNEO2dDQUFJQyxXQUFVOztrREFDYiw4REFBQ0Q7d0NBQUlDLFdBQVU7a0RBQ2IsNEVBQUNFOzRDQUFLRixXQUFVOztnREFBOEI7Z0RBQ3RDbkIsUUFBUTs7Ozs7Ozs7Ozs7O2tEQUdsQiw4REFBQ2YsMERBQVFBO3dDQUNQcUMsVUFBVSxDQUFDVCxRQUFVRCxzQkFBc0JDLE9BQU9iOzs7Ozs7Ozs7Ozs7MENBSXRELDhEQUFDa0I7MENBQ0MsNEVBQUNLO29DQUNDdkIsT0FBT0E7b0NBQ1BDLFVBQVVlLFVBQVVmLFFBQVE7b0NBQzVCQyxXQUFXYyxVQUFVZCxTQUFTO29DQUM5QmQsYUFBYUE7Ozs7Ozs7Ozs7Ozt1QkFsQlRZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCdEI7R0FuRU1kO0tBQUFBO0FBcUVOLE1BQU1xQyxZQUtEO1FBQUMsRUFBRXZCLEtBQUssRUFBRUMsUUFBUSxFQUFFYixXQUFXLEVBQUVjLFNBQVMsRUFBRTs7SUFDL0MsTUFBTSxFQUFFc0IsVUFBVSxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsRUFBRUMsU0FBUyxFQUFFQyxVQUFVLEVBQUUsR0FDaEU3QywyREFBWUEsQ0FBQztRQUNYTyxJQUFJVSxNQUFNNkIsUUFBUTtJQUNwQjtJQUVGLE1BQU0sRUFBRUMsTUFBTSxFQUFFSixZQUFZSyxjQUFjLEVBQUUsR0FBRy9DLDJEQUFZQSxDQUFDO1FBQzFETSxJQUFJVSxNQUFNNkIsUUFBUTtJQUNwQjtJQUVBLE1BQU1HLG9CQUFvQixDQUFDL0IsV0FBVyxLQUFLLElBQUk7SUFDL0MsTUFBTWdDLGtCQUFrQnpDLEtBQUswQyxHQUFHLENBQUNqQyxXQUFXLEdBQUdiO0lBRS9DLHFCQUNFLDhEQUFDOEI7UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ0Q7WUFFQ2lCLEtBQUtUO1lBQ0osR0FBR0YsVUFBVTtZQUNiLEdBQUdDLFNBQVM7WUFDYk4sV0FBVywrREFFUFMsT0FERkUsU0FBUyxnQkFBZ0IsSUFDMUIsS0FBa0MsT0FBL0JGLGFBQWEsZUFBZSxJQUFHO3NCQUVuQyw0RUFBQ1Y7Z0JBQ0NpQixLQUFLSjtnQkFDTFosV0FBVyx5QkFBbUMsT0FBVmpCLFdBQVU7Z0JBQzlDa0MsT0FBTztvQkFBRUMsV0FBVztnQkFBUTswQkFFM0J6RCx1REFBSUEsQ0FDRjBELEtBQUssQ0FBQ04sb0JBQW9CLEdBQUdDLGlCQUM3QmxCLEdBQUcsQ0FBQyxDQUFDd0IsU0FBU3ZDLHNCQUNiLDhEQUFDa0I7d0JBQWdCQyxXQUFVO2tDQUN6Qiw0RUFBQ3RDLHFFQUFRQTs0QkFBQ1MsSUFBSUQsT0FBT2tELFFBQVFqRCxFQUFFOzs7Ozs7dUJBRHZCVTs7Ozs7Ozs7OztXQWhCWEM7Ozs7Ozs7Ozs7QUF3QmI7SUE3Q01zQjs7UUFPRnhDLHVEQUFZQTtRQUlpQ0MsdURBQVlBOzs7TUFYdkR1QztBQStDTiwrREFBZXJDLElBQUlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9ob21lL2hvbWUudHN4PzgyZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBtb2NrIGZyb20gXCJAL3B1YmxpYy9tb2Nrcy9wcm9kdWN0Lmpzb25cIjtcbmltcG9ydCBQcm9kdWN0cyBmcm9tIFwiQC9jb21wb25lbnRzL3Byb2R1Y3RzL1Byb2R1Y3RzXCI7XG5pbXBvcnQgeyBEbmRDb250ZXh0LCB1c2VEcmFnZ2FibGUsIHVzZURyb3BwYWJsZSB9IGZyb20gXCJAZG5kLWtpdC9jb3JlXCI7XG5pbXBvcnQgQ2hlY2tib3ggZnJvbSBcIi4uL2NoZWNrYm94L2NoZWNrYm94XCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gIHBhcmFtczogeyBpZDogc3RyaW5nIH07XG59XG5cbmNvbnN0IEhvbWU6IFJlYWN0LkZDPFByb3BzPiA9ICh7IHBhcmFtcyB9KSA9PiB7XG4gIGNvbnN0IG51bVByb2R1Y3RzID0gTnVtYmVyKHBhcmFtcy5pZCk7XG4gIGNvbnN0IG51bUNvbnRhaW5lcnMgPSBNYXRoLmNlaWwobnVtUHJvZHVjdHMgLyAzKTtcbiAgY29uc3QgW2NvbnRhaW5lclBvc2l0aW9ucywgc2V0Q29udGFpbmVyUG9zaXRpb25zXSA9IHVzZVN0YXRlKFxuICAgIEFycmF5LmZyb20oeyBsZW5ndGg6IG51bUNvbnRhaW5lcnMgfSwgKF8sIGluZGV4KSA9PiAoe1xuICAgICAgcG9zaXRpb246IGluZGV4ICsgMSxcbiAgICAgIGFsaWdubWVudDogXCJcIixcbiAgICB9KSlcbiAgKTtcblxuICBjb25zdCBoYW5kbGVEcmFnRW5kID0gKGV2ZW50OiBhbnkpID0+IHtcbiAgICBjb25zdCB7IGFjdGl2ZSwgb3ZlciB9ID0gZXZlbnQ7XG5cbiAgICBpZiAoIW92ZXIpIHJldHVybjtcblxuICAgIGNvbnN0IHNvdXJjZUluZGV4ID0gTnVtYmVyKGFjdGl2ZS5pZCk7XG4gICAgY29uc3QgZGVzdGluYXRpb25JbmRleCA9IE51bWJlcihvdmVyLmlkKTtcblxuICAgIGlmIChzb3VyY2VJbmRleCA9PT0gZGVzdGluYXRpb25JbmRleCkgcmV0dXJuO1xuXG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSBbLi4uY29udGFpbmVyUG9zaXRpb25zXTtcbiAgICBjb25zdCBtb3ZlZENvbnRhaW5lciA9IG5ld1Bvc2l0aW9uLnNwbGljZShzb3VyY2VJbmRleCwgMSlbMF07XG4gICAgbmV3UG9zaXRpb24uc3BsaWNlKGRlc3RpbmF0aW9uSW5kZXgsIDAsIG1vdmVkQ29udGFpbmVyKTtcblxuICAgIHNldENvbnRhaW5lclBvc2l0aW9ucyhuZXdQb3NpdGlvbik7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQWxpZ25tZW50Q2hhbmdlID0gKHZhbHVlOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBzZXRDb250YWluZXJQb3NpdGlvbnMoKHByZXZQb3NpdGlvbnMpID0+XG4gICAgICBwcmV2UG9zaXRpb25zLm1hcCgoY29udGFpbmVyLCBpZHgpID0+XG4gICAgICAgIGlkeCA9PT0gaW5kZXggPyB7IC4uLmNvbnRhaW5lciwgYWxpZ25tZW50OiB2YWx1ZSB9IDogY29udGFpbmVyXG4gICAgICApXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCAganVzdGlmeS1iZXR3ZWVuXCI+XG4gICAgICA8RG5kQ29udGV4dCBvbkRyYWdFbmQ9e2hhbmRsZURyYWdFbmR9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXJcIj5cbiAgICAgICAgICB7Y29udGFpbmVyUG9zaXRpb25zLm1hcCgoY29udGFpbmVyLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgPGRpdiBrZXk9e2luZGV4fSBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLXN0YXJ0IGp1c3RpZnktYmV0d2VlblwiPlxuICAgICAgICAgICAgICB7LyogQ29udGVuZWRvciBkZSBmaWxhICovfVxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTEwXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi00IGZsZXhcIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJnLVsjRUVFRUVFXSBwLTMgcm91bmRlZC1sZ1wiPlxuICAgICAgICAgICAgICAgICAgICBGaWxhIHtpbmRleCArIDF9XG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPENoZWNrYm94XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiBoYW5kbGVBbGlnbm1lbnRDaGFuZ2UodmFsdWUsIGluZGV4KX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgey8qIENvbnRlbmVkb3IgZGUgY29udGVuZWRvciAqL31cbiAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8Q29udGFpbmVyXG4gICAgICAgICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbj17Y29udGFpbmVyLnBvc2l0aW9ufVxuICAgICAgICAgICAgICAgICAgYWxpZ25tZW50PXtjb250YWluZXIuYWxpZ25tZW50fVxuICAgICAgICAgICAgICAgICAgbnVtUHJvZHVjdHM9e251bVByb2R1Y3RzfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9EbmRDb250ZXh0PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuY29uc3QgQ29udGFpbmVyOiBSZWFjdC5GQzx7XG4gIGluZGV4OiBudW1iZXI7XG4gIHBvc2l0aW9uOiBudW1iZXI7XG4gIG51bVByb2R1Y3RzOiBudW1iZXI7XG4gIGFsaWdubWVudDogc3RyaW5nO1xufT4gPSAoeyBpbmRleCwgcG9zaXRpb24sIG51bVByb2R1Y3RzLCBhbGlnbm1lbnQgfSkgPT4ge1xuICBjb25zdCB7IGF0dHJpYnV0ZXMsIGxpc3RlbmVycywgc2V0Tm9kZVJlZiwgdHJhbnNmb3JtLCBpc0RyYWdnaW5nIH0gPVxuICAgIHVzZURyYWdnYWJsZSh7XG4gICAgICBpZDogaW5kZXgudG9TdHJpbmcoKSxcbiAgICB9KTtcblxuICBjb25zdCB7IGlzT3Zlciwgc2V0Tm9kZVJlZjogc2V0RHJvcE5vZGVSZWYgfSA9IHVzZURyb3BwYWJsZSh7XG4gICAgaWQ6IGluZGV4LnRvU3RyaW5nKCksXG4gIH0pO1xuXG4gIGNvbnN0IHN0YXJ0UHJvZHVjdEluZGV4ID0gKHBvc2l0aW9uIC0gMSkgKiAzICsgMTtcbiAgY29uc3QgZW5kUHJvZHVjdEluZGV4ID0gTWF0aC5taW4ocG9zaXRpb24gKiAzLCBudW1Qcm9kdWN0cyk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInctWzUwcmVtXVwiPlxuICAgICAgPGRpdlxuICAgICAgICBrZXk9e3Bvc2l0aW9ufVxuICAgICAgICByZWY9e3NldE5vZGVSZWZ9XG4gICAgICAgIHsuLi5hdHRyaWJ1dGVzfVxuICAgICAgICB7Li4ubGlzdGVuZXJzfVxuICAgICAgICBjbGFzc05hbWU9e2ByZWxhdGl2ZSAgYmctWyNFRUVFRUVdIHAtNCBtLTQgY3Vyc29yLWdyYWIgcm91bmRlZC1sZyB3LWZ1bGwke1xuICAgICAgICAgIGlzT3ZlciA/IFwiYmctZ3JheS0yMDBcIiA6IFwiXCJcbiAgICAgICAgfSAke2lzRHJhZ2dpbmcgPyBcIm9wYWNpdHktNTBcIiA6IFwiXCJ9IHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi0zMDBgfVxuICAgICAgPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgcmVmPXtzZXREcm9wTm9kZVJlZn1cbiAgICAgICAgICBjbGFzc05hbWU9e2BmbGV4IGZsZXgtcm93IGp1c3RpZnktJHthbGlnbm1lbnR9IGl0ZW1zLWNlbnRlciBoLTQ0IHAtMmB9XG4gICAgICAgICAgc3R5bGU9e3sgbWluSGVpZ2h0OiBcIjIwMHB4XCIgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHttb2NrXG4gICAgICAgICAgICAuc2xpY2Uoc3RhcnRQcm9kdWN0SW5kZXggLSAxLCBlbmRQcm9kdWN0SW5kZXgpXG4gICAgICAgICAgICAubWFwKChwcm9kdWN0LCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICA8ZGl2IGtleT17aW5kZXh9IGNsYXNzTmFtZT1cIm0tMSBtZDptLTEwXCI+XG4gICAgICAgICAgICAgICAgPFByb2R1Y3RzIGlkPXtOdW1iZXIocHJvZHVjdC5pZCl9IC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBIb21lO1xuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwibW9jayIsIlByb2R1Y3RzIiwiRG5kQ29udGV4dCIsInVzZURyYWdnYWJsZSIsInVzZURyb3BwYWJsZSIsIkNoZWNrYm94IiwiSG9tZSIsInBhcmFtcyIsIm51bVByb2R1Y3RzIiwiTnVtYmVyIiwiaWQiLCJudW1Db250YWluZXJzIiwiTWF0aCIsImNlaWwiLCJjb250YWluZXJQb3NpdGlvbnMiLCJzZXRDb250YWluZXJQb3NpdGlvbnMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaW5kZXgiLCJwb3NpdGlvbiIsImFsaWdubWVudCIsImhhbmRsZURyYWdFbmQiLCJldmVudCIsImFjdGl2ZSIsIm92ZXIiLCJzb3VyY2VJbmRleCIsImRlc3RpbmF0aW9uSW5kZXgiLCJuZXdQb3NpdGlvbiIsIm1vdmVkQ29udGFpbmVyIiwic3BsaWNlIiwiaGFuZGxlQWxpZ25tZW50Q2hhbmdlIiwidmFsdWUiLCJwcmV2UG9zaXRpb25zIiwibWFwIiwiY29udGFpbmVyIiwiaWR4IiwiZGl2IiwiY2xhc3NOYW1lIiwib25EcmFnRW5kIiwic3BhbiIsIm9uQ2hhbmdlIiwiQ29udGFpbmVyIiwiYXR0cmlidXRlcyIsImxpc3RlbmVycyIsInNldE5vZGVSZWYiLCJ0cmFuc2Zvcm0iLCJpc0RyYWdnaW5nIiwidG9TdHJpbmciLCJpc092ZXIiLCJzZXREcm9wTm9kZVJlZiIsInN0YXJ0UHJvZHVjdEluZGV4IiwiZW5kUHJvZHVjdEluZGV4IiwibWluIiwicmVmIiwic3R5bGUiLCJtaW5IZWlnaHQiLCJzbGljZSIsInByb2R1Y3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/home/home.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/products/ProductItem.tsx":
/*!*********************************************!*\
  !*** ./components/products/ProductItem.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProductItem: function() { return /* binding */ ProductItem; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst ProductItem = (param)=>{\n    let { product } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col justify-center items-center\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"cube-loader\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"cube-top\"\n                        }, void 0, false, {\n                            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/ProductItem.tsx\",\n                            lineNumber: 8,\n                            columnNumber: 9\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"cube-wrapper\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    style: {\n                                        \"--i\": 0\n                                    },\n                                    className: \"cube-span\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/ProductItem.tsx\",\n                                    lineNumber: 10,\n                                    columnNumber: 11\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    style: {\n                                        \"--i\": 1\n                                    },\n                                    className: \"cube-span\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/ProductItem.tsx\",\n                                    lineNumber: 14,\n                                    columnNumber: 11\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    style: {\n                                        \"--i\": 2\n                                    },\n                                    className: \"cube-span\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/ProductItem.tsx\",\n                                    lineNumber: 18,\n                                    columnNumber: 11\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    style: {\n                                        \"--i\": 3\n                                    },\n                                    className: \"cube-span\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/ProductItem.tsx\",\n                                    lineNumber: 22,\n                                    columnNumber: 11\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/ProductItem.tsx\",\n                            lineNumber: 9,\n                            columnNumber: 9\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/ProductItem.tsx\",\n                    lineNumber: 7,\n                    columnNumber: 7\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/ProductItem.tsx\",\n                lineNumber: 6,\n                columnNumber: 5\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"text-sm pt-10\",\n                children: product.name\n            }, void 0, false, {\n                fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/ProductItem.tsx\",\n                lineNumber: 29,\n                columnNumber: 5\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"text-sm\",\n                children: [\n                    product.price,\n                    \" USD\"\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/ProductItem.tsx\",\n                lineNumber: 30,\n                columnNumber: 5\n            }, undefined)\n        ]\n    }, product.id, true, {\n        fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/ProductItem.tsx\",\n        lineNumber: 5,\n        columnNumber: 3\n    }, undefined);\n};\n_c = ProductItem;\nvar _c;\n$RefreshReg$(_c, \"ProductItem\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvcHJvZHVjdHMvUHJvZHVjdEl0ZW0udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQzBCO0FBRW5CLE1BQU1DLGNBQThDO1FBQUMsRUFBRUMsT0FBTyxFQUFFO3lCQUNyRSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNEOzBCQUNDLDRFQUFDQTtvQkFBSUMsV0FBVTs7c0NBQ2IsOERBQUNEOzRCQUFJQyxXQUFVOzs7Ozs7c0NBQ2YsOERBQUNEOzRCQUFJQyxXQUFVOzs4Q0FDYiw4REFBQ0M7b0NBQ0NDLE9BQU87d0NBQUUsT0FBTztvQ0FBRTtvQ0FDbEJGLFdBQVU7Ozs7Ozs4Q0FFWiw4REFBQ0M7b0NBQ0NDLE9BQU87d0NBQUUsT0FBTztvQ0FBRTtvQ0FDbEJGLFdBQVU7Ozs7Ozs4Q0FFWiw4REFBQ0M7b0NBQ0NDLE9BQU87d0NBQUUsT0FBTztvQ0FBRTtvQ0FDbEJGLFdBQVU7Ozs7Ozs4Q0FFWiw4REFBQ0M7b0NBQ0NDLE9BQU87d0NBQUUsT0FBTztvQ0FBRTtvQ0FDbEJGLFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQUtsQiw4REFBQ0M7Z0JBQUtELFdBQVU7MEJBQWlCRixRQUFRSyxJQUFJOzs7Ozs7MEJBQzdDLDhEQUFDRjtnQkFBS0QsV0FBVTs7b0JBQVdGLFFBQVFNLEtBQUs7b0JBQUM7Ozs7Ozs7O09BekJxQk4sUUFBUU8sRUFBRTs7Ozs7RUEyQjFFO0tBNUJXUiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL3Byb2R1Y3RzL1Byb2R1Y3RJdGVtLnRzeD8zZDE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByb2R1Y3QgfSBmcm9tIFwiQC9hcHAvdHlwZXMvcHJvZHVjdFwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgUHJvZHVjdEl0ZW06IFJlYWN0LkZDPHsgcHJvZHVjdDogUHJvZHVjdCB9PiA9ICh7IHByb2R1Y3QgfSkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCIga2V5PXtwcm9kdWN0LmlkfT5cbiAgICA8ZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjdWJlLWxvYWRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImN1YmUtdG9wXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY3ViZS13cmFwcGVyXCI+XG4gICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgIHN0eWxlPXt7IFwiLS1pXCI6IDAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiY3ViZS1zcGFuXCJcbiAgICAgICAgICA+PC9zcGFuPlxuICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICBzdHlsZT17eyBcIi0taVwiOiAxIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllc31cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImN1YmUtc3BhblwiXG4gICAgICAgICAgPjwvc3Bhbj5cbiAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgc3R5bGU9e3sgXCItLWlcIjogMiB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXN9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJjdWJlLXNwYW5cIlxuICAgICAgICAgID48L3NwYW4+XG4gICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgIHN0eWxlPXt7IFwiLS1pXCI6IDMgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiY3ViZS1zcGFuXCJcbiAgICAgICAgICA+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc20gcHQtMTBcIj57cHJvZHVjdC5uYW1lfTwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtXCI+e3Byb2R1Y3QucHJpY2V9IFVTRDwvc3Bhbj5cbiAgPC9kaXY+XG4pO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiUHJvZHVjdEl0ZW0iLCJwcm9kdWN0IiwiZGl2IiwiY2xhc3NOYW1lIiwic3BhbiIsInN0eWxlIiwibmFtZSIsInByaWNlIiwiaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/products/ProductItem.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/products/Products.tsx":
/*!******************************************!*\
  !*** ./components/products/Products.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _api_card__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/api/card */ \"(app-pages-browser)/./api/card.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _ProductItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ProductItem */ \"(app-pages-browser)/./components/products/ProductItem.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\nconst Products = (param)=>{\n    let { id } = param;\n    _s();\n    const [product, setProduct] = react__WEBPACK_IMPORTED_MODULE_2___default().useState(null);\n    react__WEBPACK_IMPORTED_MODULE_2___default().useEffect(()=>{\n        const fetchProduct = async ()=>{\n            const fetchedProducts = await (0,_api_card__WEBPACK_IMPORTED_MODULE_1__.getProducts)();\n            const product = fetchedProducts.find((product)=>Number(product.id) === id);\n            setProduct(product || null);\n        };\n        fetchProduct();\n    }, [\n        id\n    ]);\n    if (!product) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex justify-center w-full h-10\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ProductItem__WEBPACK_IMPORTED_MODULE_3__.ProductItem, {\n            product: product\n        }, void 0, false, {\n            fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/Products.tsx\",\n            lineNumber: 31,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/santiagoottolini/Documents/Downloads/Zara/components/products/Products.tsx\",\n        lineNumber: 30,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Products, \"Z7FRHGbVHGCoYLuEmDZnBWnFyd0=\");\n_c = Products;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Products);\nvar _c;\n$RefreshReg$(_c, \"Products\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvcHJvZHVjdHMvUHJvZHVjdHMudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXlDO0FBQ2Y7QUFDa0I7QUFPNUMsTUFBTUcsV0FBNEI7UUFBQyxFQUFFQyxFQUFFLEVBQUU7O0lBQ3ZDLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHTCxxREFBYyxDQUFpQjtJQUU3REEsc0RBQWUsQ0FBQztRQUNkLE1BQU1RLGVBQWU7WUFDbkIsTUFBTUMsa0JBQWtCLE1BQU1WLHNEQUFXQTtZQUN6QyxNQUFNSyxVQUFVSyxnQkFBZ0JDLElBQUksQ0FDbEMsQ0FBQ04sVUFBcUJPLE9BQU9QLFFBQVFELEVBQUUsTUFBTUE7WUFFL0NFLFdBQVdELFdBQVc7UUFDeEI7UUFFQUk7SUFDRixHQUFHO1FBQUNMO0tBQUc7SUFFUCxJQUFJLENBQUNDLFNBQVM7UUFDWixPQUFPO0lBQ1Q7SUFFQSxxQkFDRSw4REFBQ1E7UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ1oscURBQVdBO1lBQUNHLFNBQVNBOzs7Ozs7Ozs7OztBQUc1QjtHQXhCTUY7S0FBQUE7QUEwQk4sK0RBQWVBLFFBQVFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9wcm9kdWN0cy9Qcm9kdWN0cy50c3g/NzUwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRQcm9kdWN0cyB9IGZyb20gXCJAL2FwaS9jYXJkXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBQcm9kdWN0SXRlbSB9IGZyb20gXCIuL1Byb2R1Y3RJdGVtXCI7XG5pbXBvcnQgeyBQcm9kdWN0IH0gZnJvbSBcIkAvYXBwL3R5cGVzL3Byb2R1Y3RcIjtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgaWQ6IG51bWJlcjtcbn1cblxuY29uc3QgUHJvZHVjdHM6IFJlYWN0LkZDPFByb3BzPiA9ICh7IGlkIH0pID0+IHtcbiAgY29uc3QgW3Byb2R1Y3QsIHNldFByb2R1Y3RdID0gUmVhY3QudXNlU3RhdGU8UHJvZHVjdCB8IG51bGw+KG51bGwpO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZmV0Y2hQcm9kdWN0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmV0Y2hlZFByb2R1Y3RzID0gYXdhaXQgZ2V0UHJvZHVjdHMoKTtcbiAgICAgIGNvbnN0IHByb2R1Y3QgPSBmZXRjaGVkUHJvZHVjdHMuZmluZChcbiAgICAgICAgKHByb2R1Y3Q6IFByb2R1Y3QpID0+IE51bWJlcihwcm9kdWN0LmlkKSA9PT0gaWRcbiAgICAgICk7XG4gICAgICBzZXRQcm9kdWN0KHByb2R1Y3QgfHwgbnVsbCk7XG4gICAgfTtcblxuICAgIGZldGNoUHJvZHVjdCgpO1xuICB9LCBbaWRdKTtcblxuICBpZiAoIXByb2R1Y3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIHctZnVsbCBoLTEwXCI+XG4gICAgICA8UHJvZHVjdEl0ZW0gcHJvZHVjdD17cHJvZHVjdH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFByb2R1Y3RzO1xuIl0sIm5hbWVzIjpbImdldFByb2R1Y3RzIiwiUmVhY3QiLCJQcm9kdWN0SXRlbSIsIlByb2R1Y3RzIiwiaWQiLCJwcm9kdWN0Iiwic2V0UHJvZHVjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiZmV0Y2hQcm9kdWN0IiwiZmV0Y2hlZFByb2R1Y3RzIiwiZmluZCIsIk51bWJlciIsImRpdiIsImNsYXNzTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/products/Products.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/mocks/product.json":
/*!***********************************!*\
  !*** ./public/mocks/product.json ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = JSON.parse('[{"name":"Smartphone","price":"$999","id":"1"},{"name":"Laptop","price":"$1499","id":"2"},{"name":"Smartwatch","price":"$199","id":"3"},{"name":"Bluetooth Speaker","price":"$79","id":"4"},{"name":"Headphones","price":"$199","id":"5"},{"name":"Tablet","price":"$499","id":"6"},{"name":"Gaming Console","price":"$399","id":"7"},{"name":"Wireless Earbuds","price":"$149","id":"8"},{"name":"Smart TV","price":"$799","id":"9"},{"name":"Fitness Tracker","price":"$129","id":"10"},{"name":"Portable Charger","price":"$39","id":"11"},{"name":"Digital Camera","price":"$599","id":"12"},{"name":"Virtual Reality Headset","price":"$299","id":"13"},{"name":"Wireless Mouse","price":"$49","id":"14"},{"name":"External Hard Drive","price":"$129","id":"15"},{"name":"Smart Home Speaker","price":"$129","id":"16"},{"name":"Drones","price":"$499","id":"17"},{"name":"Gaming Keyboard","price":"$99","id":"18"},{"name":"Smart Thermostat","price":"$199","id":"19"},{"name":"E-book Reader","price":"$119","id":"20"},{"name":"Wireless Router","price":"$99","id":"21"},{"name":"Printers","price":"$199","id":"22"},{"name":"Computer Monitor","price":"$299","id":"23"},{"name":"Car Dash Cam","price":"$79","id":"24"},{"name":"Wireless Gaming Mouse","price":"$69","id":"25"},{"name":"Robot Vacuum","price":"$299","id":"26"},{"name":"Bluetooth Earphones","price":"$99","id":"27"},{"name":"Smart Doorbell","price":"$199","id":"28"},{"name":"Gaming Headset","price":"$129","id":"29"},{"name":"Wireless Keyboard","price":"$79","id":"30"},{"name":"Portable Bluetooth Speaker","price":"$59","id":"31"},{"name":"Security Cameras","price":"$299","id":"32"},{"name":"USB Flash Drive","price":"$19","id":"33"},{"name":"Wireless Charging Pad","price":"$29","id":"34"},{"name":"Smart Scale","price":"$49","id":"35"},{"name":"Noise Cancelling Headphones","price":"$299","id":"36"},{"name":"Smart Plug","price":"$29","id":"37"},{"name":"Graphics Card","price":"$699","id":"38"},{"name":"Wireless In-Ear Headphones","price":"$149","id":"39"},{"name":"Bluetooth Car Kit","price":"$39","id":"40"},{"name":"Gaming Mouse Pad","price":"$19","id":"41"},{"name":"Smart Lock","price":"$199","id":"42"},{"name":"Wireless Surround Sound System","price":"$499","id":"43"},{"name":"USB-C Hub","price":"$49","id":"44"},{"name":"Fitness Smartwatch","price":"$199","id":"45"},{"name":"Wireless Gaming Controller","price":"$79","id":"46"},{"name":"Portable Projector","price":"$299","id":"47"},{"name":"Bluetooth Keyboard","price":"$59","id":"48"},{"name":"Smart Mirror","price":"$399","id":"49"},{"name":"Wireless Webcam","price":"$129","id":"50"}]');

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsantiagoottolini%2FDocuments%2FDownloads%2FZara%2Fapp%2F%5Bid%5D%2Fpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);